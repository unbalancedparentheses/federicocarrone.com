<!doctype html>
<html lang="en">
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8" />
  <meta http-equiv="content-security-policy" content="default-src 'self'; child-src 'self' https://www.youtube-nocookie.com; script-src 'self' https://cloud.umami.is">
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <title>The Concrete Programming Language: Systems Programming for Formal Reasoning</title>

  <link rel="stylesheet" href="https://federicocarrone.com/style/min/main.css?h=89c3b5c6a96ec65c5b56" />
  <link rel="stylesheet" href="https://federicocarrone.com/style/min/syntax-theme.css?h=ef9797b0398b3ffe9058" />

  <meta name="author" content="Federico Carrone" />
  <meta name="description" content="federicocarrone.com" />
  <meta property="og:title" content="The Concrete Programming Language: Systems Programming for Formal Reasoning — from the series Concrete" />
  <meta property="og:site_name" content="federicocarrone.com" />
  <meta property="og:locale" content="en_US" />
  <meta property="og:type" content="article" />
  <meta property="og:url" content="https://federicocarrone.com/series/concrete/the-concrete-programming-language-systems-programming-for-formal-reasoning/" />
</head>
<body class="content-grid">

<nav id="menu" class="full-width content-grid">
  <ul>
    <li><a href="/">Home</a></li>
    <li><a href="https://federicocarrone.com/articles/">Articles</a></li>
    <li><a href="https://federicocarrone.com/series/">Series</a></li>
    <li><a href="/about">About</a></li>
  </ul>
</nav>

<main vocab="https://schema.org">

  <article class="series-episode" typeof="Article">
    <header>
      <h1 property="name">The Concrete Programming Language: Systems Programming for Formal Reasoning</h1>

      <nav property="isPartOf" typeof="CreativeWorkSeries">
        <p>From the series <a href="/series/concrete/" property="url"><span property="name">Concrete</span></a>.</p>
      </nav>

      
  <div class="metadata">
    <time title="Published date" datetime="2025-12-26" property="datePublished">December 26, 2025</time>
    <span title="Reading time" property="timeRequired" content="PT15M">15 minutes read</span>
    
      <span><a href="https://github.com/unbalancedparentheses/federicocarrone.com/edit/main/content/series&#x2F;concrete&#x2F;2025-12-26-the-concrete-programming-language-systems-programming-for-formal-reasoning&#x2F;index.md" title="Submit a patch for this page">Edit</a> this page</span>
      
    
  </div>

    </header>

    <p>There's a tension at the heart of systems programming. We want languages expressive enough to build complex systems, yet simple enough to reason about with confidence. We want performance without sacrificing safety. We want the freedom to write low-level code and the guarantees that come from formal verification.</p>
<p>Concrete is an attempt to resolve these tensions through commitment to a single organizing principle: <strong>every design choice must answer the question, can a machine reason about this?</strong></p>
<h2 id="the-core-idea">The Core Idea</h2>
<p>Most languages treat verification as something bolted on after the fact. You write code, then maybe you write tests, maybe you run a linter, maybe you bring in a theorem prover for critical sections. The language itself remains agnostic about provability.</p>
<p>Concrete inverts this relationship. The language is <em>designed around</em> a verified core, a small kernel calculus formalized in Lean with mechanically-checked proofs of progress, preservation, linearity soundness, and effect soundness. The surface language exists only to elaborate into this kernel. If your program type-checks, it's correct by construction.</p>
<h3 id="the-trust-boundary">The Trust Boundary</h3>
<p>Precision about what's verified matters. The kernel type system and its properties are mechanically checked in Lean. What remains trusted: the Lean proof checker itself, the elaborator (surface language to kernel), and the code generator (kernel to machine code). Verifying the elaborator and code generator is future work.</p>
<h2 id="the-compilation-pipeline">The Compilation Pipeline</h2>
<p>Understanding how Concrete programs become executables clarifies what guarantees you get and where:</p>
<pre class="z-code"><code><span class="z-text z-plain">Source Code (.concrete)
</span><span class="z-text z-plain">       ↓
</span><span class="z-text z-plain">   Lexer/Parser (LL(1) recursive descent)
</span><span class="z-text z-plain">       ↓
</span><span class="z-text z-plain">   Surface AST
</span><span class="z-text z-plain">       ↓
</span><span class="z-text z-plain">   Elaboration
</span><span class="z-text z-plain">     - Type checking
</span><span class="z-text z-plain">     - Linearity checking
</span><span class="z-text z-plain">     - Capability checking
</span><span class="z-text z-plain">     - Borrow/region checking
</span><span class="z-text z-plain">     - Defer insertion points
</span><span class="z-text z-plain">     - Allocator binding resolution
</span><span class="z-text z-plain">       ↓
</span><span class="z-text z-plain">   Kernel IR (core calculus)
</span><span class="z-text z-plain">       ↓
</span><span class="z-text z-plain">   Kernel Checker ← proven sound in Lean
</span><span class="z-text z-plain">       ↓
</span><span class="z-text z-plain">   Code Generation
</span><span class="z-text z-plain">       ↓
</span><span class="z-text z-plain">   Machine Code
</span></code></pre>
<p>The kernel checkpoint is the semantic gate. Everything before it transforms syntax; everything after it preserves meaning. The kernel checker verifies that the elaborated program satisfies linearity, capabilities, and effect constraints—properties proven sound in Lean.</p>
<h2 id="what-you-re-giving-up">What You're Giving Up</h2>
<p>Concrete is not a general-purpose language for every project. It's designed for code that <em>must</em> be correct: cryptographic implementations, financial systems, safety-critical software, blockchain infrastructure, anything where bugs have consequences measured in dollars or lives.</p>
<p>To get there, Concrete eliminates entire categories of language features:</p>
<p><strong>No garbage collection.</strong> Memory is managed through linear types and explicit destruction. Every resource is consumed exactly once. No GC pauses, no unpredictable latency, no hidden memory pressure.</p>
<p><strong>No hidden control flow.</strong> When you read Concrete code, what you see is what executes. There are no implicit function calls from operator overloading, no invisible destructor insertion, no exception unwinding behind your back. If a function is called, you see it. If cleanup happens, you see the <code>defer</code> statement.</p>
<p><strong>No implicit allocation.</strong> Allocation requires the <code>Alloc</code> capability, and the caller explicitly binds which allocator to use. <code>grep with(Alloc)</code> finds every function that might touch the heap.</p>
<p><strong>No interior mutability.</strong> All mutation flows through <code>&amp;mut</code> references. An immutable reference <code>&amp;T</code> actually guarantees immutability—no <code>Cell</code>, no <code>RefCell</code>, no <code>UnsafeCell</code> escape hatches in safe code. If you need a cache, pass <code>&amp;mut</code>. If you need lazy initialization, initialize before borrowing. For advanced patterns that genuinely require interior mutability, unsafe primitives gated by the <code>Unsafe</code> capability exist, but safe code cannot accidentally acquire interior mutability.</p>
<p><strong>No reflection, no eval, no runtime metaprogramming.</strong> All code paths are determined at compile time. This breaks certain patterns but makes verification tractable.</p>
<p><strong>No global state.</strong> All state is passed explicitly or accessed through capabilities.</p>
<p><strong>No variable shadowing.</strong> Each variable name is unique within its scope. This prevents a class of subtle bugs and makes code more auditable.</p>
<p><strong>No null.</strong> Optional values use <code>Option&lt;T&gt;</code>. No billion-dollar mistakes.</p>
<p><strong>No undefined behavior.</strong> Kernel semantics are fully defined and proven sound.</p>
<p>The result is a language that restricts what you can express in exchange for mechanical guarantees about what your code actually does.</p>
<h2 id="capabilities-making-effects-legible">Capabilities: Making Effects Legible</h2>
<p>The capability system is where Concrete's design philosophy becomes most visible. Rather than treating side effects as the default and purity as an opt-in annotation, Concrete is <strong>pure by default</strong>. A function without capability annotations cannot perform IO, cannot allocate, cannot mutate external state. It's a mathematical function that computes a result from its inputs, nothing more.</p>
<p>Purity in Concrete means no side effects and no heap allocation. Stack allocation and compile-time constants are permitted. Notably, Concrete does not guarantee termination—recursive functions may diverge. This is intentional: systems programming sometimes requires non-termination, but side effects must remain explicit.</p>
<p>When a function needs to perform effects, it declares exactly which ones:</p>
<pre class="z-code"><code><span class="z-text z-plain">fn read_file(path: String) with(FileRead) -&gt; String {
</span><span class="z-text z-plain">    ...
</span><span class="z-text z-plain">}
</span><span class="z-text z-plain">
</span><span class="z-text z-plain">fn process_with_network() with(FileRead, Network, Alloc) -&gt; Result {
</span><span class="z-text z-plain">    ...
</span><span class="z-text z-plain">}
</span></code></pre>
<p>Capabilities propagate monotonically through the call graph. If <code>f</code> calls <code>g</code>, and <code>g</code> requires <code>FileRead</code>, then <code>f</code> must declare <code>FileRead</code> too. There's no implicit granting, no ambient authority. The compiler enforces this transitively, making all effects visible in signatures.</p>
<h3 id="the-std-capability">The <code>Std</code> Capability</h3>
<p>For application entry points and prototyping, Concrete provides a shorthand. The <code>!</code> suffix declares the <code>Std</code> capability:</p>
<pre class="z-code"><code><span class="z-text z-plain">fn main!() {
</span><span class="z-text z-plain">    println(&quot;Hello&quot;)
</span><span class="z-text z-plain">}
</span></code></pre>
<p>This desugars to <code>fn main() with(Std)</code>. The <code>Std</code> capability includes common platform effects—file operations, network, clock, environment, random, and allocation—but explicitly excludes <code>Unsafe</code>. Library code should prefer explicit capability lists; <code>!</code> is a convenience for applications.</p>
<h3 id="security-model">Security Model</h3>
<p>Capabilities don't sandbox code—if a dependency declares <code>with(Network)</code>, it gets network access. What they provide is <strong>auditability</strong>. You can grep your codebase for <code>with(Network)</code> and find every function that touches the network. You can verify that your JSON parser has no capabilities at all. You can review dependency updates by diffing capability declarations.</p>
<p>The <code>Unsafe</code> capability surfaces all unsafe operations through the same system. There's no <code>unsafe</code> keyword; instead, unsafe operations require declaring <code>with(Unsafe)</code>, and that requirement propagates like any other capability. Your trust boundaries become grep-able.</p>
<h2 id="linear-types-resources-as-values">Linear Types: Resources as Values</h2>
<p>All values in Concrete are linear by default. A linear value must be consumed exactly once—not zero times (that's a leak), not twice (that's a double-free). Consumption happens when you pass the value to a function that takes ownership, return it, destructure it via pattern matching, or explicitly call <code>destroy(x)</code>.</p>
<pre class="z-code"><code><span class="z-text z-plain">fn example!() {
</span><span class="z-text z-plain">    let f = open(&quot;data.txt&quot;)
</span><span class="z-text z-plain">    defer destroy(f)
</span><span class="z-text z-plain">    let content = read(&amp;f)
</span><span class="z-text z-plain">    // destroy(f) runs here because of defer
</span><span class="z-text z-plain">}
</span></code></pre>
<p>If <code>f</code> isn't consumed on all paths, the program is rejected. If you try to use <code>f</code> after moving it, the program is rejected. This is compile-time enforcement, not runtime checking.</p>
<p>Some types—integers, booleans, floats—are explicitly marked <code>Copy</code> and escape linear restrictions:</p>
<pre class="z-code"><code><span class="z-text z-plain">type Copy Int
</span><span class="z-text z-plain">type Copy Bool
</span><span class="z-text z-plain">type Copy Float64
</span></code></pre>
<p>But the default is linearity, which forces you to think about resource ownership as you write code rather than hoping the runtime sorts it out.</p>
<h3 id="destructors">Destructors</h3>
<p>A linear type may define a destructor that executes when <code>destroy(x)</code> is called:</p>
<pre class="z-code"><code><span class="z-text z-plain">type File {
</span><span class="z-text z-plain">    handle: FileHandle
</span><span class="z-text z-plain">}
</span><span class="z-text z-plain">
</span><span class="z-text z-plain">destroy File with(FileClose) {
</span><span class="z-text z-plain">    platform_close(self.handle)
</span><span class="z-text z-plain">}
</span></code></pre>
<p>The destructor takes ownership of <code>self</code>, may require capabilities, and runs exactly once when explicitly invoked. Crucially, <code>destroy(x)</code> is only valid if the type defines a destructor. A type without a destructor cannot be destroyed—it must be consumed by moving, returning, or destructuring. This prevents accidental discard and forces resource handling through program logic.</p>
<h3 id="defer-explicit-cleanup">Defer: Explicit Cleanup</h3>
<p>The <code>defer</code> statement makes cleanup explicit. Unlike languages where destructors run implicitly at scope boundaries, Concrete requires you to write <code>defer destroy(f)</code>. You see the cleanup in the source. The compiler never secretly inserts destructor calls.</p>
<pre class="z-code"><code><span class="z-text z-plain">fn process_files!() {
</span><span class="z-text z-plain">    let f1 = open(&quot;a.txt&quot;)
</span><span class="z-text z-plain">    defer destroy(f1)           // you see this
</span><span class="z-text z-plain">    
</span><span class="z-text z-plain">    let f2 = open(&quot;b.txt&quot;)
</span><span class="z-text z-plain">    defer destroy(f2)           // you see this
</span><span class="z-text z-plain">    
</span><span class="z-text z-plain">    // When scope exits:
</span><span class="z-text z-plain">    // 1. destroy(f2) runs
</span><span class="z-text z-plain">    // 2. destroy(f1) runs
</span><span class="z-text z-plain">}
</span></code></pre>
<p>Multiple <code>defer</code> statements execute in reverse order (LIFO). <code>defer</code> runs at scope exit including early returns and error propagation. It's deterministic—not "eventually" like GC finalizers.</p>
<p>When a value is scheduled with <code>defer destroy(x)</code>, it becomes reserved. You cannot move it, destroy it again, or create borrows that might overlap the deferred destruction point.</p>
<h2 id="borrowing-without-lifetime-annotations">Borrowing Without Lifetime Annotations</h2>
<p>Concrete's borrowing system draws from Rust but simplifies it. References exist within lexical regions—scopes that bound their lifetime. You can have multiple immutable borrows or one mutable borrow. References can't escape their region.</p>
<pre class="z-code"><code><span class="z-text z-plain">borrow f as fref in R {
</span><span class="z-text z-plain">    // fref has type &amp;[File, R]
</span><span class="z-text z-plain">    // f is unusable in this block
</span><span class="z-text z-plain">    let len = length(fref)
</span><span class="z-text z-plain">}
</span><span class="z-text z-plain">// f is usable again
</span></code></pre>
<p>The key difference from Rust: no lifetime parameters in function signatures. Functions that accept references are generic over the region, but this genericity is implicit:</p>
<pre class="z-code"><code><span class="z-text z-plain">fn length&lt;R&gt;(file: &amp;[File, R]) -&gt; Uint {
</span><span class="z-text z-plain">    ...
</span><span class="z-text z-plain">}
</span></code></pre>
<p>The function cannot store the reference because it has no way to name <code>R</code> outside the call. The region system ensures references can't outlive their source, but you don't annotate lifetimes everywhere.</p>
<p>For single-expression borrows, the region is anonymous:</p>
<pre class="z-code"><code><span class="z-text z-plain">let len = length(&amp;f)  // borrows f for just this call
</span></code></pre>
<h3 id="borrowing-rules">Borrowing Rules</h3>
<p>The rules are strict but comprehensible:</p>
<ol>
<li>While borrowed, the original is unusable</li>
<li>Multiple immutable borrows are allowed</li>
<li>Mutable borrows are exclusive—one <code>&amp;mut T</code> at a time, no simultaneous <code>&amp;T</code></li>
<li>References cannot escape their region</li>
<li>Nested borrows of the same owned value are forbidden</li>
<li>Borrowing a reference is allowed, but the derived reference can't outlive the original's region</li>
</ol>
<p>Closures may not capture references if the closure escapes the borrow region. This ensures references never outlive their lexical scope.</p>
<h2 id="allocation-as-a-capability">Allocation as a Capability</h2>
<p>Allocation deserves special attention because it's so often invisible. In most languages, many operations allocate behind your back—string concatenation, collection growth, closure creation. You find out about allocation pressure through profiling or by hitting OOM.</p>
<p>Concrete treats allocation as a capability. Functions that may allocate declare <code>with(Alloc)</code>. The call site binds which allocator to use:</p>
<pre class="z-code"><code><span class="z-text z-plain">fn main!() {
</span><span class="z-text z-plain">    let arena = Arena.new()
</span><span class="z-text z-plain">    defer arena.deinit()
</span><span class="z-text z-plain">    
</span><span class="z-text z-plain">    let list = create_list&lt;Int&gt;() with(Alloc = arena)
</span><span class="z-text z-plain">    push(&amp;mut list, 42) with(Alloc = arena)
</span><span class="z-text z-plain">}
</span></code></pre>
<p>Inside a function with <code>with(Alloc)</code>, allocation "just works"—the bound allocator propagates through nested calls. But at the boundary, you see exactly where allocation happens and which allocator serves it.</p>
<p>Allocator binding is lexically scoped. A nested binding may shadow an outer one. Closures capture allocator bindings only if invoked within the lexical scope where the binding is in effect—if a closure escapes, it must accept an explicit allocator parameter.</p>
<p>Stack allocation does not require the <code>Alloc</code> capability:</p>
<pre class="z-code"><code><span class="z-text z-plain">fn example() {
</span><span class="z-text z-plain">    let x: Int = 42                    // stack
</span><span class="z-text z-plain">    let arr: [100]Uint8 = zeroed()     // stack
</span><span class="z-text z-plain">}
</span></code></pre>
<p>This makes allocation-free code provably allocation-free.</p>
<h3 id="allocator-types">Allocator Types</h3>
<p>Concrete provides several allocator types out of the box:</p>
<pre class="z-code"><code><span class="z-text z-plain">// General-purpose heap allocator
</span><span class="z-text z-plain">let gpa = GeneralPurposeAllocator.new()
</span><span class="z-text z-plain">defer gpa.deinit()
</span><span class="z-text z-plain">
</span><span class="z-text z-plain">// Arena allocator — free everything at once
</span><span class="z-text z-plain">let arena = Arena.new(gpa)
</span><span class="z-text z-plain">defer arena.deinit()
</span><span class="z-text z-plain">
</span><span class="z-text z-plain">// Fixed buffer allocator — no heap, uses stack memory
</span><span class="z-text z-plain">let buf: [1024]Uint8 = zeroed()
</span><span class="z-text z-plain">let fba = FixedBufferAllocator.new(&amp;buf)
</span></code></pre>
<p>All allocators implement a common <code>Allocator</code> trait with <code>alloc</code>, <code>free</code>, and <code>realloc</code> methods.</p>
<h2 id="error-handling">Error Handling</h2>
<p>Errors are values, not exceptions:</p>
<pre class="z-code"><code><span class="z-text z-plain">fn parse(input: String) -&gt; Result&lt;Config, ParseError&gt; {
</span><span class="z-text z-plain">    ...
</span><span class="z-text z-plain">}
</span><span class="z-text z-plain">
</span><span class="z-text z-plain">fn load_config!() -&gt; Result&lt;Config, Error&gt; {
</span><span class="z-text z-plain">    let f = open(&quot;config.toml&quot;)?
</span><span class="z-text z-plain">    defer destroy(f)
</span><span class="z-text z-plain">    
</span><span class="z-text z-plain">    let content = read(&amp;f)
</span><span class="z-text z-plain">    let config = parse(content)?
</span><span class="z-text z-plain">    Ok(config)
</span><span class="z-text z-plain">}
</span></code></pre>
<p>The <code>?</code> operator propagates errors. When <code>?</code> triggers an early return, all <code>defer</code> statements in scope run before returning. This interaction is crucial—cleanup happens even on error paths, and you can see exactly where.</p>
<p>There are no exceptions and no panic mechanism in the core language. If the runtime terminates due to an unrecoverable fault, deferred expressions are not guaranteed to run.</p>
<h2 id="pattern-matching">Pattern Matching</h2>
<p>Exhaustive pattern matching with linear type awareness:</p>
<pre class="z-code"><code><span class="z-text z-plain">fn describe(opt: Option&lt;Int&gt;) -&gt; String {
</span><span class="z-text z-plain">    match opt {
</span><span class="z-text z-plain">        Some(n) =&gt; format(&quot;Got {}&quot;, n),
</span><span class="z-text z-plain">        None =&gt; &quot;Nothing&quot;
</span><span class="z-text z-plain">    }
</span><span class="z-text z-plain">}
</span></code></pre>
<p>Linear types in patterns must be consumed:</p>
<pre class="z-code"><code><span class="z-text z-plain">fn handle!(result: Result&lt;Data, File&gt;) {
</span><span class="z-text z-plain">    match result {
</span><span class="z-text z-plain">        Ok(data) =&gt; use_data(data),
</span><span class="z-text z-plain">        Err(f) =&gt; destroy(f)
</span><span class="z-text z-plain">    }
</span><span class="z-text z-plain">}
</span></code></pre>
<p>Both branches consume their linear values. Borrowing in patterns is also supported:</p>
<pre class="z-code"><code><span class="z-text z-plain">fn peek(opt: &amp;Option&lt;Int&gt;) -&gt; Int {
</span><span class="z-text z-plain">    match opt {
</span><span class="z-text z-plain">        &amp;Some(n) =&gt; n,
</span><span class="z-text z-plain">        &amp;None =&gt; 0
</span><span class="z-text z-plain">    }
</span><span class="z-text z-plain">}
</span></code></pre>
<h2 id="traits-and-bounded-polymorphism">Traits and Bounded Polymorphism</h2>
<p>Traits provide bounded polymorphism:</p>
<pre class="z-code"><code><span class="z-text z-plain">trait Ord {
</span><span class="z-text z-plain">    fn compare(&amp;self, other: &amp;Self) -&gt; Ordering
</span><span class="z-text z-plain">}
</span><span class="z-text z-plain">
</span><span class="z-text z-plain">trait Show {
</span><span class="z-text z-plain">    fn show(&amp;self) -&gt; String
</span><span class="z-text z-plain">}
</span><span class="z-text z-plain">
</span><span class="z-text z-plain">fn sort&lt;T: Ord&gt;(list: List&lt;T&gt;) with(Alloc) -&gt; List&lt;T&gt; {
</span><span class="z-text z-plain">    ...
</span><span class="z-text z-plain">}
</span><span class="z-text z-plain">
</span><span class="z-text z-plain">fn sort_and_print&lt;T: Ord + Show&gt;(list: List&lt;T&gt;) with(Alloc, Console) -&gt; List&lt;T&gt; {
</span><span class="z-text z-plain">    let sorted = sort(list)
</span><span class="z-text z-plain">    print_all(&amp;sorted)
</span><span class="z-text z-plain">    sorted
</span><span class="z-text z-plain">}
</span></code></pre>
<p>Trait methods may take the receiver as <code>&amp;self</code>, <code>&amp;mut self</code>, or <code>self</code>. If a trait method takes <code>self</code>, calling it consumes the value following linear consumption rules. Trait implementations for linear types are allowed—they just must respect the receiver mode.</p>
<h2 id="generics-and-parametricity">Generics and Parametricity</h2>
<p>Generic functions cannot accidentally become effectful depending on instantiation. Capabilities are checked before monomorphization and are invariant under instantiation:</p>
<pre class="z-code"><code><span class="z-text z-plain">fn map&lt;T, U&gt;(list: List&lt;T&gt;, f: fn(T) -&gt; U) -&gt; List&lt;U&gt; {
</span><span class="z-text z-plain">    ...
</span><span class="z-text z-plain">}
</span></code></pre>
<p>This function is pure regardless of what <code>T</code> and <code>U</code> are. If <code>f</code> requires capabilities, that must be declared:</p>
<pre class="z-code"><code><span class="z-text z-plain">fn map_io&lt;T, U&gt;(list: List&lt;T&gt;, f: fn(T) with(IO) -&gt; U) with(IO) -&gt; List&lt;U&gt; {
</span><span class="z-text z-plain">    ...
</span><span class="z-text z-plain">}
</span></code></pre>
<p>There's no capability polymorphism—you cannot be generic over capability sets. Each capability set must be concrete. This simplifies the type system and avoids questions about capability set operations at the type level.</p>
<h2 id="type-inference">Type Inference</h2>
<p>Type inference is <strong>local only</strong>:</p>
<ul>
<li>Function signatures must be fully annotated (parameters, return type, capabilities)</li>
<li>Inside function bodies, local variable types may be inferred from their initializers</li>
<li>Type information flows in one direction (from annotations to inference, never backward)</li>
</ul>
<pre class="z-code"><code><span class="z-text z-plain">fn process(data: List&lt;Int&gt;) with(Alloc) -&gt; List&lt;Int&gt; {
</span><span class="z-text z-plain">    let doubled = map(data, fn(x) { x * 2 })  // type inferred
</span><span class="z-text z-plain">    let filtered = filter(doubled, fn(x) { x &gt; 0 })  // type inferred
</span><span class="z-text z-plain">    filtered
</span><span class="z-text z-plain">}
</span></code></pre>
<p>This keeps type errors local and makes signatures self-documenting. You can always understand a function's interface without reading its body.</p>
<h2 id="modules">Modules</h2>
<pre class="z-code"><code><span class="z-text z-plain">module FileSystem
</span><span class="z-text z-plain">
</span><span class="z-text z-plain">public fn open(path: String) with(FileOpen) -&gt; Result&lt;File, IOError&gt; {
</span><span class="z-text z-plain">    ...
</span><span class="z-text z-plain">}
</span><span class="z-text z-plain">
</span><span class="z-text z-plain">public fn read&lt;R&gt;(file: &amp;[File, R]) with(FileRead) -&gt; String {
</span><span class="z-text z-plain">    ...
</span><span class="z-text z-plain">}
</span><span class="z-text z-plain">
</span><span class="z-text z-plain">private fn validate(path: String) -&gt; Bool {
</span><span class="z-text z-plain">    ...
</span><span class="z-text z-plain">}
</span></code></pre>
<p>Visibility is <code>public</code> or <code>private</code> (the default). Types, functions, and constants can be marked either way.</p>
<p>Capabilities are part of a function's signature and therefore part of the public API contract. Changing the required capability set of a public function is a breaking change.</p>
<p>Imports support aliasing and selective imports:</p>
<pre class="z-code"><code><span class="z-text z-plain">import FileSystem
</span><span class="z-text z-plain">import FileSystem.{open, read, write}
</span><span class="z-text z-plain">import FileSystem as FS
</span></code></pre>
<h2 id="types">Types</h2>
<h3 id="primitives">Primitives</h3>
<pre class="z-code"><code><span class="z-text z-plain">Bool
</span><span class="z-text z-plain">Int, Int8, Int16, Int32, Int64
</span><span class="z-text z-plain">Uint, Uint8, Uint16, Uint32, Uint64
</span><span class="z-text z-plain">Float32, Float64
</span><span class="z-text z-plain">Char, String
</span></code></pre>
<p>All primitive numeric types and <code>Bool</code> are <code>Copy</code>. <code>String</code> is linear.</p>
<h3 id="algebraic-data-types">Algebraic Data Types</h3>
<pre class="z-code"><code><span class="z-text z-plain">type Option&lt;T&gt; {
</span><span class="z-text z-plain">    Some(T),
</span><span class="z-text z-plain">    None
</span><span class="z-text z-plain">}
</span><span class="z-text z-plain">
</span><span class="z-text z-plain">type Result&lt;T, E&gt; {
</span><span class="z-text z-plain">    Ok(T),
</span><span class="z-text z-plain">    Err(E)
</span><span class="z-text z-plain">}
</span><span class="z-text z-plain">
</span><span class="z-text z-plain">type List&lt;T&gt; {
</span><span class="z-text z-plain">    Nil,
</span><span class="z-text z-plain">    Cons(T, List&lt;T&gt;)
</span><span class="z-text z-plain">}
</span></code></pre>
<h3 id="records">Records</h3>
<pre class="z-code"><code><span class="z-text z-plain">type Point {
</span><span class="z-text z-plain">    x: Float64,
</span><span class="z-text z-plain">    y: Float64
</span><span class="z-text z-plain">}
</span></code></pre>
<p>A record is <code>Copy</code> only if explicitly marked and all fields are <code>Copy</code>:</p>
<pre class="z-code"><code><span class="z-text z-plain">type Copy Point {
</span><span class="z-text z-plain">    x: Float64,
</span><span class="z-text z-plain">    y: Float64
</span><span class="z-text z-plain">}
</span></code></pre>
<p>For generic types, linearity depends on the type parameter. <code>Option&lt;Int&gt;</code> is <code>Copy</code> because <code>Int</code> is. <code>Option&lt;File&gt;</code> is linear because <code>File</code> is.</p>
<h3 id="standard-library-types">Standard Library Types</h3>
<p>For domains where precision matters, the standard library includes:</p>
<ul>
<li><strong>Decimal</strong> — Fixed-point decimal arithmetic for financial calculations</li>
<li><strong>BigInt</strong> — Arbitrary-precision integers</li>
<li><strong>BigDecimal</strong> — Arbitrary-precision decimals</li>
</ul>
<p>These avoid floating-point representation errors in financial systems and cryptographic applications.</p>
<h2 id="determinism">Determinism</h2>
<h3 id="reproducible-builds">Reproducible Builds</h3>
<p>Concrete aims for <strong>bit-for-bit reproducible builds</strong>:</p>
<ul>
<li>Same source code + same compiler version = identical binary</li>
<li>No timestamps, random seeds, or environment-dependent data embedded in output</li>
<li>Build order does not affect output</li>
</ul>
<h3 id="perfect-replayability">Perfect Replayability</h3>
<p>For debugging, Concrete supports <strong>deterministic replay</strong>:</p>
<ul>
<li>All sources of non-determinism are explicit and controllable</li>
<li>Random number generation requires <code>Random</code> capability with explicit seed</li>
<li>System time requires <code>Clock</code> capability</li>
<li>Given the same inputs and capability bindings, execution is identical</li>
</ul>
<p>This enables reproducing Heisenbugs that depend on timing or randomness. When your program behaves the same way every time given the same inputs, debugging becomes tractable.</p>
<h2 id="the-grammar-as-guarantee">The Grammar as Guarantee</h2>
<p>Concrete uses an LL(1) grammar. Every parsing decision can be made with a single token of lookahead. No ambiguity, no backtracking, no lexer hacks.</p>
<p>This might seem like an implementation detail, but it has consequences for the developer experience. Simple tooling can parse Concrete—any LL(1) parser generator works. Syntax errors are local and comprehensible. There are no parser edge cases that behave differently in different tools.</p>
<p>The grammar enforces stylistic constraints: keywords are reserved, statements and expressions are syntactically distinct, blocks use braces, standard operator precedence is built in. You can't invent surprising syntax.</p>
<h2 id="compilation-targets">Compilation Targets</h2>
<p>Concrete supports multiple backends:</p>
<ul>
<li><strong>Native</strong> — Direct machine code via MLIR/LLVM</li>
<li><strong>C</strong> — Portable C output for maximum platform support</li>
<li><strong>WebAssembly</strong> — For browser and edge deployment</li>
</ul>
<p>Cross-compilation is a first-class feature. Specify target at build time.</p>
<h2 id="tooling">Tooling</h2>
<p>Unlike languages where essential tooling is an afterthought or third-party dependency, Concrete ships with built-in tools:</p>
<ul>
<li><strong>Package manager</strong> — Dependency resolution and versioning</li>
<li><strong>Formatter</strong> — Canonical code formatting (one true style)</li>
<li><strong>Linter</strong> — Static analysis and style checking</li>
<li><strong>Test runner</strong> — Built-in test framework</li>
<li><strong>REPL</strong> — Interactive evaluation for debugging and exploration</li>
</ul>
<p>These are part of the language distribution, not external dependencies with their own versioning and compatibility concerns.</p>
<h2 id="profiling-and-tracing">Profiling and Tracing</h2>
<p>Profiling and tracing are first-class features:</p>
<ul>
<li>Built into the runtime, not bolted on</li>
<li>Low overhead when disabled</li>
<li>Structured output for tooling integration</li>
</ul>
<p>While code is read more often than written, it is executed even more often than read. Performance visibility matters, especially for systems programming.</p>
<h2 id="what-you-can-say-about-programs">What You Can Say About Programs</h2>
<p>If a program type-checks in Concrete, you gain mechanical knowledge about it:</p>
<p><strong>"This function is pure."</strong> No capabilities declared. The compiler proves it performs no side effects, no IO, no mutation, no allocation. You can reason about it as a mathematical function.</p>
<p><strong>"This resource is used exactly once."</strong> Linear type. The compiler proves no leaks, no double-free, no use-after-free.</p>
<p><strong>"These are the only effects this code can perform."</strong> Capability set is explicit. It cannot secretly touch the network or file system.</p>
<p><strong>"This code cannot escape the type system."</strong> Unsafe operations require <code>with(Unsafe)</code>. You can grep for all trust boundaries.</p>
<p><strong>"Allocation happens here, using this allocator."</strong> Call site binds the allocator. No hidden heap activity.</p>
<p><strong>"Cleanup happens here."</strong> <code>defer destroy(x)</code> is visible. The compiler doesn't insert invisible destructor calls.</p>
<p><strong>"This build is reproducible."</strong> Same inputs, same binary. Debugging is tractable.</p>
<p>These are mechanical guarantees derived from the type system, which is itself proven sound in Lean. Not best practices, not conventions—proofs.</p>
<h2 id="example-file-processing">Example: File Processing</h2>
<pre class="z-code"><code><span class="z-text z-plain">module Main
</span><span class="z-text z-plain">
</span><span class="z-text z-plain">import FileSystem.{open, read, write}
</span><span class="z-text z-plain">import Parse.{parse_csv}
</span><span class="z-text z-plain">
</span><span class="z-text z-plain">fn process_file!(input_path: String, output_path: String) with(Alloc) -&gt; Result&lt;(), Error&gt; {
</span><span class="z-text z-plain">    let in_file = open(input_path)?
</span><span class="z-text z-plain">    defer destroy(in_file)
</span><span class="z-text z-plain">    
</span><span class="z-text z-plain">    let content = read(&amp;in_file)
</span><span class="z-text z-plain">    let data = parse_csv(content)?
</span><span class="z-text z-plain">    let output = transform(&amp;data)
</span><span class="z-text z-plain">    
</span><span class="z-text z-plain">    let out_file = open(output_path)?
</span><span class="z-text z-plain">    defer destroy(out_file)
</span><span class="z-text z-plain">    
</span><span class="z-text z-plain">    write(&amp;mut out_file, output)
</span><span class="z-text z-plain">    Ok(())
</span><span class="z-text z-plain">}
</span><span class="z-text z-plain">
</span><span class="z-text z-plain">fn transform(data: &amp;List&lt;Row&gt;) -&gt; String {
</span><span class="z-text z-plain">    ...
</span><span class="z-text z-plain">}
</span><span class="z-text z-plain">
</span><span class="z-text z-plain">fn main!() {
</span><span class="z-text z-plain">    let arena = Arena.new()
</span><span class="z-text z-plain">    defer arena.deinit()
</span><span class="z-text z-plain">    
</span><span class="z-text z-plain">    match process_file(&quot;input.csv&quot;, &quot;output.txt&quot;) with(Alloc = arena) {
</span><span class="z-text z-plain">        Ok(()) =&gt; println(&quot;Done&quot;),
</span><span class="z-text z-plain">        Err(e) =&gt; println(&quot;Error: &quot; + e.message())
</span><span class="z-text z-plain">    }
</span><span class="z-text z-plain">}
</span></code></pre>
<p>Everything is visible: resource acquisition, cleanup scheduling, error propagation, allocator binding. No hidden control flow.</p>
<h2 id="who-should-use-this">Who Should Use This</h2>
<p>Concrete is not for every project. It trades convenience for explicitness, flexibility for auditability. Prototyping is slower. Some patterns become verbose or impossible. You'll miss interior mutability when building certain data structures. You'll miss runtime reflection when building serialization libraries.</p>
<p>But for code where correctness is paramount—cryptographic primitives, consensus protocols, financial transaction systems, medical device firmware—the trade is worth it. You get a language where you can make strong claims about program behavior and those claims are mechanically verified.</p>
<p>The verified kernel means the language semantics won't drift. The capability system means effects are auditable. The linear types mean resources are managed with precision. The LL(1) grammar means tooling is straightforward. Reproducible builds mean debugging is tractable.</p>
<p>Concrete aims to be a language you can trust the way you trust mathematics: not because someone promises it works, but because you can check the proof yourself.</p>
<hr />
<h2 id="quick-reference">Quick Reference</h2>
<table><thead><tr><th>Annotation</th><th>Meaning</th></tr></thead><tbody>
<tr><td><code>fn foo() -&gt; T</code></td><td>Pure function, no capabilities, no allocation</td></tr>
<tr><td><code>fn foo!() -&gt; T</code></td><td>Shorthand for <code>with(Std)</code></td></tr>
<tr><td><code>fn foo() with(C) -&gt; T</code></td><td>Requires capability set <code>C</code></td></tr>
<tr><td><code>with(Alloc)</code></td><td>Function may allocate</td></tr>
<tr><td><code>with(Alloc = a)</code></td><td>Bind allocator <code>a</code> at call site</td></tr>
<tr><td><code>T</code></td><td>Linear type, must be consumed exactly once</td></tr>
<tr><td><code>type Copy T</code></td><td>Unrestricted type, can be copied or ignored</td></tr>
<tr><td><code>&amp;T</code> or <code>&amp;[T, R]</code></td><td>Immutable reference in region <code>R</code></td></tr>
<tr><td><code>&amp;mut T</code> or <code>&amp;mut [T, R]</code></td><td>Mutable reference in region <code>R</code></td></tr>
<tr><td><code>borrow x as y in R { }</code></td><td>Explicit borrow with named region</td></tr>
<tr><td><code>defer expr</code></td><td>Run <code>expr</code> when scope exits</td></tr>
<tr><td><code>destroy(x)</code></td><td>Consume <code>x</code> via destructor</td></tr>
<tr><td><code>destroy T with(C) { }</code></td><td>Define destructor for type <code>T</code> requiring capability <code>C</code></td></tr>
</tbody></table>


    <nav class="previous-next-episodes"><div class="button button--disabled text-align-end">(coming soon)&nbsp;❯</div></nav>
  </article>

</main>

<footer class="full-width content-grid">
  <div class="footer">
    <div>
      <h2>Contact me</h2>

      <ul>
        <li><a href="mailto:mail@fcarrone.com" title="Email">mail@fcarrone.com</a></li>
        <li><a href="https://x.com/federicocarrone" title="Say hi on X" rel="me">X</a></li>
        <li><a href="https://github.com/unbalancedparentheses" title="Say hi on Github">Github</a></li>
      </ul>
    </div>
    <div>
      <h2>Recommendations</h2>

      <ul>
        <li><a href="https://ergodicgroup.com">ergodicgroup.com</a></li>
        <li><a href="https://lambdaclass.com/">lambdaclass.com</a></li>
      </ul>
    </div>

    <div>
      <h2>More</h2>

      <ul>
        <li><a href="https://federicocarrone.com/rss.xml">RSS</a></li>
        <li><a href="https://federicocarrone.com/atom.xml">Atom</a></li>
        <li><a href="https://github.com/unbalancedparentheses/federicocarrone.com" title="Source code of this site">Source code</a></li>
      </ul>
    </div>
  </div>
</footer>

<script defer src="https://cloud.umami.is/script.js" data-website-id=""></script>
</body>
</html>
