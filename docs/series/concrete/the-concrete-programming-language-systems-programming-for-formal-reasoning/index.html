<!doctype html>
<html lang="en">
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8" />

  <meta
  http-equiv="content-security-policy"
  content="default-src 'self'; child-src 'self' https://www.youtube-nocookie.com; script-src 'self' https://cloud.umami.is; connect-src 'self' https://api-gateway.umami.dev"
  >

  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <title>The Concrete Programming Language: Systems Programming for Formal Reasoning</title>

  <link rel="stylesheet" href="https://federicocarrone.com/style/min/main.css?h=89c3b5c6a96ec65c5b56" />
  <link rel="stylesheet" href="https://federicocarrone.com/style/min/syntax-theme.css?h=ef9797b0398b3ffe9058" />

  <meta name="author" content="Federico Carrone" />
  <meta name="description" content="federicocarrone.com" />
  <meta property="og:title" content="The Concrete Programming Language: Systems Programming for Formal Reasoning — from the series Concrete" />
  <meta property="og:site_name" content="federicocarrone.com" />
  <meta property="og:locale" content="en_US" />
  <meta property="og:type" content="article" />
  <meta property="og:url" content="https://federicocarrone.com/series/concrete/the-concrete-programming-language-systems-programming-for-formal-reasoning/" />

  <script defer src="https://cloud.umami.is/script.js" data-website-id="062ee306-b2e8-479b-80fd-1afeefa0bb29"></script>
</head>
<body class="content-grid">

<nav id="menu" class="full-width content-grid">
  <ul>
    <li><a href="/">Home</a></li>
    <li><a href="https://federicocarrone.com/articles/">Articles</a></li>
    <li><a href="https://federicocarrone.com/series/">Series</a></li>
    <li><a href="/about">About</a></li>
  </ul>
</nav>

<main vocab="https://schema.org">

  <article class="series-episode" typeof="Article">
    <header>
      <h1 property="name">The Concrete Programming Language: Systems Programming for Formal Reasoning</h1>

      <nav property="isPartOf" typeof="CreativeWorkSeries">
        <p>From the series <a href="/series/concrete/" property="url"><span property="name">Concrete</span></a>.</p>
      </nav>

      
  <div class="metadata">
    <time title="Published date" datetime="2025-12-26" property="datePublished">December 26, 2025</time>
    <span title="Reading time" property="timeRequired" content="PT13M">13 minutes read</span>
    
      <span><a href="https://github.com/unbalancedparentheses/federicocarrone.com/edit/main/content/series&#x2F;concrete&#x2F;2025-12-26-the-concrete-programming-language-systems-programming-for-formal-reasoning&#x2F;index.md" title="Submit a patch for this page">Edit</a> this page</span>
      
    
  </div>

    </header>

    <p>There's a tension at the heart of systems programming. We want languages expressive enough to build complex systems, yet simple enough to reason about with confidence. We want performance without sacrificing safety. We want the freedom to write low-level code and the guarantees that come from formal verification.</p>
<p>Concrete is an attempt to resolve these tensions through commitment to a single organizing principle: <strong>every design choice must answer the question, can a machine reason about this?</strong></p>
<h2 id="on-this-specification">On This Specification</h2>
<p>This document describes what we're building, not what we've finished building. The kernel formalization in Lean is ongoing work. Until that formalization is complete, this specification likely contains mistakes, ambiguities, and internal contradictions.</p>
<p>We state this not as an apology but as a feature of our approach. Most language specifications accumulate contradictions silently over years, edge cases where the spec says one thing and the implementation does another, or where two parts of the spec conflict in ways nobody noticed. These contradictions become load-bearing bugs that can never be fixed without breaking existing code.</p>
<p>By designing Concrete around a formally verified kernel from the start, we force these contradictions into the open. When we formalize a feature in Lean, the proof assistant will reject inconsistencies. Features that seem reasonable on paper will turn out to be unsound, and we'll have to redesign them. This is the point. We'd rather discover that our linearity rules have a hole <em>before</em> a million lines of code depend on the broken behavior.</p>
<p>The specification and the formalization will co-evolve. As we prove properties in Lean, we'll update this document. As we write this document, we'll discover what needs proving. The goal is convergence: eventually, this specification will be a human-readable projection of a machine-checked artifact.</p>
<h2 id="the-core-idea">The Core Idea</h2>
<p>Most languages treat verification as something bolted on after the fact. You write code, then maybe you write tests, maybe you run a linter, maybe you bring in a theorem prover for critical sections. The language itself remains agnostic about provability.</p>
<p>Concrete inverts this relationship. The language is <em>designed around</em> a verified core, a small kernel calculus formalized in Lean with mechanically-checked proofs of progress, preservation, linearity soundness, and effect soundness. The surface language exists only to elaborate into this kernel.</p>
<h3 id="what-correct-means">What "Correct" Means</h3>
<p>When we say a type-checked program is "correct by construction," we mean correct with respect to specific properties:</p>
<ul>
<li><strong>Memory safety</strong>: no use-after-free, no double-free, no dangling references</li>
<li><strong>Resource safety</strong>: linear values consumed exactly once, no leaks</li>
<li><strong>Effect correctness</strong>: declared capabilities match actual effects</li>
</ul>
<p>We do not guarantee termination. Recursive functions may diverge. We do not guarantee liveness or deadlock freedom. These properties are outside the current verification scope. The kernel proves progress (well-typed programs don't get stuck) and preservation (types are maintained during evaluation), which together yield memory and resource safety, not total correctness.</p>
<h3 id="the-trust-boundary">The Trust Boundary</h3>
<p>The kernel type system and its properties are mechanically checked in Lean. What remains trusted: the Lean proof checker itself, the elaborator (surface language to kernel), and the code generator (kernel to machine code). Verifying the elaborator and code generator is future work.</p>
<h2 id="the-compilation-pipeline">The Compilation Pipeline</h2>
<pre class="z-code"><code><span class="z-text z-plain">Source Code (.concrete)
</span><span class="z-text z-plain">       ↓
</span><span class="z-text z-plain">   Lexer/Parser (LL(1) recursive descent)
</span><span class="z-text z-plain">       ↓
</span><span class="z-text z-plain">   Surface AST
</span><span class="z-text z-plain">       ↓
</span><span class="z-text z-plain">   Elaboration
</span><span class="z-text z-plain">     - Type checking
</span><span class="z-text z-plain">     - Linearity checking
</span><span class="z-text z-plain">     - Capability checking
</span><span class="z-text z-plain">     - Borrow/region checking
</span><span class="z-text z-plain">     - Defer insertion points
</span><span class="z-text z-plain">     - Allocator binding resolution
</span><span class="z-text z-plain">       ↓
</span><span class="z-text z-plain">   Kernel IR (core calculus)
</span><span class="z-text z-plain">       ↓
</span><span class="z-text z-plain">   Kernel Checker ← proven sound in Lean
</span><span class="z-text z-plain">       ↓
</span><span class="z-text z-plain">   Code Generation
</span><span class="z-text z-plain">       ↓
</span><span class="z-text z-plain">   Machine Code
</span></code></pre>
<p>The kernel checkpoint is the semantic gate. Everything before it transforms syntax; everything after it preserves meaning.</p>
<h2 id="types">Types</h2>
<h3 id="primitives">Primitives</h3>
<pre class="z-code"><code><span class="z-text z-plain">Bool
</span><span class="z-text z-plain">Int, Int8, Int16, Int32, Int64
</span><span class="z-text z-plain">Uint, Uint8, Uint16, Uint32, Uint64
</span><span class="z-text z-plain">Float32, Float64
</span><span class="z-text z-plain">Char, String
</span><span class="z-text z-plain">Unit
</span></code></pre>
<h3 id="algebraic-data-types">Algebraic Data Types</h3>
<pre class="z-code"><code><span class="z-text z-plain">type Option&lt;T&gt; {
</span><span class="z-text z-plain">    Some(T),
</span><span class="z-text z-plain">    None
</span><span class="z-text z-plain">}
</span><span class="z-text z-plain">
</span><span class="z-text z-plain">type Result&lt;T, E&gt; {
</span><span class="z-text z-plain">    Ok(T),
</span><span class="z-text z-plain">    Err(E)
</span><span class="z-text z-plain">}
</span><span class="z-text z-plain">
</span><span class="z-text z-plain">type List&lt;T&gt; {
</span><span class="z-text z-plain">    Nil,
</span><span class="z-text z-plain">    Cons(T, List&lt;T&gt;)
</span><span class="z-text z-plain">}
</span></code></pre>
<h3 id="records">Records</h3>
<pre class="z-code"><code><span class="z-text z-plain">type Point {
</span><span class="z-text z-plain">    x: Float64,
</span><span class="z-text z-plain">    y: Float64
</span><span class="z-text z-plain">}
</span></code></pre>
<h3 id="standard-library-types">Standard Library Types</h3>
<p>For domains where precision matters, the standard library includes:</p>
<ul>
<li><strong>Decimal</strong>: fixed-point decimal arithmetic for financial calculations</li>
<li><strong>BigInt</strong>: arbitrary-precision integers</li>
<li><strong>BigDecimal</strong>: arbitrary-precision decimals</li>
</ul>
<p>These avoid floating-point representation errors in financial systems and cryptographic applications.</p>
<h2 id="linearity-and-copy">Linearity and Copy</h2>
<p>All values in Concrete are linear by default. A linear value must be consumed exactly once, not zero times (that's a leak), not twice (that's a double-free). Consumption happens when you pass the value to a function that takes ownership, return it, destructure it via pattern matching, or explicitly call <code>destroy(x)</code>.</p>
<pre class="z-code"><code><span class="z-text z-plain">fn example!() {
</span><span class="z-text z-plain">    let f = open(&quot;data.txt&quot;)
</span><span class="z-text z-plain">    defer destroy(f)
</span><span class="z-text z-plain">    let content = read(&amp;f)
</span><span class="z-text z-plain">    // destroy(f) runs here because of defer
</span><span class="z-text z-plain">}
</span></code></pre>
<p>If <code>f</code> isn't consumed on all paths, the program is rejected. If you try to use <code>f</code> after moving it, the program is rejected. This is compile-time enforcement, not runtime checking.</p>
<h3 id="the-copy-marker">The Copy Marker</h3>
<p>Some types escape linear restrictions. The rules for <code>Copy</code> are:</p>
<ol>
<li><strong>Copy is explicit and opt-in.</strong> You must mark a type as <code>Copy</code>; it is never inferred.</li>
<li><strong>Copy is structural.</strong> A type can be <code>Copy</code> only if all its fields are <code>Copy</code>.</li>
<li><strong>Copy types cannot have destructors.</strong> If a type defines <code>destroy</code>, it cannot be <code>Copy</code>.</li>
<li><strong>Copy types cannot contain linear fields.</strong> A <code>Copy</code> record with a <code>File</code> field is rejected.</li>
</ol>
<pre class="z-code"><code><span class="z-text z-plain">type Copy Point {
</span><span class="z-text z-plain">    x: Float64,
</span><span class="z-text z-plain">    y: Float64
</span><span class="z-text z-plain">}
</span></code></pre>
<p>The primitive numeric types and <code>Bool</code> are built-in <code>Copy</code> types. <code>String</code> is linear. For generic types, linearity depends on the type parameter: <code>Option&lt;Int&gt;</code> is <code>Copy</code> because <code>Int</code> is; <code>Option&lt;File&gt;</code> is linear because <code>File</code> is.</p>
<p><code>Copy</code> is not an escape hatch from thinking about resources. It's a marker for types that have no cleanup requirements and can be freely duplicated.</p>
<h3 id="destructors">Destructors</h3>
<p>A linear type may define a destructor:</p>
<pre class="z-code"><code><span class="z-text z-plain">type File {
</span><span class="z-text z-plain">    handle: FileHandle
</span><span class="z-text z-plain">}
</span><span class="z-text z-plain">
</span><span class="z-text z-plain">destroy File with(File) {
</span><span class="z-text z-plain">    close_handle(self.handle)
</span><span class="z-text z-plain">}
</span></code></pre>
<p>The destructor takes ownership of <code>self</code>, may require capabilities, and runs exactly once when explicitly invoked. <code>destroy(x)</code> is only valid if the type defines a destructor. A type without a destructor must be consumed by moving, returning, or destructuring.</p>
<h3 id="defer">Defer</h3>
<p>The <code>defer</code> statement schedules cleanup at scope exit:</p>
<pre class="z-code"><code><span class="z-text z-plain">fn process_files!() {
</span><span class="z-text z-plain">    let f1 = open(&quot;a.txt&quot;)
</span><span class="z-text z-plain">    defer destroy(f1)
</span><span class="z-text z-plain">    
</span><span class="z-text z-plain">    let f2 = open(&quot;b.txt&quot;)
</span><span class="z-text z-plain">    defer destroy(f2)
</span><span class="z-text z-plain">    
</span><span class="z-text z-plain">    // When scope exits:
</span><span class="z-text z-plain">    // 1. destroy(f2) runs
</span><span class="z-text z-plain">    // 2. destroy(f1) runs
</span><span class="z-text z-plain">}
</span></code></pre>
<p>Multiple <code>defer</code> statements execute in reverse order (LIFO). <code>defer</code> runs at scope exit including early returns and error propagation.</p>
<p>When a value is scheduled with <code>defer destroy(x)</code>, it becomes reserved. You cannot move it, destroy it again, or create borrows that overlap the deferred destruction point.</p>
<h3 id="abort">Abort</h3>
<p>Abort is immediate process termination, outside normal control flow:</p>
<ul>
<li>Out-of-memory conditions trigger abort</li>
<li>Stack overflow triggers abort</li>
<li>Explicit <code>abort()</code> terminates immediately</li>
<li><strong>Deferred cleanup does not run on abort</strong></li>
</ul>
<p>This matches Zig's behavior: <code>defer</code> is for normal control flow, not catastrophic failure. Abort is outside language semantics. The process stops. There are no guarantees about state after abort begins.</p>
<h2 id="borrowing">Borrowing</h2>
<p>References let you use values without consuming them. References exist within lexical regions that bound their lifetime.</p>
<pre class="z-code"><code><span class="z-text z-plain">borrow f as fref in R {
</span><span class="z-text z-plain">    // fref has type &amp;[File, R]
</span><span class="z-text z-plain">    // f is unusable in this block
</span><span class="z-text z-plain">    let len = length(fref)
</span><span class="z-text z-plain">}
</span><span class="z-text z-plain">// f is usable again
</span></code></pre>
<p>Unlike Rust, no lifetime parameters in function signatures. Functions that accept references are generic over the region, but implicitly:</p>
<pre class="z-code"><code><span class="z-text z-plain">fn length&lt;R&gt;(file: &amp;[File, R]) -&gt; Uint {
</span><span class="z-text z-plain">    ...
</span><span class="z-text z-plain">}
</span></code></pre>
<p>The function cannot store the reference because it cannot name <code>R</code> outside the call.</p>
<p>For single-expression borrows, the region is anonymous:</p>
<pre class="z-code"><code><span class="z-text z-plain">let len = length(&amp;f)  // borrows f for just this call
</span></code></pre>
<h3 id="borrowing-rules">Borrowing Rules</h3>
<ol>
<li>While borrowed, the original is unusable</li>
<li>Multiple immutable borrows allowed</li>
<li>Mutable borrows exclusive: one <code>&amp;mut T</code> at a time, no simultaneous <code>&amp;T</code></li>
<li>References cannot escape their region</li>
<li>Nested borrows of the same owned value forbidden</li>
<li>Derived references can't outlive the original's region</li>
</ol>
<p>Closures cannot capture references if the closure escapes the borrow region.</p>
<h2 id="capabilities">Capabilities</h2>
<p>Concrete is <strong>pure by default</strong>. A function without capability annotations cannot perform IO, cannot allocate, cannot mutate external state. It computes a result from its inputs, nothing more.</p>
<p>Purity means no side effects and no heap allocation. Stack allocation and compile-time constants are permitted. Non-termination is possible; purity does not imply totality.</p>
<p>When a function needs effects, it declares them:</p>
<pre class="z-code"><code><span class="z-text z-plain">fn read_file(path: String) with(File) -&gt; String {
</span><span class="z-text z-plain">    ...
</span><span class="z-text z-plain">}
</span><span class="z-text z-plain">
</span><span class="z-text z-plain">fn process_data() with(File, Network, Alloc) -&gt; Result {
</span><span class="z-text z-plain">    ...
</span><span class="z-text z-plain">}
</span></code></pre>
<p>Capabilities propagate monotonically. If <code>f</code> calls <code>g</code>, and <code>g</code> requires <code>File</code>, then <code>f</code> must declare <code>File</code> too. No implicit granting, no ambient authority. The compiler enforces this transitively.</p>
<h3 id="the-std-capability">The Std Capability</h3>
<p>For application entry points, Concrete provides a shorthand. The <code>!</code> suffix declares the <code>Std</code> capability:</p>
<pre class="z-code"><code><span class="z-text z-plain">fn main!() {
</span><span class="z-text z-plain">    println(&quot;Hello&quot;)
</span><span class="z-text z-plain">}
</span></code></pre>
<p>This desugars to <code>fn main() with(Std)</code>. <code>Std</code> includes file operations, network, clock, environment, random, and allocation, but excludes <code>Unsafe</code>.</p>
<p><strong>Library code should prefer explicit capability lists.</strong> This is a social convention, not a mechanical enforcement. The compiler won't reject a library function that uses <code>Std</code>. But explicit capabilities make dependencies auditable. <code>Std</code> is a convenience for applications, not a license for libraries.</p>
<h3 id="security-model">Security Model</h3>
<p>Capabilities don't sandbox code. If a dependency declares <code>with(Network)</code>, it gets network access. What they provide is <strong>auditability</strong>. You can grep for <code>with(Network)</code> and find every function that touches the network. You can verify that your JSON parser has no capabilities. You can review dependency updates by diffing capability declarations.</p>
<h3 id="capability-polymorphism">Capability Polymorphism</h3>
<p>Currently, you cannot be generic over capability sets:</p>
<pre class="z-code"><code><span class="z-text z-plain">// Not allowed
</span><span class="z-text z-plain">fn map&lt;T, U, C&gt;(list: List&lt;T&gt;, f: fn(T) with(C) -&gt; U) with(C) -&gt; List&lt;U&gt;
</span></code></pre>
<p>Each capability set must be concrete. This means generic combinators must be duplicated per capability set. Capability polymorphism is future work; the theory is well-understood (effect polymorphism in Koka, Eff, Frank), but adds complexity to the type system and the Lean formalization.</p>
<h2 id="allocation">Allocation</h2>
<p>Allocation deserves special attention because it's often invisible. In most languages, many operations allocate behind your back: string concatenation, collection growth, closure creation.</p>
<p>Concrete treats allocation as a capability. Functions that allocate declare <code>with(Alloc)</code>. The call site binds which allocator:</p>
<pre class="z-code"><code><span class="z-text z-plain">fn main!() {
</span><span class="z-text z-plain">    let arena = Arena.new()
</span><span class="z-text z-plain">    defer arena.deinit()
</span><span class="z-text z-plain">    
</span><span class="z-text z-plain">    let list = create_list&lt;Int&gt;() with(Alloc = arena)
</span><span class="z-text z-plain">    push(&amp;mut list, 42) with(Alloc = arena)
</span><span class="z-text z-plain">}
</span></code></pre>
<p>Inside <code>with(Alloc)</code>, the bound allocator propagates through nested calls. At the boundary, you see exactly where allocation happens and which allocator serves it.</p>
<p>Stack allocation does not require <code>Alloc</code>:</p>
<pre class="z-code"><code><span class="z-text z-plain">fn example() {
</span><span class="z-text z-plain">    let x: Int = 42                    // stack
</span><span class="z-text z-plain">    let arr: [100]Uint8 = zeroed()     // stack
</span><span class="z-text z-plain">}
</span></code></pre>
<p>Allocation-free code is provably allocation-free.</p>
<h3 id="allocator-types">Allocator Types</h3>
<pre class="z-code"><code><span class="z-text z-plain">// General-purpose heap allocator
</span><span class="z-text z-plain">let gpa = GeneralPurposeAllocator.new()
</span><span class="z-text z-plain">defer gpa.deinit()
</span><span class="z-text z-plain">
</span><span class="z-text z-plain">// Arena allocator, free everything at once
</span><span class="z-text z-plain">let arena = Arena.new(gpa)
</span><span class="z-text z-plain">defer arena.deinit()
</span><span class="z-text z-plain">
</span><span class="z-text z-plain">// Fixed buffer allocator, no heap
</span><span class="z-text z-plain">let buf: [1024]Uint8 = zeroed()
</span><span class="z-text z-plain">let fba = FixedBufferAllocator.new(&amp;buf)
</span></code></pre>
<p>All allocators implement a common <code>Allocator</code> trait.</p>
<h2 id="error-handling">Error Handling</h2>
<p>Errors are values:</p>
<pre class="z-code"><code><span class="z-text z-plain">fn parse(input: String) -&gt; Result&lt;Config, ParseError&gt; {
</span><span class="z-text z-plain">    ...
</span><span class="z-text z-plain">}
</span><span class="z-text z-plain">
</span><span class="z-text z-plain">fn load_config!() -&gt; Result&lt;Config, Error&gt; {
</span><span class="z-text z-plain">    let f = open(&quot;config.toml&quot;)?
</span><span class="z-text z-plain">    defer destroy(f)
</span><span class="z-text z-plain">    
</span><span class="z-text z-plain">    let content = read(&amp;f)
</span><span class="z-text z-plain">    let config = parse(content)?
</span><span class="z-text z-plain">    Ok(config)
</span><span class="z-text z-plain">}
</span></code></pre>
<p>The <code>?</code> operator propagates errors. When <code>?</code> triggers an early return, all <code>defer</code> statements in scope run first. Cleanup happens even on error paths.</p>
<p>No exceptions. No panic. Unrecoverable faults (out-of-memory, stack overflow, explicit abort) terminate immediately without running deferred cleanup.</p>
<h2 id="what-you-re-giving-up">What You're Giving Up</h2>
<p>Concrete is not a general-purpose language. It's for code that must be correct: cryptographic implementations, financial systems, safety-critical software, blockchain infrastructure.</p>
<p><strong>No garbage collection.</strong> Memory is managed through linear types and explicit destruction. No GC pauses, no unpredictable latency, no hidden memory pressure.</p>
<p><strong>No implicit control flow.</strong> What you see is what executes. No implicit function calls from operator overloading, no compiler-inserted destructor calls. <code>defer</code> statements are explicit: you write them, you see them, even though their execution occurs at scope exit.</p>
<p><strong>No implicit allocation.</strong> Allocation requires the <code>Alloc</code> capability. <code>grep with(Alloc)</code> finds every function that might touch the heap.</p>
<p><strong>No interior mutability.</strong> All mutation flows through <code>&amp;mut</code> references. An immutable reference <code>&amp;T</code> guarantees immutability, no hidden mutation behind an immutable facade.</p>
<p><strong>No reflection, no eval, no runtime metaprogramming.</strong> All code paths are determined at compile time.</p>
<p><strong>No implicit global state.</strong> All global interactions (file system, network, clock, environment) are mediated through capabilities.</p>
<p><strong>No variable shadowing.</strong> Each variable name is unique within its scope.</p>
<p><strong>No null.</strong> Optional values use <code>Option&lt;T&gt;</code>.</p>
<p><strong>No undefined behavior in safe code.</strong> Kernel semantics are fully defined and proven sound. The <code>Unsafe</code> capability explicitly reintroduces the possibility of undefined behavior for FFI and low-level operations.</p>
<p><strong>No concurrency primitives.</strong> The language provides no threads, no async/await, no channels. Concurrency is a library concern. This may change, but any future concurrency model must preserve determinism and linearity, likely through structured or deterministic concurrency. This is a design constraint, not an open question.</p>
<h2 id="pattern-matching">Pattern Matching</h2>
<p>Exhaustive pattern matching with linear type awareness:</p>
<pre class="z-code"><code><span class="z-text z-plain">fn describe(opt: Option&lt;Int&gt;) -&gt; String {
</span><span class="z-text z-plain">    match opt {
</span><span class="z-text z-plain">        Some(n) =&gt; format(&quot;Got {}&quot;, n),
</span><span class="z-text z-plain">        None =&gt; &quot;Nothing&quot;
</span><span class="z-text z-plain">    }
</span><span class="z-text z-plain">}
</span></code></pre>
<p>Linear types in patterns must be consumed:</p>
<pre class="z-code"><code><span class="z-text z-plain">fn handle!(result: Result&lt;Data, File&gt;) {
</span><span class="z-text z-plain">    match result {
</span><span class="z-text z-plain">        Ok(data) =&gt; use_data(data),
</span><span class="z-text z-plain">        Err(f) =&gt; destroy(f)
</span><span class="z-text z-plain">    }
</span><span class="z-text z-plain">}
</span></code></pre>
<p>Borrowing in patterns:</p>
<pre class="z-code"><code><span class="z-text z-plain">fn peek(opt: &amp;Option&lt;Int&gt;) -&gt; Int {
</span><span class="z-text z-plain">    match opt {
</span><span class="z-text z-plain">        &amp;Some(n) =&gt; n,
</span><span class="z-text z-plain">        &amp;None =&gt; 0
</span><span class="z-text z-plain">    }
</span><span class="z-text z-plain">}
</span></code></pre>
<h2 id="traits">Traits</h2>
<pre class="z-code"><code><span class="z-text z-plain">trait Ord {
</span><span class="z-text z-plain">    fn compare(&amp;self, other: &amp;Self) -&gt; Ordering
</span><span class="z-text z-plain">}
</span><span class="z-text z-plain">
</span><span class="z-text z-plain">trait Show {
</span><span class="z-text z-plain">    fn show(&amp;self) -&gt; String
</span><span class="z-text z-plain">}
</span><span class="z-text z-plain">
</span><span class="z-text z-plain">fn sort&lt;T: Ord&gt;(list: List&lt;T&gt;) with(Alloc) -&gt; List&lt;T&gt; {
</span><span class="z-text z-plain">    ...
</span><span class="z-text z-plain">}
</span></code></pre>
<p>Trait methods take <code>&amp;self</code>, <code>&amp;mut self</code>, or <code>self</code>. If a method takes <code>self</code>, calling it consumes the value.</p>
<h2 id="type-inference">Type Inference</h2>
<p>Type inference is <strong>local only</strong>. Function signatures must be fully annotated. Inside bodies, local types may be inferred:</p>
<pre class="z-code"><code><span class="z-text z-plain">fn process(data: List&lt;Int&gt;) with(Alloc) -&gt; List&lt;Int&gt; {
</span><span class="z-text z-plain">    let doubled = map(data, fn(x) { x * 2 })  // inferred
</span><span class="z-text z-plain">    let filtered = filter(doubled, fn(x) { x &gt; 0 })  // inferred
</span><span class="z-text z-plain">    filtered
</span><span class="z-text z-plain">}
</span></code></pre>
<p>You can always understand a function's interface without reading its body.</p>
<h2 id="modules">Modules</h2>
<pre class="z-code"><code><span class="z-text z-plain">module FileSystem
</span><span class="z-text z-plain">
</span><span class="z-text z-plain">public fn open(path: String) with(File) -&gt; Result&lt;File, IOError&gt; {
</span><span class="z-text z-plain">    ...
</span><span class="z-text z-plain">}
</span><span class="z-text z-plain">
</span><span class="z-text z-plain">public fn read&lt;R&gt;(file: &amp;[File, R]) with(File) -&gt; String {
</span><span class="z-text z-plain">    ...
</span><span class="z-text z-plain">}
</span><span class="z-text z-plain">
</span><span class="z-text z-plain">private fn validate(path: String) -&gt; Bool {
</span><span class="z-text z-plain">    ...
</span><span class="z-text z-plain">}
</span></code></pre>
<p>Visibility is <code>public</code> or <code>private</code> (default). Capabilities are part of the signature and the public API contract.</p>
<pre class="z-code"><code><span class="z-text z-plain">import FileSystem
</span><span class="z-text z-plain">import FileSystem.{open, read, write}
</span><span class="z-text z-plain">import FileSystem as FS
</span></code></pre>
<h2 id="unsafe-and-ffi">Unsafe and FFI</h2>
<p>The <code>Unsafe</code> capability gates operations the type system cannot verify: foreign function calls, raw pointer operations, type transmutation, inline assembly, and linearity bypasses.</p>
<pre class="z-code"><code><span class="z-text z-plain">fn transmute&lt;T, U&gt;(value: T) with(Unsafe) -&gt; U
</span><span class="z-text z-plain">
</span><span class="z-text z-plain">fn ptr_read&lt;T&gt;(ptr: Address[T]) with(Unsafe) -&gt; T
</span><span class="z-text z-plain">
</span><span class="z-text z-plain">fn ptr_write&lt;T&gt;(ptr: Address[T], value: T) with(Unsafe)
</span></code></pre>
<p><code>Unsafe</code> propagates through the call graph like any other capability. Grep for <code>with(Unsafe)</code> to find all trust boundaries.</p>
<h3 id="raw-pointers">Raw Pointers</h3>
<p>Raw pointers exist for FFI and low-level memory manipulation:</p>
<pre class="z-code"><code><span class="z-text z-plain">Address[T]       // raw pointer to T
</span></code></pre>
<p>Raw pointers are <code>Copy</code>. They carry no lifetime information and no linearity guarantees. This is safe because:</p>
<ul>
<li>Creating a raw pointer is safe. <code>address_of(r)</code> extracts an address.</li>
<li>Holding a raw pointer is safe. It's a number.</li>
<li>Using a raw pointer requires <code>Unsafe</code>. Dereference, arithmetic, and casting are gated.</li>
</ul>
<pre class="z-code"><code><span class="z-text z-plain">fn to_ptr&lt;T&gt;(r: &amp;T) -&gt; Address[T] {
</span><span class="z-text z-plain">    address_of(r)  // safe
</span><span class="z-text z-plain">}
</span><span class="z-text z-plain">
</span><span class="z-text z-plain">fn deref&lt;T&gt;(ptr: Address[T]) with(Unsafe) -&gt; T {
</span><span class="z-text z-plain">    read_ptr(ptr)  // unsafe: no guarantee ptr is valid
</span><span class="z-text z-plain">}
</span></code></pre>
<p><code>Copy</code> does not imply usable. Raw pointers can be freely duplicated because they carry no guarantees. Safety is enforced at the point of use, not at the point of creation.</p>
<h3 id="foreign-functions">Foreign Functions</h3>
<p>Declare foreign functions with <code>Unsafe</code> and the <code>foreign</code> directive:</p>
<pre class="z-code"><code><span class="z-text z-plain">fn malloc(size: Uint) with(Unsafe) -&gt; Address[Unit] =
</span><span class="z-text z-plain">    foreign(&quot;malloc&quot;)
</span><span class="z-text z-plain">
</span><span class="z-text z-plain">fn free(ptr: Address[Unit]) with(Unsafe) =
</span><span class="z-text z-plain">    foreign(&quot;free&quot;)
</span></code></pre>
<p>The compiler generates calling convention glue and links the symbol. Foreign signatures are restricted to C-compatible types. Details of the type mapping are deferred to a future FFI specification.</p>
<h2 id="implementation">Implementation</h2>
<h3 id="determinism">Determinism</h3>
<p>Concrete aims for <strong>bit-for-bit reproducible builds</strong>: same source + same compiler = identical binary. No timestamps, random seeds, or environment-dependent data in output.</p>
<p>For debugging, <strong>deterministic replay</strong>: random generation requires <code>Random</code> with explicit seed, system time requires <code>Clock</code>. Same inputs produce identical execution.</p>
<h3 id="the-grammar">The Grammar</h3>
<p>LL(1). Every parsing decision with a single token of lookahead. No ambiguity, no backtracking.</p>
<p>This is a permanent design constraint, not an implementation detail. Future language evolution is bounded by what LL(1) can express. We accept this constraint for tooling simplicity and error message quality.</p>
<h3 id="compilation-targets">Compilation Targets</h3>
<p><strong>Native</strong> via MLIR/LLVM, <strong>C</strong> for portability, <strong>WebAssembly</strong> for browser and edge. Cross-compilation is first-class.</p>
<h3 id="tooling">Tooling</h3>
<p>Concrete ships with package manager, formatter, linter, test runner, and REPL. Part of the distribution, not external dependencies.</p>
<h2 id="what-you-can-say-about-programs">What You Can Say About Programs</h2>
<p>If a program type-checks:</p>
<p><strong>"This function is pure."</strong> No capabilities declared. No side effects, no IO, no allocation.</p>
<p><strong>"This resource is used exactly once."</strong> Linear type. No leaks, no double-free, no use-after-free.</p>
<p><strong>"These are the only effects this code can perform."</strong> Capability set is explicit and complete.</p>
<p><strong>"This code cannot escape the type system."</strong> Unsafe operations require <code>with(Unsafe)</code>.</p>
<p><strong>"Allocation happens here, using this allocator."</strong> Call site binds the allocator.</p>
<p><strong>"Cleanup happens here."</strong> <code>defer destroy(x)</code> is visible.</p>
<p><strong>"This build is reproducible."</strong> Same inputs, same binary.</p>
<p>Mechanical guarantees from a type system proven sound in Lean. Not conventions, proofs.</p>
<h2 id="example">Example</h2>
<pre class="z-code"><code><span class="z-text z-plain">module Main
</span><span class="z-text z-plain">
</span><span class="z-text z-plain">import FileSystem.{open, read, write}
</span><span class="z-text z-plain">import Parse.{parse_csv}
</span><span class="z-text z-plain">
</span><span class="z-text z-plain">fn process_file(input_path: String, output_path: String) with(File, Alloc) -&gt; Result&lt;Unit, Error&gt; {
</span><span class="z-text z-plain">    let in_file = open(input_path)?
</span><span class="z-text z-plain">    defer destroy(in_file)
</span><span class="z-text z-plain">    
</span><span class="z-text z-plain">    let content = read(&amp;in_file)
</span><span class="z-text z-plain">    let data = parse_csv(content)?
</span><span class="z-text z-plain">    let output = transform(&amp;data)
</span><span class="z-text z-plain">    
</span><span class="z-text z-plain">    let out_file = open(output_path)?
</span><span class="z-text z-plain">    defer destroy(out_file)
</span><span class="z-text z-plain">    
</span><span class="z-text z-plain">    write(&amp;mut out_file, output)
</span><span class="z-text z-plain">    Ok(())
</span><span class="z-text z-plain">}
</span><span class="z-text z-plain">
</span><span class="z-text z-plain">fn transform(data: &amp;List&lt;Row&gt;) -&gt; String {
</span><span class="z-text z-plain">    ...
</span><span class="z-text z-plain">}
</span><span class="z-text z-plain">
</span><span class="z-text z-plain">fn main!() {
</span><span class="z-text z-plain">    let arena = Arena.new()
</span><span class="z-text z-plain">    defer arena.deinit()
</span><span class="z-text z-plain">    
</span><span class="z-text z-plain">    match process_file(&quot;input.csv&quot;, &quot;output.txt&quot;) with(Alloc = arena) {
</span><span class="z-text z-plain">        Ok(()) =&gt; println(&quot;Done&quot;),
</span><span class="z-text z-plain">        Err(e) =&gt; println(&quot;Error: &quot; + e.message())
</span><span class="z-text z-plain">    }
</span><span class="z-text z-plain">}
</span></code></pre>
<p>Everything is visible: resource acquisition, cleanup scheduling, error propagation, allocator binding.</p>
<h2 id="who-should-use-this">Who Should Use This</h2>
<p>Concrete trades convenience for explicitness, flexibility for auditability. Prototyping is slower. Some patterns become verbose. You'll miss interior mutability for certain data structures.</p>
<p>But for cryptographic primitives, consensus protocols, financial transaction systems, medical device firmware, the trade is worth it. Strong claims about program behavior, mechanically verified.</p>
<p>A language you can trust the way you trust mathematics: not because someone promises it works, but because you can check the proof.</p>
<hr />
<h2 id="quick-reference">Quick Reference</h2>
<table><thead><tr><th>Annotation</th><th>Meaning</th></tr></thead><tbody>
<tr><td><code>fn foo() -&gt; T</code></td><td>Pure function, no capabilities</td></tr>
<tr><td><code>fn foo!() -&gt; T</code></td><td>Shorthand for <code>with(Std)</code></td></tr>
<tr><td><code>fn foo() with(C) -&gt; T</code></td><td>Requires capability set <code>C</code></td></tr>
<tr><td><code>with(Alloc)</code></td><td>Function may allocate</td></tr>
<tr><td><code>with(Alloc = a)</code></td><td>Bind allocator <code>a</code> at call site</td></tr>
<tr><td><code>T</code></td><td>Linear type, consumed exactly once</td></tr>
<tr><td><code>type Copy T</code></td><td>Unrestricted type, freely duplicated</td></tr>
<tr><td><code>&amp;T</code> or <code>&amp;[T, R]</code></td><td>Immutable reference in region <code>R</code></td></tr>
<tr><td><code>&amp;mut T</code></td><td>Mutable reference</td></tr>
<tr><td><code>Address[T]</code></td><td>Raw pointer (unsafe to use)</td></tr>
<tr><td><code>borrow x as y in R { }</code></td><td>Explicit borrow with named region</td></tr>
<tr><td><code>defer expr</code></td><td>Run <code>expr</code> at scope exit</td></tr>
<tr><td><code>destroy(x)</code></td><td>Consume via destructor</td></tr>
<tr><td><code>foreign("symbol")</code></td><td>Foreign function binding</td></tr>
</tbody></table>


    <nav class="previous-next-episodes"><div class="button button--disabled text-align-end">(coming soon)&nbsp;❯</div></nav>
  </article>

</main>

<footer class="full-width content-grid">
  <div class="footer">
    <div>
      <h2>Contact me</h2>

      <ul>
        <li><a href="mailto:mail@fcarrone.com" title="Email">mail@fcarrone.com</a></li>
        <li><a href="https://x.com/federicocarrone" title="Say hi on X" rel="me">X</a></li>
        <li><a href="https://github.com/unbalancedparentheses" title="Say hi on Github">Github</a></li>
      </ul>
    </div>
    <div>
      <h2>Recommendations</h2>

      <ul>
        <li><a href="https://ergodicgroup.com">ergodicgroup.com</a></li>
        <li><a href="https://lambdaclass.com/">lambdaclass.com</a></li>
      </ul>
    </div>

    <div>
      <h2>More</h2>

      <ul>
        <li><a href="https://federicocarrone.com/rss.xml">RSS</a></li>
        <li><a href="https://federicocarrone.com/atom.xml">Atom</a></li>
        <li><a href="https://github.com/unbalancedparentheses/federicocarrone.com" title="Source code of this site">Source code</a></li>
      </ul>
    </div>
  </div>
</footer>

</body>
</html>
