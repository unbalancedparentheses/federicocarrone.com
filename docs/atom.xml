<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en">
    <title></title>
    <link rel="self" type="application/atom+xml" href="https://federicocarrone.com/atom.xml"/>
    <link rel="alternate" type="text/html" href="https://federicocarrone.com"/>
    <generator uri="https://www.getzola.org/">Zola</generator>
    <updated>2025-12-26T00:00:00+00:00</updated>
    <id>https://federicocarrone.com/atom.xml</id>
    <entry xml:lang="en">
        <title>The Concrete Programming Language: Systems Programming for Formal Reasoning</title>
        <published>2025-12-26T00:00:00+00:00</published>
        <updated>2025-12-26T00:00:00+00:00</updated>
        
        <author>
          <name>
            
              Unknown
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://federicocarrone.com/series/concrete/the-concrete-programming-language-systems-programming-for-formal-reasoning/"/>
        <id>https://federicocarrone.com/series/concrete/the-concrete-programming-language-systems-programming-for-formal-reasoning/</id>
        
        <content type="html" xml:base="https://federicocarrone.com/series/concrete/the-concrete-programming-language-systems-programming-for-formal-reasoning/">&lt;p&gt;There&#x27;s a tension at the heart of systems programming. We want languages expressive enough to build complex systems, yet simple enough to reason about with confidence. We want performance without sacrificing safety. We want the freedom to write low-level code and the guarantees that come from formal verification.&lt;&#x2F;p&gt;
&lt;p&gt;Concrete is an attempt to resolve these tensions through commitment to a single organizing principle: &lt;strong&gt;every design choice must answer the question, can a machine reason about this?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;h2 id=&quot;on-this-specification&quot;&gt;On This Specification&lt;&#x2F;h2&gt;
&lt;p&gt;This document describes what we&#x27;re building, not what we&#x27;ve finished building. The kernel formalization in Lean is ongoing work. Until that formalization is complete, this specification likely contains mistakes, ambiguities, and internal contradictions.&lt;&#x2F;p&gt;
&lt;p&gt;We state this not as an apology but as a feature of our approach. Most language specifications accumulate contradictions silently over years, edge cases where the spec says one thing and the implementation does another, or where two parts of the spec conflict in ways nobody noticed. These contradictions become load-bearing bugs that can never be fixed without breaking existing code.&lt;&#x2F;p&gt;
&lt;p&gt;By designing Concrete around a formally verified kernel from the start, we force these contradictions into the open. When we formalize a feature in Lean, the proof assistant will reject inconsistencies. Features that seem reasonable on paper will turn out to be unsound, and we&#x27;ll have to redesign them. This is the point. We&#x27;d rather discover that our linearity rules have a hole &lt;em&gt;before&lt;&#x2F;em&gt; a million lines of code depend on the broken behavior.&lt;&#x2F;p&gt;
&lt;p&gt;The specification and the formalization will co-evolve. As we prove properties in Lean, we&#x27;ll update this document. As we write this document, we&#x27;ll discover what needs proving. The goal is convergence: eventually, this specification will be a human-readable projection of a machine-checked artifact.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;stability-promise&quot;&gt;Stability Promise&lt;&#x2F;h3&gt;
&lt;p&gt;The kernel is versioned separately from the surface language. Once the kernel reaches 1.0, it is frozen. New surface features must elaborate to existing kernel constructs. If a feature can&#x27;t be expressed in the kernel, the feature doesn&#x27;t ship.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;design-principles&quot;&gt;Design Principles&lt;&#x2F;h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Pure by default&lt;&#x2F;strong&gt; — Functions without capability annotations are pure: no side effects, no allocation&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;Explicit capabilities&lt;&#x2F;strong&gt; — All effects tracked in function signatures&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;Linear by default&lt;&#x2F;strong&gt; — Values consumed exactly once unless marked &lt;code&gt;Copy&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;No hidden control flow&lt;&#x2F;strong&gt; — All function calls, cleanup, and allocation visible in source&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;Fits in your head&lt;&#x2F;strong&gt; — Small enough for one person to fully understand&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;LL(1) grammar&lt;&#x2F;strong&gt; — Parseable with single token lookahead, no ambiguity&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;h2 id=&quot;the-core-idea&quot;&gt;The Core Idea&lt;&#x2F;h2&gt;
&lt;p&gt;Most languages treat verification as something bolted on after the fact. You write code, then maybe you write tests, maybe you run a linter, maybe you bring in a theorem prover for critical sections. The language itself remains agnostic about provability.&lt;&#x2F;p&gt;
&lt;p&gt;Concrete inverts this relationship. The language is &lt;em&gt;designed around&lt;&#x2F;em&gt; a verified core, a small kernel calculus formalized in Lean 4 with mechanically-checked proofs of progress, preservation, linearity soundness, and effect soundness. The surface language exists only to elaborate into this kernel.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;what-correct-means&quot;&gt;What &quot;Correct&quot; Means&lt;&#x2F;h3&gt;
&lt;p&gt;When we say a type-checked program is &quot;correct by construction,&quot; we mean correct with respect to specific properties:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Memory safety&lt;&#x2F;strong&gt;: no use-after-free, no double-free, no dangling references&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;Resource safety&lt;&#x2F;strong&gt;: linear values consumed exactly once, no leaks&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;Effect correctness&lt;&#x2F;strong&gt;: declared capabilities match actual effects&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;We do not guarantee termination. Recursive functions may diverge. We do not guarantee liveness or deadlock freedom. These properties are outside the current verification scope. The kernel proves progress (well-typed programs don&#x27;t get stuck) and preservation (types are maintained during evaluation), which together yield memory and resource safety, not total correctness.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;the-trust-boundary&quot;&gt;The Trust Boundary&lt;&#x2F;h3&gt;
&lt;p&gt;The kernel type system and its properties are mechanically checked in Lean. What remains trusted: the Lean proof checker itself, the elaborator (surface language to kernel), and the code generator (kernel to machine code). Verifying the elaborator and code generator is future work.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;the-compilation-pipeline&quot;&gt;The Compilation Pipeline&lt;&#x2F;h2&gt;
&lt;pre class=&quot;z-code&quot;&gt;&lt;code&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;Source Code (.concrete)
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;       ↓
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;   Lexer&#x2F;Parser (LL(1) recursive descent)
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;       ↓
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;   Surface AST
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;       ↓
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;   Elaboration
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;     - Type checking
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;     - Linearity checking
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;     - Capability checking
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;     - Borrow&#x2F;region checking
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;     - Defer insertion points
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;     - Allocator binding resolution
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;       ↓
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;   Kernel IR (core calculus)
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;       ↓
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;   Kernel Checker ← proven sound in Lean
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;       ↓
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;   Code Generation
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;       ↓
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;   Machine Code
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The kernel checkpoint is the semantic gate. Everything before it transforms syntax; everything after it preserves meaning.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;types&quot;&gt;Types&lt;&#x2F;h2&gt;
&lt;h3 id=&quot;primitives&quot;&gt;Primitives&lt;&#x2F;h3&gt;
&lt;pre class=&quot;z-code&quot;&gt;&lt;code&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;Bool
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;Int, Int8, Int16, Int32, Int64
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;Uint, Uint8, Uint16, Uint32, Uint64
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;Float32, Float64
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;Char, String
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;Unit
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h3 id=&quot;algebraic-data-types&quot;&gt;Algebraic Data Types&lt;&#x2F;h3&gt;
&lt;pre class=&quot;z-code&quot;&gt;&lt;code&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;type Option&amp;lt;T&amp;gt; {
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;    Some(T),
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;    None
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;}
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;type Result&amp;lt;T, E&amp;gt; {
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;    Ok(T),
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;    Err(E)
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;}
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;type List&amp;lt;T&amp;gt; {
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;    Nil,
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;    Cons(T, List&amp;lt;T&amp;gt;)
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h3 id=&quot;records&quot;&gt;Records&lt;&#x2F;h3&gt;
&lt;pre class=&quot;z-code&quot;&gt;&lt;code&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;type Point {
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;    x: Float64,
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;    y: Float64
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h3 id=&quot;standard-library-types&quot;&gt;Standard Library Types&lt;&#x2F;h3&gt;
&lt;p&gt;For domains where precision matters, the standard library includes:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Decimal&lt;&#x2F;strong&gt;: fixed-point decimal arithmetic for financial calculations&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;BigInt&lt;&#x2F;strong&gt;: arbitrary-precision integers&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;BigDecimal&lt;&#x2F;strong&gt;: arbitrary-precision decimals&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;These avoid floating-point representation errors in financial systems and cryptographic applications.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;linearity-and-copy&quot;&gt;Linearity and Copy&lt;&#x2F;h2&gt;
&lt;p&gt;All values in Concrete are linear by default. A linear value must be consumed exactly once, not zero times (that&#x27;s a leak), not twice (that&#x27;s a double-free). This is closer to Austral&#x27;s strict linearity than Rust&#x27;s affine types, which allow values to be dropped without explicit consumption.&lt;&#x2F;p&gt;
&lt;p&gt;Consumption happens when you pass the value to a function that takes ownership, return it, destructure it via pattern matching, or explicitly call &lt;code&gt;destroy(x)&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;pre class=&quot;z-code&quot;&gt;&lt;code&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;fn example!() {
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;    let f = open(&amp;quot;data.txt&amp;quot;)
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;    defer destroy(f)
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;    let content = read(&amp;amp;f)
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;    &#x2F;&#x2F; destroy(f) runs here because of defer
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;If &lt;code&gt;f&lt;&#x2F;code&gt; isn&#x27;t consumed on all paths, the program is rejected. If you try to use &lt;code&gt;f&lt;&#x2F;code&gt; after moving it, the program is rejected. This is compile-time enforcement, not runtime checking.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;the-copy-marker&quot;&gt;The Copy Marker&lt;&#x2F;h3&gt;
&lt;p&gt;Some types escape linear restrictions. The rules for &lt;code&gt;Copy&lt;&#x2F;code&gt; are:&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Copy is explicit and opt-in.&lt;&#x2F;strong&gt; You must mark a type as &lt;code&gt;Copy&lt;&#x2F;code&gt;; it is never inferred.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;Copy is structural.&lt;&#x2F;strong&gt; A type can be &lt;code&gt;Copy&lt;&#x2F;code&gt; only if all its fields are &lt;code&gt;Copy&lt;&#x2F;code&gt;.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;Copy types cannot have destructors.&lt;&#x2F;strong&gt; If a type defines &lt;code&gt;destroy&lt;&#x2F;code&gt;, it cannot be &lt;code&gt;Copy&lt;&#x2F;code&gt;.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;Copy types cannot contain linear fields.&lt;&#x2F;strong&gt; A &lt;code&gt;Copy&lt;&#x2F;code&gt; record with a &lt;code&gt;File&lt;&#x2F;code&gt; field is rejected.&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;pre class=&quot;z-code&quot;&gt;&lt;code&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;type Copy Point {
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;    x: Float64,
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;    y: Float64
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The primitive numeric types and &lt;code&gt;Bool&lt;&#x2F;code&gt; are built-in &lt;code&gt;Copy&lt;&#x2F;code&gt; types. &lt;code&gt;String&lt;&#x2F;code&gt; is linear. For generic types, linearity depends on the type parameter: &lt;code&gt;Option&amp;lt;Int&amp;gt;&lt;&#x2F;code&gt; is &lt;code&gt;Copy&lt;&#x2F;code&gt; because &lt;code&gt;Int&lt;&#x2F;code&gt; is; &lt;code&gt;Option&amp;lt;File&amp;gt;&lt;&#x2F;code&gt; is linear because &lt;code&gt;File&lt;&#x2F;code&gt; is.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;code&gt;Copy&lt;&#x2F;code&gt; is not an escape hatch from thinking about resources. It&#x27;s a marker for types that have no cleanup requirements and can be freely duplicated.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;destructors&quot;&gt;Destructors&lt;&#x2F;h3&gt;
&lt;p&gt;A linear type may define a destructor:&lt;&#x2F;p&gt;
&lt;pre class=&quot;z-code&quot;&gt;&lt;code&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;type File {
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;    handle: FileHandle
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;}
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;destroy File with(File) {
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;    close_handle(self.handle)
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The destructor takes ownership of &lt;code&gt;self&lt;&#x2F;code&gt;, may require capabilities, and runs exactly once when explicitly invoked. &lt;code&gt;destroy(x)&lt;&#x2F;code&gt; is only valid if the type defines a destructor. A type without a destructor must be consumed by moving, returning, or destructuring.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;defer&quot;&gt;Defer&lt;&#x2F;h3&gt;
&lt;p&gt;The &lt;code&gt;defer&lt;&#x2F;code&gt; statement schedules cleanup at scope exit, borrowed directly from Zig and Go:&lt;&#x2F;p&gt;
&lt;pre class=&quot;z-code&quot;&gt;&lt;code&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;fn process_files!() {
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;    let f1 = open(&amp;quot;a.txt&amp;quot;)
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;    defer destroy(f1)
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;    
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;    let f2 = open(&amp;quot;b.txt&amp;quot;)
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;    defer destroy(f2)
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;    
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;    &#x2F;&#x2F; When scope exits:
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;    &#x2F;&#x2F; 1. destroy(f2) runs
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;    &#x2F;&#x2F; 2. destroy(f1) runs
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Multiple &lt;code&gt;defer&lt;&#x2F;code&gt; statements execute in reverse order (LIFO). &lt;code&gt;defer&lt;&#x2F;code&gt; runs at scope exit including early returns and error propagation.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;defer-reserves-the-value&quot;&gt;Defer Reserves the Value&lt;&#x2F;h3&gt;
&lt;p&gt;When a value is scheduled with &lt;code&gt;defer destroy(x)&lt;&#x2F;code&gt;, it becomes reserved. The rules:&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;After &lt;code&gt;defer destroy(x)&lt;&#x2F;code&gt;, you cannot move &lt;code&gt;x&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;After &lt;code&gt;defer destroy(x)&lt;&#x2F;code&gt;, you cannot destroy &lt;code&gt;x&lt;&#x2F;code&gt; again&lt;&#x2F;li&gt;
&lt;li&gt;After &lt;code&gt;defer destroy(x)&lt;&#x2F;code&gt;, you cannot &lt;code&gt;defer destroy(x)&lt;&#x2F;code&gt; again&lt;&#x2F;li&gt;
&lt;li&gt;After &lt;code&gt;defer destroy(x)&lt;&#x2F;code&gt;, you cannot create borrows of &lt;code&gt;x&lt;&#x2F;code&gt; that might overlap the deferred destruction point&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;The value is still owned by the current scope until exit, but it is no longer available for use. This prevents double destruction and dangling borrows.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;abort&quot;&gt;Abort&lt;&#x2F;h3&gt;
&lt;p&gt;Abort is immediate process termination, outside normal control flow. Following Zig&#x27;s model:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;Out-of-memory conditions trigger abort&lt;&#x2F;li&gt;
&lt;li&gt;Stack overflow triggers abort&lt;&#x2F;li&gt;
&lt;li&gt;Explicit &lt;code&gt;abort()&lt;&#x2F;code&gt; terminates immediately&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;Deferred cleanup does not run on abort&lt;&#x2F;strong&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;&lt;code&gt;defer&lt;&#x2F;code&gt; is for normal control flow, not catastrophic failure. Abort is outside language semantics. The process stops. There are no guarantees about state after abort begins.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;borrowing&quot;&gt;Borrowing&lt;&#x2F;h2&gt;
&lt;p&gt;References let you use values without consuming them. Concrete&#x27;s borrowing model draws from Rust but simplifies it: references exist within lexical regions that bound their lifetime, with no lifetime parameters in function signatures.&lt;&#x2F;p&gt;
&lt;pre class=&quot;z-code&quot;&gt;&lt;code&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;borrow f as fref in R {
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;    &#x2F;&#x2F; fref has type &amp;amp;[File, R]
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;    &#x2F;&#x2F; f is unusable in this block
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;    let len = length(fref)
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;}
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;&#x2F;&#x2F; f is usable again
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Functions that accept references are generic over the region, but implicitly:&lt;&#x2F;p&gt;
&lt;pre class=&quot;z-code&quot;&gt;&lt;code&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;fn length&amp;lt;R&amp;gt;(file: &amp;amp;[File, R]) -&amp;gt; Uint {
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;    ...
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The function cannot store the reference because it cannot name &lt;code&gt;R&lt;&#x2F;code&gt; outside the call.&lt;&#x2F;p&gt;
&lt;p&gt;For single-expression borrows, the region is anonymous:&lt;&#x2F;p&gt;
&lt;pre class=&quot;z-code&quot;&gt;&lt;code&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;let len = length(&amp;amp;f)  &#x2F;&#x2F; borrows f for just this call
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h3 id=&quot;borrowing-rules&quot;&gt;Borrowing Rules&lt;&#x2F;h3&gt;
&lt;ol&gt;
&lt;li&gt;While borrowed, the original is unusable&lt;&#x2F;li&gt;
&lt;li&gt;Multiple immutable borrows allowed&lt;&#x2F;li&gt;
&lt;li&gt;Mutable borrows exclusive: one &lt;code&gt;&amp;amp;mut T&lt;&#x2F;code&gt; at a time, no simultaneous &lt;code&gt;&amp;amp;T&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;References cannot escape their region&lt;&#x2F;li&gt;
&lt;li&gt;Nested borrows of the same owned value forbidden&lt;&#x2F;li&gt;
&lt;li&gt;Derived references can&#x27;t outlive the original&#x27;s region&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;Closures cannot capture references if the closure escapes the borrow region. This ensures references never outlive their lexical scope.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;capabilities&quot;&gt;Capabilities&lt;&#x2F;h2&gt;
&lt;h3 id=&quot;what-capabilities-are&quot;&gt;What Capabilities Are&lt;&#x2F;h3&gt;
&lt;p&gt;A capability is a static permission annotation on a function. It declares which effects the function may perform. Capabilities are not runtime values—they cannot be created, passed, stored, or inspected at runtime. They exist only at the type level, checked by the compiler and erased before execution.&lt;&#x2F;p&gt;
&lt;p&gt;Capabilities are predefined names. Users cannot define new capabilities or create composite capability types. Function signatures may combine predefined capabilities using &lt;code&gt;+&lt;&#x2F;code&gt; in the &lt;code&gt;with()&lt;&#x2F;code&gt; clause, but only among names exported by the platform&#x27;s capability universe. There is no capability arithmetic, no capability inheritance, no way to forge a capability your caller didn&#x27;t have.&lt;&#x2F;p&gt;
&lt;p&gt;Capabilities that can be manufactured at runtime aren&#x27;t capabilities—they&#x27;re tokens.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;purity&quot;&gt;Purity&lt;&#x2F;h3&gt;
&lt;p&gt;Concrete is &lt;strong&gt;pure by default&lt;&#x2F;strong&gt;, following Austral&#x27;s approach to effect tracking. A function without capability annotations cannot perform IO, cannot allocate, cannot mutate external state. It computes a result from its inputs, nothing more.&lt;&#x2F;p&gt;
&lt;p&gt;Purity in Concrete has a precise definition: a function is pure if and only if it declares no capabilities and does not require &lt;code&gt;Alloc&lt;&#x2F;code&gt;. Equivalently, purity means an empty capability set.&lt;&#x2F;p&gt;
&lt;p&gt;Pure functions may use stack allocation and compile-time constants—these are not effects. Pure functions may diverge—termination is orthogonal to purity. A non-terminating function that performs no IO and touches no heap is still pure. This separates effect-freedom (what Concrete tracks) from totality (which Concrete does not guarantee).&lt;&#x2F;p&gt;
&lt;p&gt;Purity enables equational reasoning: a pure function called twice with the same arguments yields the same result. Totality would enable stronger claims about program termination, but enforcing it would require restricting recursion, which conflicts with systems programming.&lt;&#x2F;p&gt;
&lt;p&gt;When a function needs effects, it declares them:&lt;&#x2F;p&gt;
&lt;pre class=&quot;z-code&quot;&gt;&lt;code&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;fn read_file(path: String) with(File) -&amp;gt; String {
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;    ...
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;}
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;fn process_data() with(File, Network, Alloc) -&amp;gt; Result {
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;    ...
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Capabilities propagate monotonically. If &lt;code&gt;f&lt;&#x2F;code&gt; calls &lt;code&gt;g&lt;&#x2F;code&gt;, and &lt;code&gt;g&lt;&#x2F;code&gt; requires &lt;code&gt;File&lt;&#x2F;code&gt;, then &lt;code&gt;f&lt;&#x2F;code&gt; must declare &lt;code&gt;File&lt;&#x2F;code&gt; too. No implicit granting, no ambient authority. The compiler enforces this transitively.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;the-std-capability&quot;&gt;The Std Capability&lt;&#x2F;h3&gt;
&lt;p&gt;For application entry points, Concrete provides a shorthand. The &lt;code&gt;!&lt;&#x2F;code&gt; suffix declares the &lt;code&gt;Std&lt;&#x2F;code&gt; capability:&lt;&#x2F;p&gt;
&lt;pre class=&quot;z-code&quot;&gt;&lt;code&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;fn main!() {
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;    println(&amp;quot;Hello&amp;quot;)
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This desugars to &lt;code&gt;fn main() with(Std)&lt;&#x2F;code&gt;. &lt;code&gt;Std&lt;&#x2F;code&gt; includes file operations, network, clock, environment, random, and allocation, but excludes &lt;code&gt;Unsafe&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Library code should prefer explicit capability lists.&lt;&#x2F;strong&gt; This is a social convention, not a mechanical enforcement. The compiler won&#x27;t reject a library function that uses &lt;code&gt;Std&lt;&#x2F;code&gt;. But explicit capabilities make dependencies auditable. &lt;code&gt;Std&lt;&#x2F;code&gt; is a convenience for applications, not a license for libraries.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;security-model&quot;&gt;Security Model&lt;&#x2F;h3&gt;
&lt;p&gt;Capabilities don&#x27;t sandbox code. If a dependency declares &lt;code&gt;with(Network)&lt;&#x2F;code&gt;, it gets network access. What they provide is &lt;strong&gt;auditability&lt;&#x2F;strong&gt;. You can grep for &lt;code&gt;with(Network)&lt;&#x2F;code&gt; and find every function that touches the network. You can verify that your JSON parser has no capabilities. You can review dependency updates by diffing capability declarations.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;capability-polymorphism&quot;&gt;Capability Polymorphism&lt;&#x2F;h3&gt;
&lt;p&gt;Currently, you cannot be generic over capability sets:&lt;&#x2F;p&gt;
&lt;pre class=&quot;z-code&quot;&gt;&lt;code&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;&#x2F;&#x2F; Not allowed
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;fn map&amp;lt;T, U, C&amp;gt;(list: List&amp;lt;T&amp;gt;, f: fn(T) with(C) -&amp;gt; U) with(C) -&amp;gt; List&amp;lt;U&amp;gt;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Each capability set must be concrete. This means generic combinators must be duplicated per capability set. Capability polymorphism is future work; the theory is well-understood (effect polymorphism in Koka, Eff, Frank), but adds complexity to the type system and the Lean formalization.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;parametricity&quot;&gt;Parametricity&lt;&#x2F;h3&gt;
&lt;p&gt;Generic functions cannot accidentally become effectful depending on instantiation. A function &lt;code&gt;fn map&amp;lt;T, U&amp;gt;(list: List&amp;lt;T&amp;gt;, f: fn(T) -&amp;gt; U) -&amp;gt; List&amp;lt;U&amp;gt;&lt;&#x2F;code&gt; is pure regardless of what &lt;code&gt;T&lt;&#x2F;code&gt; and &lt;code&gt;U&lt;&#x2F;code&gt; are. If &lt;code&gt;f&lt;&#x2F;code&gt; requires capabilities, that must be declared in the signature.&lt;&#x2F;p&gt;
&lt;p&gt;Capabilities are checked before monomorphization. When generic code is specialized to concrete types, capability requirements don&#x27;t change. A pure generic function stays pure at every instantiation.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;allocation&quot;&gt;Allocation&lt;&#x2F;h2&gt;
&lt;p&gt;Allocation deserves special attention because it&#x27;s often invisible. In most languages, many operations allocate behind your back: string concatenation, collection growth, closure creation.&lt;&#x2F;p&gt;
&lt;p&gt;Concrete treats allocation as a capability, with explicit allocator passing inspired by Zig. Functions that allocate declare &lt;code&gt;with(Alloc)&lt;&#x2F;code&gt;. The call site binds which allocator:&lt;&#x2F;p&gt;
&lt;pre class=&quot;z-code&quot;&gt;&lt;code&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;fn main!() {
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;    let arena = Arena.new()
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;    defer arena.deinit()
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;    
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;    let list = create_list&amp;lt;Int&amp;gt;() with(Alloc = arena)
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;    push(&amp;amp;mut list, 42) with(Alloc = arena)
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Inside &lt;code&gt;with(Alloc)&lt;&#x2F;code&gt;, the bound allocator propagates through nested calls. At the boundary, you see exactly where allocation happens and which allocator serves it.&lt;&#x2F;p&gt;
&lt;p&gt;Stack allocation does not require &lt;code&gt;Alloc&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre class=&quot;z-code&quot;&gt;&lt;code&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;fn example() {
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;    let x: Int = 42                    &#x2F;&#x2F; stack
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;    let arr: [100]Uint8 = zeroed()     &#x2F;&#x2F; stack
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Allocation-free code is provably allocation-free.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;allocator-binding-scope&quot;&gt;Allocator Binding Scope&lt;&#x2F;h3&gt;
&lt;p&gt;Allocator binding is lexically scoped. A binding applies within the static extent of the call being evaluated and any nested calls that require &lt;code&gt;with(Alloc)&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;A nested binding may shadow an outer binding:&lt;&#x2F;p&gt;
&lt;pre class=&quot;z-code&quot;&gt;&lt;code&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;fn outer() with(Alloc) {
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;    inner()                         &#x2F;&#x2F; uses outer binding
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;    inner() with(Alloc = arena2)    &#x2F;&#x2F; shadows within this call
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Closures capture allocator bindings only if the closure is invoked within the lexical scope where the binding is in effect. If a closure escapes that scope, it cannot rely on an implicit allocator binding and must instead accept an explicit allocator parameter or be rejected by the type checker.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;allocator-types&quot;&gt;Allocator Types&lt;&#x2F;h3&gt;
&lt;pre class=&quot;z-code&quot;&gt;&lt;code&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;&#x2F;&#x2F; General-purpose heap allocator
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;let gpa = GeneralPurposeAllocator.new()
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;defer gpa.deinit()
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;&#x2F;&#x2F; Arena allocator, free everything at once
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;let arena = Arena.new(gpa)
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;defer arena.deinit()
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;&#x2F;&#x2F; Fixed buffer allocator, no heap
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;let buf: [1024]Uint8 = zeroed()
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;let fba = FixedBufferAllocator.new(&amp;amp;buf)
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;All allocators implement a common &lt;code&gt;Allocator&lt;&#x2F;code&gt; trait.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;allocator-interface&quot;&gt;Allocator Interface&lt;&#x2F;h3&gt;
&lt;pre class=&quot;z-code&quot;&gt;&lt;code&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;trait Allocator {
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;    fn alloc&amp;lt;T&amp;gt;(&amp;amp;mut self, count: Uint) -&amp;gt; Result&amp;lt;&amp;amp;mut [T], AllocError&amp;gt;
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;    fn free&amp;lt;T&amp;gt;(&amp;amp;mut self, ptr: &amp;amp;mut [T])
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;    fn realloc&amp;lt;T&amp;gt;(&amp;amp;mut self, ptr: &amp;amp;mut [T], new_count: Uint) -&amp;gt; Result&amp;lt;&amp;amp;mut [T], AllocError&amp;gt;
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The interface is minimal. &lt;code&gt;alloc&lt;&#x2F;code&gt; returns a mutable slice or fails. &lt;code&gt;free&lt;&#x2F;code&gt; releases memory. &lt;code&gt;realloc&lt;&#x2F;code&gt; resizes in place or relocates. All three take &lt;code&gt;&amp;amp;mut self&lt;&#x2F;code&gt;—allocators are stateful resources, not ambient services.&lt;&#x2F;p&gt;
&lt;p&gt;Custom allocators implement this trait. The standard library allocators (&lt;code&gt;GeneralPurposeAllocator&lt;&#x2F;code&gt;, &lt;code&gt;Arena&lt;&#x2F;code&gt;, &lt;code&gt;FixedBufferAllocator&lt;&#x2F;code&gt;) are implementations, not special cases.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;error-handling&quot;&gt;Error Handling&lt;&#x2F;h2&gt;
&lt;p&gt;Errors are values, using &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;&#x2F;code&gt; like Rust and the &lt;code&gt;?&lt;&#x2F;code&gt; operator for propagation:&lt;&#x2F;p&gt;
&lt;pre class=&quot;z-code&quot;&gt;&lt;code&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;fn parse(input: String) -&amp;gt; Result&amp;lt;Config, ParseError&amp;gt; {
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;    ...
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;}
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;fn load_config!() -&amp;gt; Result&amp;lt;Config, Error&amp;gt; {
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;    let f = open(&amp;quot;config.toml&amp;quot;)?
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;    defer destroy(f)
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;    
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;    let content = read(&amp;amp;f)
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;    let config = parse(content)?
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;    Ok(config)
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The &lt;code&gt;?&lt;&#x2F;code&gt; operator propagates errors. When &lt;code&gt;?&lt;&#x2F;code&gt; triggers an early return, all &lt;code&gt;defer&lt;&#x2F;code&gt; statements in scope run first. Cleanup happens even on error paths.&lt;&#x2F;p&gt;
&lt;p&gt;No exceptions. No panic. Unrecoverable faults (out-of-memory, stack overflow, explicit abort) terminate immediately without running deferred cleanup.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;what-you-re-giving-up&quot;&gt;What You&#x27;re Giving Up&lt;&#x2F;h2&gt;
&lt;p&gt;Concrete is not a general-purpose language. It&#x27;s for code that must be correct: cryptographic implementations, financial systems, safety-critical software, blockchain infrastructure.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;No garbage collection.&lt;&#x2F;strong&gt; Memory is managed through linear types and explicit destruction. No GC pauses, no unpredictable latency, no hidden memory pressure.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;No implicit control flow.&lt;&#x2F;strong&gt; What you see is what executes. No implicit function calls from operator overloading, no compiler-inserted destructor calls. &lt;code&gt;defer&lt;&#x2F;code&gt; statements are explicit: you write them, you see them, even though their execution occurs at scope exit.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;No implicit allocation.&lt;&#x2F;strong&gt; Allocation requires the &lt;code&gt;Alloc&lt;&#x2F;code&gt; capability. &lt;code&gt;grep with(Alloc)&lt;&#x2F;code&gt; finds every function that might touch the heap.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;No interior mutability.&lt;&#x2F;strong&gt; All mutation flows through &lt;code&gt;&amp;amp;mut&lt;&#x2F;code&gt; references. An immutable reference &lt;code&gt;&amp;amp;T&lt;&#x2F;code&gt; guarantees immutability, no hidden mutation behind an immutable facade. This forbids patterns like shared caches and memoization behind shared references. If you need a cache, pass &lt;code&gt;&amp;amp;mut&lt;&#x2F;code&gt;. If you need lazy initialization, initialize before borrowing. For advanced patterns that genuinely require interior mutability, the standard library provides &lt;code&gt;UnsafeCell&amp;lt;T&amp;gt;&lt;&#x2F;code&gt; gated by the &lt;code&gt;Unsafe&lt;&#x2F;code&gt; capability.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;No reflection, no eval, no runtime metaprogramming.&lt;&#x2F;strong&gt; All code paths are determined at compile time. There is no way to inspect types at runtime, call methods by name dynamically, or generate code during execution.&lt;&#x2F;p&gt;
&lt;p&gt;If macros are added in a future version, they will be constrained to preserve the &quot;can a machine reason about this?&quot; principle:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Hygienic&lt;&#x2F;strong&gt; — no accidental variable capture&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;Phase-separated&lt;&#x2F;strong&gt; — macro expansion completes before type checking&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;Syntactic&lt;&#x2F;strong&gt; — macros transform syntax trees, not strings&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;Capability-tracked&lt;&#x2F;strong&gt; — procedural macros that execute arbitrary code at compile time will require capability annotations, extending effect tracking to the compile-time phase&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;&lt;strong&gt;No implicit global state.&lt;&#x2F;strong&gt; All global interactions (file system, network, clock, environment) are mediated through capabilities.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;No variable shadowing.&lt;&#x2F;strong&gt; Each variable name is unique within its scope.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;No null.&lt;&#x2F;strong&gt; Optional values use &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;No undefined behavior in safe code.&lt;&#x2F;strong&gt; Kernel semantics are fully defined and proven sound. The &lt;code&gt;Unsafe&lt;&#x2F;code&gt; capability explicitly reintroduces the possibility of undefined behavior for FFI and low-level operations.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;No concurrency primitives.&lt;&#x2F;strong&gt; The language provides no threads, no async&#x2F;await, no channels. Concurrency is a library concern. This may change, but any future concurrency model must preserve determinism and linearity, likely through structured or deterministic concurrency. This is a design constraint, not an open question.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;anti-features-summary&quot;&gt;Anti-Features Summary&lt;&#x2F;h3&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;Concrete does not have&lt;&#x2F;th&gt;&lt;th&gt;Rationale&lt;&#x2F;th&gt;&lt;&#x2F;tr&gt;&lt;&#x2F;thead&gt;&lt;tbody&gt;
&lt;tr&gt;&lt;td&gt;Garbage collection&lt;&#x2F;td&gt;&lt;td&gt;Predictable latency, explicit resource management&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;Hidden control flow&lt;&#x2F;td&gt;&lt;td&gt;Auditability, debuggability&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;Hidden allocation&lt;&#x2F;td&gt;&lt;td&gt;Performance visibility, allocator control&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;Interior mutability&lt;&#x2F;td&gt;&lt;td&gt;Simple reasoning, verification tractability&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;Reflection &#x2F; eval&lt;&#x2F;td&gt;&lt;td&gt;Static analysis, all paths known at compile time&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;Global mutable state&lt;&#x2F;td&gt;&lt;td&gt;Effect tracking, reproducibility&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;Variable shadowing&lt;&#x2F;td&gt;&lt;td&gt;Clarity, fewer subtle bugs&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;Null&lt;&#x2F;td&gt;&lt;td&gt;Type safety via &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;Exceptions&lt;&#x2F;td&gt;&lt;td&gt;Errors as values, explicit propagation&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;Implicit conversions&lt;&#x2F;td&gt;&lt;td&gt;No silent data loss or coercion&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;Function overloading&lt;&#x2F;td&gt;&lt;td&gt;Except through traits with explicit bounds&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;Uninitialized variables&lt;&#x2F;td&gt;&lt;td&gt;Memory safety&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;Macros&lt;&#x2F;td&gt;&lt;td&gt;Undecided; if added, will be hygienic and capability-aware&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;Concurrency primitives&lt;&#x2F;td&gt;&lt;td&gt;Undecided; must preserve linearity and determinism&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;Undefined behavior (in safe code)&lt;&#x2F;td&gt;&lt;td&gt;Kernel semantics fully defined&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;&#x2F;tbody&gt;&lt;&#x2F;table&gt;
&lt;h2 id=&quot;pattern-matching&quot;&gt;Pattern Matching&lt;&#x2F;h2&gt;
&lt;p&gt;Exhaustive pattern matching with linear type awareness:&lt;&#x2F;p&gt;
&lt;pre class=&quot;z-code&quot;&gt;&lt;code&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;fn describe(opt: Option&amp;lt;Int&amp;gt;) -&amp;gt; String {
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;    match opt {
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;        Some(n) =&amp;gt; format(&amp;quot;Got {}&amp;quot;, n),
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;        None =&amp;gt; &amp;quot;Nothing&amp;quot;
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;    }
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Linear types in patterns must be consumed:&lt;&#x2F;p&gt;
&lt;pre class=&quot;z-code&quot;&gt;&lt;code&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;fn handle!(result: Result&amp;lt;Data, File&amp;gt;) {
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;    match result {
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;        Ok(data) =&amp;gt; use_data(data),
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;        Err(f) =&amp;gt; destroy(f)
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;    }
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Borrowing in patterns:&lt;&#x2F;p&gt;
&lt;pre class=&quot;z-code&quot;&gt;&lt;code&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;fn peek(opt: &amp;amp;Option&amp;lt;Int&amp;gt;) -&amp;gt; Int {
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;    match opt {
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;        &amp;amp;Some(n) =&amp;gt; n,
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;        &amp;amp;None =&amp;gt; 0
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;    }
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;traits&quot;&gt;Traits&lt;&#x2F;h2&gt;
&lt;p&gt;Traits provide bounded polymorphism, similar to Rust&#x27;s trait system:&lt;&#x2F;p&gt;
&lt;pre class=&quot;z-code&quot;&gt;&lt;code&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;trait Ord {
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;    fn compare(&amp;amp;self, other: &amp;amp;Self) -&amp;gt; Ordering
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;}
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;trait Show {
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;    fn show(&amp;amp;self) -&amp;gt; String
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;}
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;fn sort&amp;lt;T: Ord&amp;gt;(list: List&amp;lt;T&amp;gt;) with(Alloc) -&amp;gt; List&amp;lt;T&amp;gt; {
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;    ...
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h3 id=&quot;receiver-modes-and-linear-types&quot;&gt;Receiver Modes and Linear Types&lt;&#x2F;h3&gt;
&lt;p&gt;Trait methods take the receiver in one of three forms:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&amp;amp;self&lt;&#x2F;code&gt; — borrows the value immutably&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;&amp;amp;mut self&lt;&#x2F;code&gt; — borrows the value mutably&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;self&lt;&#x2F;code&gt; — takes ownership, consuming the value&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;If a trait method takes &lt;code&gt;self&lt;&#x2F;code&gt;, calling it consumes the value. This follows linear consumption rules:&lt;&#x2F;p&gt;
&lt;pre class=&quot;z-code&quot;&gt;&lt;code&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;trait Consume {
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;    fn consume(self)
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;}
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;fn use_once&amp;lt;T: Consume&amp;gt;(x: T) {
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;    x.consume()  &#x2F;&#x2F; x is consumed here
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;    &#x2F;&#x2F; x.consume()  &#x2F;&#x2F; ERROR: x already consumed
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;A trait implementation for a linear type must respect the receiver mode. An &lt;code&gt;&amp;amp;self&lt;&#x2F;code&gt; method cannot consume the value. An &lt;code&gt;&amp;amp;mut self&lt;&#x2F;code&gt; method cannot let the value escape. A &lt;code&gt;self&lt;&#x2F;code&gt; method consumes it.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;type-inference&quot;&gt;Type Inference&lt;&#x2F;h2&gt;
&lt;p&gt;Type inference is &lt;strong&gt;local only&lt;&#x2F;strong&gt;. Function signatures must be fully annotated. Inside bodies, local types may be inferred:&lt;&#x2F;p&gt;
&lt;pre class=&quot;z-code&quot;&gt;&lt;code&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;fn process(data: List&amp;lt;Int&amp;gt;) with(Alloc) -&amp;gt; List&amp;lt;Int&amp;gt; {
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;    let doubled = map(data, fn(x) { x * 2 })  &#x2F;&#x2F; inferred
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;    let filtered = filter(doubled, fn(x) { x &amp;gt; 0 })  &#x2F;&#x2F; inferred
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;    filtered
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;You can always understand a function&#x27;s interface without reading its body.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;modules&quot;&gt;Modules&lt;&#x2F;h2&gt;
&lt;pre class=&quot;z-code&quot;&gt;&lt;code&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;module FileSystem
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;public fn open(path: String) with(File) -&amp;gt; Result&amp;lt;File, IOError&amp;gt; {
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;    ...
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;}
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;public fn read&amp;lt;R&amp;gt;(file: &amp;amp;[File, R]) with(File) -&amp;gt; String {
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;    ...
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;}
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;private fn validate(path: String) -&amp;gt; Bool {
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;    ...
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Visibility is &lt;code&gt;public&lt;&#x2F;code&gt; or &lt;code&gt;private&lt;&#x2F;code&gt; (default).&lt;&#x2F;p&gt;
&lt;h3 id=&quot;capabilities-as-public-contract&quot;&gt;Capabilities as Public Contract&lt;&#x2F;h3&gt;
&lt;p&gt;Capabilities are part of a function&#x27;s signature and therefore part of the public API contract. Changing the required capability set of a public function is a breaking change. This applies in both directions: adding a capability requirement breaks callers who don&#x27;t have it; removing one changes the function&#x27;s guarantees.&lt;&#x2F;p&gt;
&lt;p&gt;When reviewing dependency updates, diff the capability declarations. A library that adds &lt;code&gt;with(Network)&lt;&#x2F;code&gt; to a function that previously had none is a significant change, even if the types remain identical.&lt;&#x2F;p&gt;
&lt;pre class=&quot;z-code&quot;&gt;&lt;code&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;import FileSystem
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;import FileSystem.{open, read, write}
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;import FileSystem as FS
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;unsafe-and-ffi&quot;&gt;Unsafe and FFI&lt;&#x2F;h2&gt;
&lt;p&gt;The &lt;code&gt;Unsafe&lt;&#x2F;code&gt; capability gates operations the type system cannot verify: foreign function calls, raw pointer operations, type transmutation, inline assembly, and linearity bypasses.&lt;&#x2F;p&gt;
&lt;pre class=&quot;z-code&quot;&gt;&lt;code&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;fn transmute&amp;lt;T, U&amp;gt;(value: T) with(Unsafe) -&amp;gt; U
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;fn ptr_read&amp;lt;T&amp;gt;(ptr: Address[T]) with(Unsafe) -&amp;gt; T
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;fn ptr_write&amp;lt;T&amp;gt;(ptr: Address[T], value: T) with(Unsafe)
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;&lt;code&gt;Unsafe&lt;&#x2F;code&gt; propagates through the call graph like any other capability. Grep for &lt;code&gt;with(Unsafe)&lt;&#x2F;code&gt; to find all trust boundaries.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;raw-pointers&quot;&gt;Raw Pointers&lt;&#x2F;h3&gt;
&lt;p&gt;Raw pointers exist for FFI and low-level memory manipulation:&lt;&#x2F;p&gt;
&lt;pre class=&quot;z-code&quot;&gt;&lt;code&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;Address[T]       &#x2F;&#x2F; raw pointer to T
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Raw pointers are &lt;code&gt;Copy&lt;&#x2F;code&gt;. They carry no lifetime information and no linearity guarantees. This is safe because:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;Creating a raw pointer is safe. &lt;code&gt;address_of(r)&lt;&#x2F;code&gt; extracts an address.&lt;&#x2F;li&gt;
&lt;li&gt;Holding a raw pointer is safe. It&#x27;s a number.&lt;&#x2F;li&gt;
&lt;li&gt;Using a raw pointer requires &lt;code&gt;Unsafe&lt;&#x2F;code&gt;. Dereference, arithmetic, and casting are gated.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;pre class=&quot;z-code&quot;&gt;&lt;code&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;fn to_ptr&amp;lt;T&amp;gt;(r: &amp;amp;T) -&amp;gt; Address[T] {
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;    address_of(r)  &#x2F;&#x2F; safe
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;}
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;fn deref&amp;lt;T&amp;gt;(ptr: Address[T]) with(Unsafe) -&amp;gt; T {
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;    read_ptr(ptr)  &#x2F;&#x2F; unsafe: no guarantee ptr is valid
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;&lt;code&gt;Copy&lt;&#x2F;code&gt; does not imply usable. Raw pointers can be freely duplicated because they carry no guarantees. Safety is enforced at the point of use, not at the point of creation.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;foreign-functions&quot;&gt;Foreign Functions&lt;&#x2F;h3&gt;
&lt;p&gt;Declare foreign functions with &lt;code&gt;Unsafe&lt;&#x2F;code&gt; and the &lt;code&gt;foreign&lt;&#x2F;code&gt; directive:&lt;&#x2F;p&gt;
&lt;pre class=&quot;z-code&quot;&gt;&lt;code&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;fn malloc(size: Uint) with(Unsafe) -&amp;gt; Address[Unit] =
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;    foreign(&amp;quot;malloc&amp;quot;)
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;fn free(ptr: Address[Unit]) with(Unsafe) =
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;    foreign(&amp;quot;free&amp;quot;)
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The compiler generates calling convention glue and links the symbol. Foreign signatures are restricted to C-compatible types. Details of the type mapping are deferred to a future FFI specification.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;implementation&quot;&gt;Implementation&lt;&#x2F;h2&gt;
&lt;h3 id=&quot;determinism&quot;&gt;Determinism&lt;&#x2F;h3&gt;
&lt;p&gt;Concrete aims for &lt;strong&gt;bit-for-bit reproducible builds&lt;&#x2F;strong&gt;: same source + same compiler = identical binary. No timestamps, random seeds, or environment-dependent data in output.&lt;&#x2F;p&gt;
&lt;p&gt;For debugging, &lt;strong&gt;deterministic replay&lt;&#x2F;strong&gt;: random generation requires &lt;code&gt;Random&lt;&#x2F;code&gt; with explicit seed, system time requires &lt;code&gt;Clock&lt;&#x2F;code&gt;. Same inputs produce identical execution.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;the-grammar&quot;&gt;The Grammar&lt;&#x2F;h3&gt;
&lt;p&gt;LL(1). Every parsing decision with a single token of lookahead. No ambiguity, no backtracking.&lt;&#x2F;p&gt;
&lt;p&gt;This is a permanent design constraint, not an implementation detail. Future language evolution is bounded by what LL(1) can express. We accept this constraint for tooling simplicity and error message quality.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;compilation-targets&quot;&gt;Compilation Targets&lt;&#x2F;h3&gt;
&lt;p&gt;&lt;strong&gt;Native&lt;&#x2F;strong&gt; via MLIR&#x2F;LLVM, &lt;strong&gt;C&lt;&#x2F;strong&gt; for portability, &lt;strong&gt;WebAssembly&lt;&#x2F;strong&gt; for browser and edge. Cross-compilation is first-class.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;tooling&quot;&gt;Tooling&lt;&#x2F;h3&gt;
&lt;p&gt;Concrete ships with package manager, formatter, linter, test runner, and REPL. Part of the distribution, not external dependencies.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;what-you-can-say-about-programs&quot;&gt;What You Can Say About Programs&lt;&#x2F;h2&gt;
&lt;p&gt;If a program type-checks:&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;&quot;This function is pure.&quot;&lt;&#x2F;strong&gt; No capabilities declared. No side effects, no IO, no allocation.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;&quot;This resource is used exactly once.&quot;&lt;&#x2F;strong&gt; Linear type. No leaks, no double-free, no use-after-free.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;&quot;These are the only effects this code can perform.&quot;&lt;&#x2F;strong&gt; Capability set is explicit and complete.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;&quot;This code cannot escape the type system.&quot;&lt;&#x2F;strong&gt; Unsafe operations require &lt;code&gt;with(Unsafe)&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;&quot;Allocation happens here, using this allocator.&quot;&lt;&#x2F;strong&gt; Call site binds the allocator.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;&quot;Cleanup happens here.&quot;&lt;&#x2F;strong&gt; &lt;code&gt;defer destroy(x)&lt;&#x2F;code&gt; is visible.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;&quot;This build is reproducible.&quot;&lt;&#x2F;strong&gt; Same inputs, same binary.&lt;&#x2F;p&gt;
&lt;p&gt;Mechanical guarantees from a type system proven sound in Lean. Not conventions, proofs.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;example&quot;&gt;Example&lt;&#x2F;h2&gt;
&lt;pre class=&quot;z-code&quot;&gt;&lt;code&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;module Main
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;import FileSystem.{open, read, write}
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;import Parse.{parse_csv}
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;fn process_file(input_path: String, output_path: String) with(File, Alloc) -&amp;gt; Result&amp;lt;Unit, Error&amp;gt; {
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;    let in_file = open(input_path)?
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;    defer destroy(in_file)
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;    
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;    let content = read(&amp;amp;in_file)
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;    let data = parse_csv(content)?
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;    let output = transform(&amp;amp;data)
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;    
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;    let out_file = open(output_path)?
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;    defer destroy(out_file)
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;    
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;    write(&amp;amp;mut out_file, output)
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;    Ok(())
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;}
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;fn transform(data: &amp;amp;List&amp;lt;Row&amp;gt;) -&amp;gt; String {
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;    ...
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;}
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;fn main!() {
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;    let arena = Arena.new()
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;    defer arena.deinit()
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;    
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;    match process_file(&amp;quot;input.csv&amp;quot;, &amp;quot;output.txt&amp;quot;) with(Alloc = arena) {
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;        Ok(()) =&amp;gt; println(&amp;quot;Done&amp;quot;),
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;        Err(e) =&amp;gt; println(&amp;quot;Error: &amp;quot; + e.message())
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;    }
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Everything is visible: resource acquisition, cleanup scheduling, error propagation, allocator binding.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;influences&quot;&gt;Influences&lt;&#x2F;h2&gt;
&lt;p&gt;The kernel calculus is formalized in Lean 4. Coq could serve the same role; we chose Lean for its performance and active development.&lt;&#x2F;p&gt;
&lt;p&gt;Austral shaped the type system more than any other language. Linear types in Concrete are strict: every value must be consumed exactly once. Rust&#x27;s affine types allow dropping values without explicit consumption; we don&#x27;t. The capability system for effect tracking also comes from Austral.&lt;&#x2F;p&gt;
&lt;p&gt;From Rust: borrowing, traits, error handling, pattern matching. Concrete uses lexical regions instead of lifetime annotations, which simplifies the model but covers fewer cases. &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;&#x2F;code&gt; and the &lt;code&gt;?&lt;&#x2F;code&gt; operator are lifted directly.&lt;&#x2F;p&gt;
&lt;p&gt;Zig&#x27;s influence shows in explicit allocator passing and defer. Zig functions that allocate take an allocator parameter; Concrete expresses the same idea through &lt;code&gt;with(Alloc)&lt;&#x2F;code&gt; and allocator binding at call sites.&lt;&#x2F;p&gt;
&lt;p&gt;Go had defer first. Go also shipped gofmt, which ended style debates by making one canonical format. We ship a formatter too.&lt;&#x2F;p&gt;
&lt;p&gt;The &lt;code&gt;!&lt;&#x2F;code&gt; syntax for impure functions comes from Roc. &lt;code&gt;fn main!()&lt;&#x2F;code&gt; marks impurity at a glance.&lt;&#x2F;p&gt;
&lt;p&gt;Koka, Eff, and Frank are the algebraic effects languages. Concrete&#x27;s capabilities are a simplified version of their effect systems. Capability polymorphism would bring us closer to their expressiveness; it&#x27;s future work.&lt;&#x2F;p&gt;
&lt;p&gt;Haskell proved that pure-by-default is practical. Clean had uniqueness types (precursor to linear types) and purity before Haskell did.&lt;&#x2F;p&gt;
&lt;p&gt;Cyclone pioneered region-based memory, the research line that led to Rust&#x27;s lifetimes and our lexical regions. ATS showed linear types and theorem proving can coexist. Ada&#x2F;SPARK proved formal verification works in production: avionics, rail, security-critical systems.&lt;&#x2F;p&gt;
&lt;p&gt;CompCert and seL4 established that you can mechanically verify real systems software. A verified C compiler and a verified microkernel. That&#x27;s the standard we&#x27;re aiming for.&lt;&#x2F;p&gt;
&lt;p&gt;These ideas work. We&#x27;re combining them and proving the combination sound.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;who-should-use-this&quot;&gt;Who Should Use This&lt;&#x2F;h2&gt;
&lt;p&gt;Concrete trades convenience for explicitness, flexibility for auditability. Prototyping is slower. Some patterns become verbose. You&#x27;ll miss interior mutability for certain data structures.&lt;&#x2F;p&gt;
&lt;p&gt;But for cryptographic primitives, consensus protocols, financial transaction systems, medical device firmware, the trade is worth it. Strong claims about program behavior, mechanically verified.&lt;&#x2F;p&gt;
&lt;p&gt;A language you can trust the way you trust mathematics: not because someone promises it works, but because you can check the proof.&lt;&#x2F;p&gt;
&lt;hr &#x2F;&gt;
&lt;h2 id=&quot;quick-reference&quot;&gt;Quick Reference&lt;&#x2F;h2&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;Annotation&lt;&#x2F;th&gt;&lt;th&gt;Meaning&lt;&#x2F;th&gt;&lt;&#x2F;tr&gt;&lt;&#x2F;thead&gt;&lt;tbody&gt;
&lt;tr&gt;&lt;td&gt;&lt;code&gt;fn foo() -&amp;gt; T&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;Pure function, no capabilities&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;&lt;code&gt;fn foo!() -&amp;gt; T&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;Shorthand for &lt;code&gt;with(Std)&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;&lt;code&gt;fn foo() with(C) -&amp;gt; T&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;Requires capability set &lt;code&gt;C&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;&lt;code&gt;with(Alloc)&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;Function may allocate&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;&lt;code&gt;with(Alloc = a)&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;Bind allocator &lt;code&gt;a&lt;&#x2F;code&gt; at call site&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;&lt;code&gt;T&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;Linear type, consumed exactly once&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;&lt;code&gt;type Copy T&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;Unrestricted type, freely duplicated&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;&lt;code&gt;&amp;amp;T&lt;&#x2F;code&gt; or &lt;code&gt;&amp;amp;[T, R]&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;Immutable reference in region &lt;code&gt;R&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;&lt;code&gt;&amp;amp;mut T&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;Mutable reference&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;&lt;code&gt;Address[T]&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;Raw pointer (unsafe to use)&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;&lt;code&gt;borrow x as y in R { }&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;Explicit borrow with named region&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;&lt;code&gt;defer expr&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;Run &lt;code&gt;expr&lt;&#x2F;code&gt; at scope exit&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;&lt;code&gt;destroy(x)&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;Consume via destructor&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;&lt;code&gt;foreign(&quot;symbol&quot;)&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;Foreign function binding&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;&#x2F;tbody&gt;&lt;&#x2F;table&gt;
&lt;hr &#x2F;&gt;
&lt;h2 id=&quot;appendix-a-standard-capabilities&quot;&gt;Appendix A: Standard Capabilities&lt;&#x2F;h2&gt;
&lt;p&gt;The &lt;code&gt;Std&lt;&#x2F;code&gt; capability (accessed via &lt;code&gt;!&lt;&#x2F;code&gt;) bundles these individual capabilities:&lt;&#x2F;p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;Capability&lt;&#x2F;th&gt;&lt;th&gt;Gates&lt;&#x2F;th&gt;&lt;&#x2F;tr&gt;&lt;&#x2F;thead&gt;&lt;tbody&gt;
&lt;tr&gt;&lt;td&gt;&lt;code&gt;File&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;Open, read, write, close files. Directory operations.&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;&lt;code&gt;Network&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;Sockets, HTTP, DNS resolution.&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;&lt;code&gt;Alloc&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;Heap allocation. Requires allocator binding at call site.&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;&lt;code&gt;Clock&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;System time, monotonic time, sleep.&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;&lt;code&gt;Random&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;Random number generation. Requires explicit seed for reproducibility.&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;&lt;code&gt;Env&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;Environment variables, command line arguments.&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;&lt;code&gt;Process&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;Spawn processes, exit codes, signals.&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;&lt;code&gt;Console&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;Stdin, stdout, stderr.&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;&#x2F;tbody&gt;&lt;&#x2F;table&gt;
&lt;p&gt;Capabilities not in &lt;code&gt;Std&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;Capability&lt;&#x2F;th&gt;&lt;th&gt;Gates&lt;&#x2F;th&gt;&lt;&#x2F;tr&gt;&lt;&#x2F;thead&gt;&lt;tbody&gt;
&lt;tr&gt;&lt;td&gt;&lt;code&gt;Unsafe&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;Raw pointer operations, FFI calls, transmute, inline assembly. Never implicit.&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;&#x2F;tbody&gt;&lt;&#x2F;table&gt;
&lt;p&gt;A function with no capability annotation is pure. A function with &lt;code&gt;!&lt;&#x2F;code&gt; has access to everything except &lt;code&gt;Unsafe&lt;&#x2F;code&gt;. A function with explicit &lt;code&gt;with(File, Alloc)&lt;&#x2F;code&gt; has exactly those capabilities.&lt;&#x2F;p&gt;
&lt;p&gt;Capabilities are not hierarchical. &lt;code&gt;Std&lt;&#x2F;code&gt; is a shorthand for a set, not a super-capability. You cannot request &quot;half of Std.&quot;&lt;&#x2F;p&gt;
&lt;hr &#x2F;&gt;
&lt;h2 id=&quot;appendix-b-open-questions&quot;&gt;Appendix B: Open Questions&lt;&#x2F;h2&gt;
&lt;p&gt;These are unresolved design decisions:&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Concurrency&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;No concurrency primitives exist. The language is currently single-threaded. Any future model must preserve:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;Linearity (no data races from aliasing)&lt;&#x2F;li&gt;
&lt;li&gt;Determinism (reproducible execution)&lt;&#x2F;li&gt;
&lt;li&gt;Effect tracking (concurrency as capability)&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;Candidates: structured concurrency (like Trio&#x2F;libdill), deterministic parallelism (like Haskell&#x27;s &lt;code&gt;par&lt;&#x2F;code&gt;), actor model with linear message passing. Not decided.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Capability Polymorphism&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Currently impossible:&lt;&#x2F;p&gt;
&lt;pre class=&quot;z-code&quot;&gt;&lt;code&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;fn map&amp;lt;T, U, C&amp;gt;(list: List&amp;lt;T&amp;gt;, f: fn(T) with(C) -&amp;gt; U) with(C) -&amp;gt; List&amp;lt;U&amp;gt;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This forces duplicating combinators for each capability set. The theory exists (Koka, Eff, Frank), but adds complexity. Open question: is the duplication acceptable, or do we need polymorphism?&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Effect Handlers&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Capabilities track effects but don&#x27;t handle them. Full algebraic effects would allow:&lt;&#x2F;p&gt;
&lt;pre class=&quot;z-code&quot;&gt;&lt;code&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;fn with_mock_filesystem&amp;lt;T&amp;gt;(f: fn() with(File) -&amp;gt; T) -&amp;gt; T {
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;    handle File in f() {
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;        open(path) =&amp;gt; resume(MockFile.new(path))
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;        read(file) =&amp;gt; resume(mock_data)
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;    }
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This enables testing, sandboxing, effect interception. Significant implementation complexity. Not committed.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Module System&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Current design is minimal. Open questions:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;Parameterized modules (functors)?&lt;&#x2F;li&gt;
&lt;li&gt;Module-level capability restrictions?&lt;&#x2F;li&gt;
&lt;li&gt;Visibility modifiers beyond public&#x2F;private?&lt;&#x2F;li&gt;
&lt;li&gt;Separate compilation units?&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;&lt;strong&gt;FFI Type Mapping&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;The spec says &quot;C-compatible types&quot; without defining them. Need to specify:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;Integer mappings (is &lt;code&gt;Int&lt;&#x2F;code&gt; C&#x27;s &lt;code&gt;int&lt;&#x2F;code&gt; or &lt;code&gt;intptr_t&lt;&#x2F;code&gt;?)&lt;&#x2F;li&gt;
&lt;li&gt;Struct layout guarantees&lt;&#x2F;li&gt;
&lt;li&gt;Calling conventions&lt;&#x2F;li&gt;
&lt;li&gt;Nullable pointer representation&lt;&#x2F;li&gt;
&lt;li&gt;String encoding at boundaries&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;&lt;strong&gt;Variance&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Generic types have variance implications. &lt;code&gt;List&amp;lt;T&amp;gt;&lt;&#x2F;code&gt; is covariant in &lt;code&gt;T&lt;&#x2F;code&gt;. &lt;code&gt;fn(T) -&amp;gt; U&lt;&#x2F;code&gt; is contravariant in &lt;code&gt;T&lt;&#x2F;code&gt;. The spec doesn&#x27;t address this. For linear types, variance interacts with consumption. Needs formalization.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Macros&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;No macro system. Options:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;None (keep it simple)&lt;&#x2F;li&gt;
&lt;li&gt;Hygienic macros (Scheme-style)&lt;&#x2F;li&gt;
&lt;li&gt;Procedural macros (Rust-style)&lt;&#x2F;li&gt;
&lt;li&gt;Compile-time evaluation (Zig-style comptime)&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;Procedural macros would need capability restrictions. Not decided.&lt;&#x2F;p&gt;
&lt;hr &#x2F;&gt;
&lt;h2 id=&quot;appendix-c-glossary&quot;&gt;Appendix C: Glossary&lt;&#x2F;h2&gt;
&lt;p&gt;&lt;strong&gt;Affine type&lt;&#x2F;strong&gt;: A type whose values can be used at most once. Rust&#x27;s ownership model is affine: you can drop a value without consuming it.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Capability&lt;&#x2F;strong&gt;: A token that grants permission to perform an effect. Functions declare required capabilities; callers must have them. Capabilities propagate: if &lt;code&gt;f&lt;&#x2F;code&gt; calls &lt;code&gt;g&lt;&#x2F;code&gt;, and &lt;code&gt;g&lt;&#x2F;code&gt; needs &lt;code&gt;File&lt;&#x2F;code&gt;, then &lt;code&gt;f&lt;&#x2F;code&gt; needs &lt;code&gt;File&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Consumption&lt;&#x2F;strong&gt;: Using a linear value in a way that fulfills its &quot;exactly once&quot; obligation. Methods of consumption: pass to a function taking ownership, return, destructure via pattern match, call &lt;code&gt;destroy()&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Copy type&lt;&#x2F;strong&gt;: A type exempt from linearity. Values can be duplicated freely. Must be explicitly marked. Cannot have destructors or linear fields.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Destruction&lt;&#x2F;strong&gt;: Consuming a linear value by invoking its destructor. &lt;code&gt;destroy(x)&lt;&#x2F;code&gt; calls the type&#x27;s destructor and consumes &lt;code&gt;x&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Effect&lt;&#x2F;strong&gt;: An observable interaction with the world outside pure computation: IO, allocation, mutation, non-determinism. Concrete tracks effects through capabilities.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Elaboration&lt;&#x2F;strong&gt;: The compiler phase that transforms surface syntax into kernel IR. Type checking, linearity checking, and capability checking happen here.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Kernel&lt;&#x2F;strong&gt;: The core calculus formalized in Lean. A small language with mechanically verified properties. The surface language elaborates into it.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Lexical region&lt;&#x2F;strong&gt;: A scope that bounds reference lifetimes. References created in a region cannot escape it. Unlike Rust&#x27;s lifetime parameters, regions are always lexical and never appear in signatures.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Linear type&lt;&#x2F;strong&gt;: A type whose values must be used exactly once. Not zero (leak), not twice (double-use). Concrete&#x27;s default.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Purity&lt;&#x2F;strong&gt;: Absence of effects. A pure function computes a result from its inputs without IO, allocation, or mutation. In Concrete, functions without capability annotations are pure.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Raw pointer&lt;&#x2F;strong&gt;: An &lt;code&gt;Address[T]&lt;&#x2F;code&gt; value. Carries no lifetime or linearity information. Safe to create and hold; unsafe to use.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Reference&lt;&#x2F;strong&gt;: A borrowed view of a value. &lt;code&gt;&amp;amp;T&lt;&#x2F;code&gt; for immutable, &lt;code&gt;&amp;amp;mut T&lt;&#x2F;code&gt; for mutable. The original value is inaccessible while borrowed.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Region&lt;&#x2F;strong&gt;: See lexical region.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Std&lt;&#x2F;strong&gt;: The standard capability set. Shorthand for &lt;code&gt;File&lt;&#x2F;code&gt;, &lt;code&gt;Network&lt;&#x2F;code&gt;, &lt;code&gt;Alloc&lt;&#x2F;code&gt;, &lt;code&gt;Clock&lt;&#x2F;code&gt;, &lt;code&gt;Random&lt;&#x2F;code&gt;, &lt;code&gt;Env&lt;&#x2F;code&gt;, &lt;code&gt;Process&lt;&#x2F;code&gt;, &lt;code&gt;Console&lt;&#x2F;code&gt;. Excludes &lt;code&gt;Unsafe&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Unsafe&lt;&#x2F;strong&gt;: The capability that permits operations the type system cannot verify: FFI, raw pointer dereference, transmute.&lt;&#x2F;p&gt;
&lt;hr &#x2F;&gt;
&lt;h2 id=&quot;appendix-d-comparison-table&quot;&gt;Appendix D: Comparison Table&lt;&#x2F;h2&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;Feature&lt;&#x2F;th&gt;&lt;th&gt;Concrete&lt;&#x2F;th&gt;&lt;th&gt;Rust&lt;&#x2F;th&gt;&lt;th&gt;Zig&lt;&#x2F;th&gt;&lt;th&gt;Austral&lt;&#x2F;th&gt;&lt;th&gt;Go&lt;&#x2F;th&gt;&lt;&#x2F;tr&gt;&lt;&#x2F;thead&gt;&lt;tbody&gt;
&lt;tr&gt;&lt;td&gt;Memory safety&lt;&#x2F;td&gt;&lt;td&gt;Linear types&lt;&#x2F;td&gt;&lt;td&gt;Ownership + borrow checker&lt;&#x2F;td&gt;&lt;td&gt;Runtime checks (optional)&lt;&#x2F;td&gt;&lt;td&gt;Linear types&lt;&#x2F;td&gt;&lt;td&gt;GC&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;Linearity&lt;&#x2F;td&gt;&lt;td&gt;Strict (exactly once)&lt;&#x2F;td&gt;&lt;td&gt;Affine (at most once)&lt;&#x2F;td&gt;&lt;td&gt;None&lt;&#x2F;td&gt;&lt;td&gt;Strict&lt;&#x2F;td&gt;&lt;td&gt;None&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;GC&lt;&#x2F;td&gt;&lt;td&gt;None&lt;&#x2F;td&gt;&lt;td&gt;None&lt;&#x2F;td&gt;&lt;td&gt;None&lt;&#x2F;td&gt;&lt;td&gt;None&lt;&#x2F;td&gt;&lt;td&gt;Yes&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;Effect tracking&lt;&#x2F;td&gt;&lt;td&gt;Capabilities&lt;&#x2F;td&gt;&lt;td&gt;None&lt;&#x2F;td&gt;&lt;td&gt;None&lt;&#x2F;td&gt;&lt;td&gt;Capabilities&lt;&#x2F;td&gt;&lt;td&gt;None&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;Pure by default&lt;&#x2F;td&gt;&lt;td&gt;Yes&lt;&#x2F;td&gt;&lt;td&gt;No&lt;&#x2F;td&gt;&lt;td&gt;No&lt;&#x2F;td&gt;&lt;td&gt;Yes&lt;&#x2F;td&gt;&lt;td&gt;No&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;Explicit allocation&lt;&#x2F;td&gt;&lt;td&gt;Capability + binding&lt;&#x2F;td&gt;&lt;td&gt;Global allocator&lt;&#x2F;td&gt;&lt;td&gt;Allocator parameter&lt;&#x2F;td&gt;&lt;td&gt;No&lt;&#x2F;td&gt;&lt;td&gt;GC&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;Null&lt;&#x2F;td&gt;&lt;td&gt;None (&lt;code&gt;Option&amp;lt;T&amp;gt;&lt;&#x2F;code&gt;)&lt;&#x2F;td&gt;&lt;td&gt;None (&lt;code&gt;Option&amp;lt;T&amp;gt;&lt;&#x2F;code&gt;)&lt;&#x2F;td&gt;&lt;td&gt;Optional (&lt;code&gt;?T&lt;&#x2F;code&gt;)&lt;&#x2F;td&gt;&lt;td&gt;None (&lt;code&gt;Option[T]&lt;&#x2F;code&gt;)&lt;&#x2F;td&gt;&lt;td&gt;Yes (&lt;code&gt;nil&lt;&#x2F;code&gt;)&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;Exceptions&lt;&#x2F;td&gt;&lt;td&gt;None&lt;&#x2F;td&gt;&lt;td&gt;Panic (discouraged)&lt;&#x2F;td&gt;&lt;td&gt;None&lt;&#x2F;td&gt;&lt;td&gt;None&lt;&#x2F;td&gt;&lt;td&gt;Panic&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;Error handling&lt;&#x2F;td&gt;&lt;td&gt;&lt;code&gt;Result&lt;&#x2F;code&gt; + &lt;code&gt;?&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;&lt;code&gt;Result&lt;&#x2F;code&gt; + &lt;code&gt;?&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;Error unions&lt;&#x2F;td&gt;&lt;td&gt;&lt;code&gt;Result&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;Multiple returns&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;Lifetime annotations&lt;&#x2F;td&gt;&lt;td&gt;None (lexical regions)&lt;&#x2F;td&gt;&lt;td&gt;Yes&lt;&#x2F;td&gt;&lt;td&gt;None&lt;&#x2F;td&gt;&lt;td&gt;None&lt;&#x2F;td&gt;&lt;td&gt;N&#x2F;A (GC)&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;Formal verification&lt;&#x2F;td&gt;&lt;td&gt;Kernel in Lean&lt;&#x2F;td&gt;&lt;td&gt;External tools&lt;&#x2F;td&gt;&lt;td&gt;None&lt;&#x2F;td&gt;&lt;td&gt;None&lt;&#x2F;td&gt;&lt;td&gt;None&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;Defer&lt;&#x2F;td&gt;&lt;td&gt;Yes&lt;&#x2F;td&gt;&lt;td&gt;No (RAII)&lt;&#x2F;td&gt;&lt;td&gt;Yes&lt;&#x2F;td&gt;&lt;td&gt;No&lt;&#x2F;td&gt;&lt;td&gt;Yes&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;Interior mutability&lt;&#x2F;td&gt;&lt;td&gt;None&lt;&#x2F;td&gt;&lt;td&gt;&lt;code&gt;Cell&lt;&#x2F;code&gt;, &lt;code&gt;RefCell&lt;&#x2F;code&gt;, etc.&lt;&#x2F;td&gt;&lt;td&gt;Pointers&lt;&#x2F;td&gt;&lt;td&gt;None&lt;&#x2F;td&gt;&lt;td&gt;Pointers&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;Unsafe escape hatch&lt;&#x2F;td&gt;&lt;td&gt;&lt;code&gt;with(Unsafe)&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;&lt;code&gt;unsafe&lt;&#x2F;code&gt; blocks&lt;&#x2F;td&gt;&lt;td&gt;No safe&#x2F;unsafe distinction&lt;&#x2F;td&gt;&lt;td&gt;&lt;code&gt;Unsafe_Module&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;No distinction&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;Macros&lt;&#x2F;td&gt;&lt;td&gt;None (undecided)&lt;&#x2F;td&gt;&lt;td&gt;Procedural + declarative&lt;&#x2F;td&gt;&lt;td&gt;Comptime&lt;&#x2F;td&gt;&lt;td&gt;None&lt;&#x2F;td&gt;&lt;td&gt;None&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;Concurrency&lt;&#x2F;td&gt;&lt;td&gt;None (undecided)&lt;&#x2F;td&gt;&lt;td&gt;&lt;code&gt;async&lt;&#x2F;code&gt;, threads, channels&lt;&#x2F;td&gt;&lt;td&gt;Threads, async&lt;&#x2F;td&gt;&lt;td&gt;None&lt;&#x2F;td&gt;&lt;td&gt;Goroutines, channels&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;Formatter&lt;&#x2F;td&gt;&lt;td&gt;Ships with language&lt;&#x2F;td&gt;&lt;td&gt;rustfmt (separate)&lt;&#x2F;td&gt;&lt;td&gt;zig fmt&lt;&#x2F;td&gt;&lt;td&gt;None&lt;&#x2F;td&gt;&lt;td&gt;gofmt&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;Grammar&lt;&#x2F;td&gt;&lt;td&gt;LL(1)&lt;&#x2F;td&gt;&lt;td&gt;Complex&lt;&#x2F;td&gt;&lt;td&gt;Simple&lt;&#x2F;td&gt;&lt;td&gt;Simple&lt;&#x2F;td&gt;&lt;td&gt;LALR&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;&#x2F;tbody&gt;&lt;&#x2F;table&gt;
&lt;hr &#x2F;&gt;
&lt;h2 id=&quot;appendix-e-error-messages&quot;&gt;Appendix E: Error Messages&lt;&#x2F;h2&gt;
&lt;p&gt;These are representative error messages. The actual compiler may differ.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Linearity violation: value not consumed&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;pre class=&quot;z-code&quot;&gt;&lt;code&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;error[E0201]: linear value `f` is never consumed
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;  --&amp;gt; src&#x2F;main.concrete:4:9
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;   |
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt; 4 |     let f = open(&amp;quot;data.txt&amp;quot;)
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;   |         ^ this value has type `File` which is linear
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;   |
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;   = help: linear values must be consumed exactly once
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;   = help: add `defer destroy(f)` or pass `f` to a function that takes ownership
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;&lt;strong&gt;Linearity violation: value consumed twice&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;pre class=&quot;z-code&quot;&gt;&lt;code&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;error[E0202]: value `f` consumed twice
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;  --&amp;gt; src&#x2F;main.concrete:7:12
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;   |
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt; 5 |     let content = read_all(f)
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;   |                           - first consumption here
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt; 6 |     
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt; 7 |     destroy(f)
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;   |            ^ second consumption here
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;   |
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;   = help: after passing `f` to `read_all`, you no longer own it
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;&lt;strong&gt;Borrow escape&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;pre class=&quot;z-code&quot;&gt;&lt;code&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;error[E0301]: reference cannot escape its region
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;  --&amp;gt; src&#x2F;main.concrete:3:12
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;   |
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt; 2 |     borrow data as r in R {
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;   |                       --- region R starts here
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt; 3 |         return r
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;   |                ^ cannot return reference with region R
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt; 4 |     }
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;   |     - region R ends here
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;   |
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;   = help: references are only valid within their borrow region
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;&lt;strong&gt;Missing capability&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;pre class=&quot;z-code&quot;&gt;&lt;code&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;error[E0401]: function requires capability `Network` which is not available
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;  --&amp;gt; src&#x2F;main.concrete:8:5
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;   |
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt; 8 |     fetch(url)
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;   |     ^^^^^^^^^^ requires `Network`
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;   |
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;   = note: the current function has capabilities: {File, Alloc}
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;   = help: add `Network` to the function&amp;#39;s capability declaration:
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;   |
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt; 2 | fn process(url: String) with(File, Alloc, Network) -&amp;gt; Result&amp;lt;Data, Error&amp;gt;
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;   |                                    +++++++++
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;&lt;strong&gt;Capability leak through closure&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;pre class=&quot;z-code&quot;&gt;&lt;code&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;error[E0402]: closure captures capability `File` but escapes its scope
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;  --&amp;gt; src&#x2F;main.concrete:5:18
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;   |
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt; 5 |     let handler = fn() { read(&amp;amp;config_file) }
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;   |                   ^^^^ this closure requires `File`
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt; 6 |     return handler
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;   |            ------- closure escapes here
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;   |
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;   = help: closures that escape cannot capture capabilities
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;   = help: pass the file as a parameter instead
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;&lt;strong&gt;Mutable borrow conflict&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;pre class=&quot;z-code&quot;&gt;&lt;code&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;error[E0302]: cannot borrow `data` as immutable because it is already borrowed as mutable
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;  --&amp;gt; src&#x2F;main.concrete:4:17
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;   |
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt; 3 |     borrow mut data as m in R {
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;   |                       - mutable borrow occurs here
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt; 4 |         let len = length(&amp;amp;data)
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;   |                          ^^^^^ immutable borrow attempted here
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;   |
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;   = help: mutable borrows are exclusive; no other borrows allowed
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;&lt;strong&gt;Unsafe operation without capability&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;pre class=&quot;z-code&quot;&gt;&lt;code&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;error[E0501]: operation requires `Unsafe` capability
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;  --&amp;gt; src&#x2F;main.concrete:6:5
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;   |
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt; 6 |     ptr_read(addr)
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;   |     ^^^^^^^^^^^^^^ unsafe operation
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;   |
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;   = note: reading from raw pointers may cause undefined behavior
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;   = help: add `Unsafe` to the function&amp;#39;s capabilities:
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;   |
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt; 2 | fn dangerous(addr: Address[Int]) with(Unsafe) -&amp;gt; Int
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;   |                                  ++++++++++++
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;hr &#x2F;&gt;
&lt;h2 id=&quot;references&quot;&gt;References&lt;&#x2F;h2&gt;
&lt;h3 id=&quot;languages&quot;&gt;Languages&lt;&#x2F;h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;lean-lang.org&#x2F;&quot;&gt;Lean 4&lt;&#x2F;a&gt; — theorem prover and programming language&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;austral-lang.org&#x2F;&quot;&gt;Austral&lt;&#x2F;a&gt; — linear types and capabilities for systems programming
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;austral-lang.org&#x2F;spec&#x2F;spec.html&quot;&gt;Specification&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;www.rust-lang.org&#x2F;&quot;&gt;Rust&lt;&#x2F;a&gt; — ownership, borrowing, traits&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;ziglang.org&#x2F;&quot;&gt;Zig&lt;&#x2F;a&gt; — explicit allocators, defer, no hidden control flow&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;www.roc-lang.org&#x2F;&quot;&gt;Roc&lt;&#x2F;a&gt; — pure functional, &lt;code&gt;!&lt;&#x2F;code&gt; for effects&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;koka-lang.github.io&#x2F;koka&#x2F;doc&#x2F;index.html&quot;&gt;Koka&lt;&#x2F;a&gt; — algebraic effects and handlers&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;www.eff-lang.org&#x2F;&quot;&gt;Eff&lt;&#x2F;a&gt; — algebraic effects research language&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;frank-lang&#x2F;frank&quot;&gt;Frank&lt;&#x2F;a&gt; — effects as calling conventions&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;clean.cs.ru.nl&#x2F;&quot;&gt;Clean&lt;&#x2F;a&gt; — uniqueness types, pure by default&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;http:&#x2F;&#x2F;www.ats-lang.org&#x2F;&quot;&gt;ATS&lt;&#x2F;a&gt; — linear types with theorem proving&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;cyclone.thelanguage.org&#x2F;&quot;&gt;Cyclone&lt;&#x2F;a&gt; — region-based memory for C&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;www.adacore.com&#x2F;about-spark&quot;&gt;Ada&#x2F;SPARK&lt;&#x2F;a&gt; — formal verification in systems programming&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h3 id=&quot;verified-systems&quot;&gt;Verified Systems&lt;&#x2F;h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;compcert.org&#x2F;&quot;&gt;CompCert&lt;&#x2F;a&gt; — verified C compiler&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;sel4.systems&#x2F;&quot;&gt;seL4&lt;&#x2F;a&gt; — verified microkernel&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;flint.cs.yale.edu&#x2F;certikos&#x2F;&quot;&gt;CertiKOS&lt;&#x2F;a&gt; — verified concurrent OS kernel&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;iris-project.org&#x2F;&quot;&gt;Iris&lt;&#x2F;a&gt; — higher-order concurrent separation logic&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h3 id=&quot;papers&quot;&gt;Papers&lt;&#x2F;h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;homepages.inf.ed.ac.uk&#x2F;wadler&#x2F;papers&#x2F;linearlogic&#x2F;linearlogic.pdf&quot;&gt;Linear Logic&lt;&#x2F;a&gt; — Wadler&#x27;s introduction&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;www.cs.cmu.edu&#x2F;~fp&#x2F;courses&#x2F;15816-s12&#x2F;misc&#x2F;substructural.pdf&quot;&gt;Substructural Type Systems&lt;&#x2F;a&gt; — Walker&#x27;s survey&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;granule-project.github.io&#x2F;papers&#x2F;esop22-paper.pdf&quot;&gt;Linearity and Uniqueness: An Entente Cordiale&lt;&#x2F;a&gt; — linear vs unique vs affine&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;www.cs.umd.edu&#x2F;~mwh&#x2F;papers&#x2F;cyclone-safety.pdf&quot;&gt;Cyclone: A Safe Dialect of C&lt;&#x2F;a&gt; — region-based memory&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;www.microsoft.com&#x2F;en-us&#x2F;research&#x2F;wp-content&#x2F;uploads&#x2F;2016&#x2F;08&#x2F;algeff-tr-2016-v2.pdf&quot;&gt;Algebraic Effects for Functional Programming&lt;&#x2F;a&gt; — Leijen&#x27;s tutorial&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;www.eff-lang.org&#x2F;handlers-tutorial.pdf&quot;&gt;An Introduction to Algebraic Effects and Handlers&lt;&#x2F;a&gt; — Matija Pretnar&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;www.microsoft.com&#x2F;en-us&#x2F;research&#x2F;video&#x2F;typed-continuations-and-the-origin-of-algebraic-effects&#x2F;&quot;&gt;Typed Continuations and the Origin of Algebraic Effects&lt;&#x2F;a&gt; — Daan Leijen&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;srl.cs.jhu.edu&#x2F;pubs&#x2F;SRL2003-02.pdf&quot;&gt;Capability Myths Demolished&lt;&#x2F;a&gt; — what capabilities actually provide&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;www.cs.cmu.edu&#x2F;~crary&#x2F;819-f09&#x2F;Landin66.pdf&quot;&gt;The Next 700 Programming Languages&lt;&#x2F;a&gt; — Landin&#x27;s classic&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;www.cs.yale.edu&#x2F;flint&#x2F;cs428&#x2F;doc&#x2F;HintsPL.pdf&quot;&gt;Hints on Programming Language Design&lt;&#x2F;a&gt; — Tony Hoare&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;www.cs.virginia.edu&#x2F;~evans&#x2F;cs655&#x2F;readings&#x2F;steele.pdf&quot;&gt;Growing a Language&lt;&#x2F;a&gt; — Guy Steele&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;web.cecs.pdx.edu&#x2F;~mpj&#x2F;pubs&#x2F;polyrec.pdf&quot;&gt;A Polymorphic Type System for Extensible Records and Variants&lt;&#x2F;a&gt; — row polymorphism&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;plv.mpi-sws.org&#x2F;rustbelt&#x2F;popl18&#x2F;paper.pdf&quot;&gt;RustBelt: Securing the Foundations of the Rust Programming Language&lt;&#x2F;a&gt; — formal verification of Rust&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;plv.mpi-sws.org&#x2F;rustbelt&#x2F;stacked-borrows&#x2F;paper.pdf&quot;&gt;Stacked Borrows: An Aliasing Model for Rust&lt;&#x2F;a&gt; — Ralf Jung on aliasing&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;patpannuto.com&#x2F;pubs&#x2F;levy15ownership.pdf&quot;&gt;Ownership is Theft: Experiences Building an Embedded OS in Rust&lt;&#x2F;a&gt; — Tock OS&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;www.microsoft.com&#x2F;en-us&#x2F;research&#x2F;wp-content&#x2F;uploads&#x2F;2016&#x2F;07&#x2F;history.pdf&quot;&gt;A History of Haskell: Being Lazy with Class&lt;&#x2F;a&gt; — design decisions&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;www.cs.kent.ac.uk&#x2F;people&#x2F;staff&#x2F;dat&#x2F;miranda&#x2F;whyfp90.pdf&quot;&gt;Why Functional Programming Matters&lt;&#x2F;a&gt; — John Hughes&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;www.win.tue.nl&#x2F;~wstomv&#x2F;edu&#x2F;2ip30&#x2F;references&#x2F;criteria_for_modularization.pdf&quot;&gt;On the Criteria To Be Used in Decomposing Systems into Modules&lt;&#x2F;a&gt; — Parnas&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;clean.cs.ru.nl&#x2F;download&#x2F;doc&#x2F;CleanLangRep.3.0.pdf&quot;&gt;Clean Language Report&lt;&#x2F;a&gt; — uniqueness types specification&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;www.mbsd.cs.ru.nl&#x2F;publications&#x2F;papers&#x2F;2010&#x2F;deVries-Plasmeijer-uniqueness-simplified.pdf&quot;&gt;Uniqueness Typing Simplified&lt;&#x2F;a&gt; — how uniqueness types work&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;www.amazon.science&#x2F;publications&#x2F;using-lightweight-formal-methods-to-validate-a-key-value-storage-node-in-amazon-s3&quot;&gt;Using Lightweight Formal Methods to Validate a Key-Value Storage Node&lt;&#x2F;a&gt; — practical verification at AWS&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h3 id=&quot;blog-posts&quot;&gt;Blog Posts&lt;&#x2F;h3&gt;
&lt;p&gt;&lt;strong&gt;Language Design Philosophy&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;www.dreamsongs.com&#x2F;RiseOfWorseIsBetter.html&quot;&gt;Worse is Better&lt;&#x2F;a&gt; — Richard Gabriel on simplicity vs correctness&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;paulgraham.com&#x2F;hundred.html&quot;&gt;The Hundred-Year Language&lt;&#x2F;a&gt; — Paul Graham&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;blog.ploeh.dk&#x2F;2015&#x2F;04&#x2F;13&#x2F;less-is-more-language-features&#x2F;&quot;&gt;Less is more: language features&lt;&#x2F;a&gt; — Mark Seemann on constraints&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;curtclifton.net&#x2F;papers&#x2F;MosessonClifton06.pdf&quot;&gt;Out of the Tar Pit&lt;&#x2F;a&gt; — Moseley and Marks on complexity&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;www.cs.virginia.edu&#x2F;~evans&#x2F;cs655&#x2F;readings&#x2F;smalltalk.html&quot;&gt;Design Principles Behind Smalltalk&lt;&#x2F;a&gt; — Dan Ingalls&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;cdsmith.wordpress.com&#x2F;2011&#x2F;01&#x2F;09&#x2F;an-old-article-i-wrote&#x2F;&quot;&gt;What to Know Before Debating Type Systems&lt;&#x2F;a&gt; — Chris Smith&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;steve-yegge.blogspot.com&#x2F;2006&#x2F;03&#x2F;execution-in-kingdom-of-nouns.html&quot;&gt;Execution in the Kingdom of Nouns&lt;&#x2F;a&gt; — Steve Yegge&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;www.cs.virginia.edu&#x2F;~cs655&#x2F;readings&#x2F;bwk-on-pascal.html&quot;&gt;Why Pascal is Not My Favorite Language&lt;&#x2F;a&gt; — Kernighan&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;&lt;strong&gt;Austral and Linear Types&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;borretti.me&#x2F;article&#x2F;introducing-austral&quot;&gt;Introducing Austral&lt;&#x2F;a&gt; — Fernando Borretti&#x27;s rationale&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;borretti.me&#x2F;article&#x2F;how-australs-linear-type-checker-works&quot;&gt;How Austral&#x27;s Linear Type Checker Works&lt;&#x2F;a&gt; — implementation decisions&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;borretti.me&#x2F;article&#x2F;linear-types-and-capabilities&quot;&gt;Linear Types and Capabilities&lt;&#x2F;a&gt; — how they compose&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;borretti.me&#x2F;article&#x2F;type-systems-memory-safety&quot;&gt;Type Systems for Memory Safety&lt;&#x2F;a&gt; — survey of approaches&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;borretti.me&#x2F;article&#x2F;case-for-compiler-complexity&quot;&gt;The Case for Compiler Complexity&lt;&#x2F;a&gt; — why simple isn&#x27;t always better&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;homepages.inf.ed.ac.uk&#x2F;wadler&#x2F;topics&#x2F;linear-logic.html&quot;&gt;Linear types can change the world!&lt;&#x2F;a&gt; — Wadler&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;www.tweag.io&#x2F;blog&#x2F;2017-03-13-linear-types&#x2F;&quot;&gt;Retrofitting Linear Types&lt;&#x2F;a&gt; — adding linear types to Haskell&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;&lt;strong&gt;Rust Design Decisions&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;manishearth.github.io&#x2F;blog&#x2F;2015&#x2F;05&#x2F;17&#x2F;the-problem-with-shared-mutability&#x2F;&quot;&gt;The Problem with Single-threaded Shared Mutability&lt;&#x2F;a&gt; — why Rust forbids it&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;limpet.net&#x2F;mbrubeck&#x2F;2019&#x2F;02&#x2F;07&#x2F;rust-a-unique-perspective.html&quot;&gt;Rust: A unique perspective&lt;&#x2F;a&gt; — ownership from first principles&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;blog.rust-lang.org&#x2F;2018&#x2F;12&#x2F;06&#x2F;Rust-1.31-and-rust-2018.html#non-lexical-lifetimes&quot;&gt;Non-Lexical Lifetimes&lt;&#x2F;a&gt; — why Rust moved beyond lexical scopes&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;smallcultfollowing.com&#x2F;babysteps&#x2F;blog&#x2F;2018&#x2F;04&#x2F;27&#x2F;an-alias-based-formulation-of-the-borrow-checker&#x2F;&quot;&gt;Polonius: the future of the borrow checker&lt;&#x2F;a&gt; — Niko Matsakis&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;smallcultfollowing.com&#x2F;babysteps&#x2F;blog&#x2F;2018&#x2F;11&#x2F;10&#x2F;after-nll-moving-from-borrowed-data-and-the-sentinel-pattern&#x2F;&quot;&gt;After NLL: Moving from borrowed data&lt;&#x2F;a&gt; — borrow checker limitations&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;www.ralfj.de&#x2F;blog&#x2F;&quot;&gt;Ralf Jung&#x27;s Blog&lt;&#x2F;a&gt; — Stacked Borrows, unsafe, formal semantics&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;reberhardt.com&#x2F;blog&#x2F;2020&#x2F;10&#x2F;05&#x2F;why-rust.html&quot;&gt;Why Rust?&lt;&#x2F;a&gt; — Ryan Eberhardt&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;rust-unofficial.github.io&#x2F;too-many-lists&#x2F;&quot;&gt;Learn Rust With Entirely Too Many Linked Lists&lt;&#x2F;a&gt; — ownership through pain&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;nomicon&#x2F;&quot;&gt;The Rustonomicon&lt;&#x2F;a&gt; — dark arts of unsafe Rust&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;&lt;strong&gt;Graydon Hoare (Rust creator)&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;graydon2.dreamwidth.org&#x2F;307105.html&quot;&gt;The Rust I Wanted Had No Future&lt;&#x2F;a&gt; — original vision&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;graydon2.dreamwidth.org&#x2F;307291.html&quot;&gt;Not Rust&lt;&#x2F;a&gt; — what Rust deliberately avoided&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;graydon2.dreamwidth.org&#x2F;253769.html&quot;&gt;What next for compiled languages?&lt;&#x2F;a&gt; — language evolution&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;graydon2.dreamwidth.org&#x2F;249666.html&quot;&gt;Rust prehistory&lt;&#x2F;a&gt; — design origins&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;&lt;strong&gt;Zig Design Decisions&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;zig.news&#x2F;kristoff&#x2F;allocgate-finalizing-allocators-in-zig-3l99&quot;&gt;Allocgate&lt;&#x2F;a&gt; — why Zig&#x27;s allocator design changed&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;kristoff.it&#x2F;blog&#x2F;what-is-zigs-comptime&#x2F;&quot;&gt;What is Zig&#x27;s Comptime&lt;&#x2F;a&gt; — compile-time execution design&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;zig.news&#x2F;kristoff&#x2F;zigs-io-and-you-2c28&quot;&gt;Zig&#x27;s I&#x2F;O and You&lt;&#x2F;a&gt; — I&#x2F;O design&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;www.scattered-thoughts.net&#x2F;writing&#x2F;a-reply-to-zigs-creator-on-undefined-behavior&#x2F;&quot;&gt;A Reply to Zig&#x27;s Creator on Undefined Behavior&lt;&#x2F;a&gt; — Jamie Brandon&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;ziglang.org&#x2F;learn&#x2F;why_zig_over_c_cpp&#x2F;&quot;&gt;Why Zig When There&#x27;s Already Rust?&lt;&#x2F;a&gt; — official comparison&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;zig.news&#x2F;david_chisnall&#x2F;zig-vs-c-35eo&quot;&gt;Zig vs C++&lt;&#x2F;a&gt; — David Chisnall&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;&lt;strong&gt;Effects and Capabilities&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;overreacted.io&#x2F;algebraic-effects-for-the-rest-of-us&#x2F;&quot;&gt;Algebraic Effects for the Rest of Us&lt;&#x2F;a&gt; — Dan Abramov&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;journal.stuffwithstuff.com&#x2F;2015&#x2F;02&#x2F;01&#x2F;what-color-is-your-function&#x2F;&quot;&gt;What Color is Your Function?&lt;&#x2F;a&gt; — Bob Nystrom on effect tracking&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;vorpus.org&#x2F;blog&#x2F;notes-on-structured-concurrency-or-go-statement-considered-harmful&#x2F;&quot;&gt;Structured Concurrency&lt;&#x2F;a&gt; — Nathaniel Smith&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;www.eff-lang.org&#x2F;learn&#x2F;faq&#x2F;&quot;&gt;The Effect System FAQ&lt;&#x2F;a&gt; — Eff team&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;koka-lang.github.io&#x2F;koka&#x2F;doc&#x2F;book.html&quot;&gt;Koka: Programming with Row-polymorphic Effect Types&lt;&#x2F;a&gt; — official book&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;&lt;strong&gt;Roc and Purity&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;www.roc-lang.org&#x2F;design_goals.html&quot;&gt;Roc Design Philosophy&lt;&#x2F;a&gt; — official goals&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;www.roc-lang.org&#x2F;platforms&quot;&gt;Why Roc Uses Platform&#x2F;App Split&lt;&#x2F;a&gt; — effect isolation design&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;&lt;strong&gt;Go Design Decisions&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;go.dev&#x2F;talks&#x2F;2012&#x2F;splash.article&quot;&gt;Go at Google: Language Design in the Service of Software Engineering&lt;&#x2F;a&gt; — Rob Pike&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;go.dev&#x2F;talks&#x2F;2015&#x2F;simplicity-is-complicated.slide&quot;&gt;Simplicity is Complicated&lt;&#x2F;a&gt; — Rob Pike&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;go.dev&#x2F;blog&#x2F;errors-are-values&quot;&gt;Errors are values&lt;&#x2F;a&gt; — Rob Pike&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;go-proverbs.github.io&#x2F;&quot;&gt;Go Proverbs&lt;&#x2F;a&gt; — design philosophy&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;go.dev&#x2F;blog&#x2F;toward-go2&quot;&gt;Toward Go 2&lt;&#x2F;a&gt; — Russ Cox on language evolution&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;&lt;strong&gt;Memory and Allocators&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;www.rfleury.com&#x2F;p&#x2F;untangling-lifetimes-the-arena-allocator&quot;&gt;Untangling Lifetimes: The Arena Allocator&lt;&#x2F;a&gt; — Ryan Fleury&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;www.foonathan.net&#x2F;2022&#x2F;08&#x2F;malloc-overview&#x2F;&quot;&gt;What&#x27;s a Memory Allocator Anyway?&lt;&#x2F;a&gt; — Jonathan Müller&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;www.foonathan.net&#x2F;2022&#x2F;08&#x2F;malloc-interface&#x2F;&quot;&gt;malloc() and free() are a bad API&lt;&#x2F;a&gt; — Jonathan Müller&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;fitzgeraldnick.com&#x2F;2019&#x2F;11&#x2F;01&#x2F;always-bump-downwards.html&quot;&gt;Always Bump Downwards&lt;&#x2F;a&gt; — Nick Fitzgerald&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;www.gingerbill.org&#x2F;series&#x2F;memory-allocation-strategies&#x2F;&quot;&gt;Memory Allocation Strategies&lt;&#x2F;a&gt; — Bill Hall&#x27;s series&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;&lt;strong&gt;Error Handling Design&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;joeduffyblog.com&#x2F;2016&#x2F;02&#x2F;07&#x2F;the-error-model&#x2F;&quot;&gt;The Error Model&lt;&#x2F;a&gt; — Joe Duffy on Midori&#x27;s approach&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;sled.rs&#x2F;errors&quot;&gt;Error Handling in a Correctness-Critical Rust Project&lt;&#x2F;a&gt; — sled database&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;&lt;strong&gt;Formal Methods in Practice&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;www.hillelwayne.com&#x2F;post&#x2F;theorem-prover-showdown&#x2F;&quot;&gt;Proofs About Programs&lt;&#x2F;a&gt; — Hillel Wayne&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;brooker.co.za&#x2F;blog&#x2F;2022&#x2F;06&#x2F;02&#x2F;formal.html&quot;&gt;Formal Methods Only Solve Half My Problems&lt;&#x2F;a&gt; — Marc Brooker at AWS&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;cacm.acm.org&#x2F;magazines&#x2F;2015&#x2F;4&#x2F;184701-how-amazon-web-services-uses-formal-methods&#x2F;fulltext&quot;&gt;How AWS Uses Formal Methods&lt;&#x2F;a&gt; — Communications of the ACM&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;www.hillelwayne.com&#x2F;post&#x2F;where-the-bugs-are&#x2F;&quot;&gt;Where the Bugs Are&lt;&#x2F;a&gt; — where verification helps&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;www.hillelwayne.com&#x2F;post&#x2F;using-tla-in-the-real-world&#x2F;&quot;&gt;Using TLA+ in the Real World&lt;&#x2F;a&gt; — Hillel Wayne&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;web.stanford.edu&#x2F;~engler&#x2F;ASPLOS24-dave.pdf&quot;&gt;Verification at Scale&lt;&#x2F;a&gt; — how to verify real systems&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;blog.brownplt.org&#x2F;2024&#x2F;01&#x2F;04&#x2F;compile-your-proofs.html&quot;&gt;You Should Compile Your Proofs&lt;&#x2F;a&gt; — on proof engineering&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;&lt;strong&gt;Lean 4&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;lean-lang.org&#x2F;functional_programming_in_lean&#x2F;&quot;&gt;Functional Programming in Lean&lt;&#x2F;a&gt; — official book&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;lean-lang.org&#x2F;theorem_proving_in_lean4&#x2F;&quot;&gt;Theorem Proving in Lean 4&lt;&#x2F;a&gt; — official book&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;leanprover-community&#x2F;lean4-metaprogramming-book&quot;&gt;Metaprogramming in Lean 4&lt;&#x2F;a&gt; — macros and tactics&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;&lt;strong&gt;Type System Design&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;lexi-lambda.github.io&#x2F;blog&#x2F;2019&#x2F;11&#x2F;05&#x2F;parse-don-t-validate&#x2F;&quot;&gt;Parse, Don&#x27;t Validate&lt;&#x2F;a&gt; — Alexis King&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;lexi-lambda.github.io&#x2F;blog&#x2F;2020&#x2F;11&#x2F;01&#x2F;names-are-not-type-safety&#x2F;&quot;&gt;Names Are Not Type Safety&lt;&#x2F;a&gt; — Alexis King&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;lexi-lambda.github.io&#x2F;blog&#x2F;2020&#x2F;08&#x2F;13&#x2F;types-as-axioms-or-playing-with-fire&#x2F;&quot;&gt;Types as Axioms&lt;&#x2F;a&gt; — Alexis King&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;http:&#x2F;&#x2F;homepages.inf.ed.ac.uk&#x2F;wadler&#x2F;papers&#x2F;expression&#x2F;expression.txt&quot;&gt;The Expression Problem&lt;&#x2F;a&gt; — Philip Wadler&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;&lt;strong&gt;Bob Harper&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;existentialtype.wordpress.com&#x2F;2011&#x2F;03&#x2F;19&#x2F;what-if-anything-is-a-programming-paradigm&#x2F;&quot;&gt;What, if anything, is a programming paradigm?&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;existentialtype.wordpress.com&#x2F;2011&#x2F;03&#x2F;19&#x2F;dynamic-languages-are-static-languages&#x2F;&quot;&gt;Dynamic languages are static languages&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;existentialtype.wordpress.com&#x2F;2011&#x2F;04&#x2F;16&#x2F;modules-matter-most&#x2F;&quot;&gt;Modules matter most&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h3 id=&quot;talks&quot;&gt;Talks&lt;&#x2F;h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=0jI-AlWEwYI&quot;&gt;Effects for Less&lt;&#x2F;a&gt; — Alexis King on effects (essential)&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=Unq712gqu2U&quot;&gt;The Road to Zig 1.0&lt;&#x2F;a&gt; — Andrew Kelley&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=HgtRAbE1nBM&quot;&gt;Is It Time to Rewrite the OS in Rust?&lt;&#x2F;a&gt; — Bryan Cantrill&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=IOiZatlZtGU&quot;&gt;Propositions as Types&lt;&#x2F;a&gt; — Philip Wadler&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=nV3r1rB5_6E&quot;&gt;Correctness by Construction&lt;&#x2F;a&gt; — Derek Dreyer on RustBelt&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;www.infoq.com&#x2F;presentations&#x2F;Simple-Made-Easy&#x2F;&quot;&gt;Simple Made Easy&lt;&#x2F;a&gt; — Rich Hickey&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=GqmsQeSzMdw&quot;&gt;Constraints Liberate, Liberties Constrain&lt;&#x2F;a&gt; — Runar Bjarnason&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=_ahvzDzKdB0&quot;&gt;Growing a Language&lt;&#x2F;a&gt; — Guy Steele (watch this)&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=7GcrT0SBSnI&quot;&gt;Why Algebraic Effects Matter&lt;&#x2F;a&gt; — Daan Leijen&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=vzfy4EKwG_Y&quot;&gt;Outperforming Imperative with Pure Functional Languages&lt;&#x2F;a&gt; — Richard Feldman&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=cpQwtwVKAfU&quot;&gt;Why Roc?&lt;&#x2F;a&gt; — Richard Feldman&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=pW-SOdj4Kkk&quot;&gt;Preventing the Collapse of Civilization&lt;&#x2F;a&gt; — Jonathan Blow on why new languages matter&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=TH9VCN6UkyQ&quot;&gt;Ideas about a new programming language for games&lt;&#x2F;a&gt; — Jonathan Blow on Jai&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=t0mhvd3-60Y&quot;&gt;Linear Types for Low-latency, High-throughput Systems&lt;&#x2F;a&gt; — Jean-Philippe Bernardy&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=Sj3b8Sltx1s&quot;&gt;seL4 and Formal Verification&lt;&#x2F;a&gt; — Gernot Heiser&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h3 id=&quot;books&quot;&gt;Books&lt;&#x2F;h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;www.cis.upenn.edu&#x2F;~bcpierce&#x2F;tapl&#x2F;&quot;&gt;Types and Programming Languages&lt;&#x2F;a&gt; — Pierce&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;www.cs.cmu.edu&#x2F;~rwh&#x2F;pfpl&#x2F;&quot;&gt;Practical Foundations for Programming Languages&lt;&#x2F;a&gt; — Harper&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;http:&#x2F;&#x2F;adam.chlipala.net&#x2F;cpdt&#x2F;&quot;&gt;Certified Programming with Dependent Types&lt;&#x2F;a&gt; — Chlipala&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;softwarefoundations.cis.upenn.edu&#x2F;&quot;&gt;Software Foundations&lt;&#x2F;a&gt; — interactive Coq textbook&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;plfa.github.io&#x2F;&quot;&gt;Programming Language Foundations in Agda&lt;&#x2F;a&gt; — Wadler and Kokke&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;mitpress.mit.edu&#x2F;9780262536431&#x2F;the-little-typer&#x2F;&quot;&gt;The Little Typer&lt;&#x2F;a&gt; — Friedman and Christiansen&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;craftinginterpreters.com&#x2F;&quot;&gt;Crafting Interpreters&lt;&#x2F;a&gt; — Bob Nystrom&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
</content>
        
    </entry>
    <entry xml:lang="en">
        <title>The Death of the Inner Self</title>
        <published>2025-12-23T00:00:00+00:00</published>
        <updated>2025-12-23T00:00:00+00:00</updated>
        
        <author>
          <name>
            
              Unknown
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://federicocarrone.com/articles/the-death-of-the-inner-self/"/>
        <id>https://federicocarrone.com/articles/the-death-of-the-inner-self/</id>
        
        <content type="html" xml:base="https://federicocarrone.com/articles/the-death-of-the-inner-self/">&lt;p&gt;I am working on a series of articles that connect biology, computation, philosophy, the history of the West and the formation of individuality. The core argument is simple: many features of human life that appear stable and natural are historically produced. As society accelerates a number of these features begin to lose their function and their permanence. This is just a draft of what I&#x27;m working on.&lt;&#x2F;p&gt;
&lt;p&gt;Life is organized around information that replicates under constraint. Computation generalizes this biological logic. It allows selection and optimization to occur faster and at larger scales by externalizing memory comparison and feedback. Problems that once required internal deliberation can be solved through external processes that test filter and iterate possibilities. Capital pushes this logic further. It reorganizes social life around continuous feedback price signals and competitive selection. As these forces compound individuality starts to look less like a foundation and more like an interface that emerged to solve earlier coordination problems. Capital behaves as an impersonal intelligence oriented toward speed abstraction and self optimization. As cognition decision making and coordination migrate into automated systems the inner self loses its structural role.&lt;&#x2F;p&gt;
&lt;p&gt;Over time many assumptions we take for granted are worn down by this acceleration. Individuality and consciousness appear increasingly exposed to this process.&lt;&#x2F;p&gt;
&lt;p&gt;The death of the inner self and individuality&lt;&#x2F;p&gt;
&lt;p&gt;Fish do not realize they live in water. The medium that sustains them is so constant that it disappears from perception. Some of the most important structures are overlooked for the same reason. Individuality and consciousness belong to that category.&lt;&#x2F;p&gt;
&lt;p&gt;We tend to treat individuality and consciousness as self evident facts. As if humans have always experienced themselves as bounded selves with an inner voice a private mental space and a continuous narrative identity. Because this experience feels natural it is assumed to be timeless. However for most of human history people did not describe themselves as individuals in the modern sense. Decisions were not understood as outcomes of inner deliberation and agency was not located inside a private interior self. Action was organized through rituals traditions, kinship and prescribed roles. Meaning arrived from outside the person rather than from introspection. In many societies outside the Western trajectory this structure remains largely intact.&lt;&#x2F;p&gt;
&lt;p&gt;The idea of a you inside your head observing your own thoughts is therefore a learned construction. It depends on language habits metaphors and social practices that had to be developed and stabilized over time. Inner speech narrative memory moral self examination and the sense of authorship over action emerged as cultural achievements layered on top of older biological processes.&lt;&#x2F;p&gt;
&lt;p&gt;Modern societies actively reproduce this configuration. From early childhood people are trained to understand themselves as autonomous units with opinions preferences goals and an inner life that belongs only to them. The training is so pervasive that it becomes invisible. Other ways of being human recede from view even though many have existed and some still persist.&lt;&#x2F;p&gt;
&lt;p&gt;The conditions that once made individuality functional are weakening. Earlier systems relied on human subjects to think decide judge and take responsibility. Cognition and coordination were constrained by human minds. Individuality emerged as a solution. A stable self enabled long term planning moral accounting and institutional continuity.&lt;&#x2F;p&gt;
&lt;p&gt;Earlier societies coordinated without modern consciousness. Contemporary systems increasingly coordinate without modern selves. Decision making proceeds without inner deliberation. Meaning is delivered through incentives metrics and feedback loops. At the cultural level individuality remains constantly invoked. People are urged to be themselves express themselves optimize themselves. Yet the channels for expression arrive pre shaped quantified and monetized. What appears as selfhood increasingly takes the form of managed performance within narrow bounds.&lt;&#x2F;p&gt;
&lt;p&gt;The modern self once felt inevitable because it solved concrete problems. It enabled abstraction continuity and responsibility at scale. Its future usefulness is far less certain.&lt;&#x2F;p&gt;
</content>
        
    </entry>
    <entry xml:lang="en">
        <title>Notes on permanence, time, and ergodicity</title>
        <published>2025-12-15T00:00:00+00:00</published>
        <updated>2025-12-15T00:00:00+00:00</updated>
        
        <author>
          <name>
            
              Unknown
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://federicocarrone.com/articles/notes-on-culture-infrastructure-time-and-ergodicity/"/>
        <id>https://federicocarrone.com/articles/notes-on-culture-infrastructure-time-and-ergodicity/</id>
        
        <content type="html" xml:base="https://federicocarrone.com/articles/notes-on-culture-infrastructure-time-and-ergodicity/">&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;ergodicgroup.com&#x2F;&quot;&gt;Ergodic Group&lt;&#x2F;a&gt; is organized around the observation that certain systems change character through sustained engagement. In these systems, repetition refines execution, experience carries forward, and accumulated judgment reshapes future outcomes. Time is not neutral. It filters error, stabilizes standards, and reveals structural quality. Systems differ less in what they produce than in how they behave under repeated contact with reality.&lt;&#x2F;p&gt;
&lt;p&gt;Contemporary society is accelerating across technical, cultural, and organizational dimensions. Cycles shorten, signals multiply, and coordination occurs under constant pressure to respond. This acceleration compounds itself, tightening feedback loops and compressing decision horizons. As pace increases, many structures continue operating while gradually shedding accumulated judgment and internal coherence. Activity persists while formation weakens. Systems appear functional even as their capacity to learn erodes.&lt;&#x2F;p&gt;
&lt;p&gt;Acceleration also alters the shape of error and transmission. As pace increases, decisions become harder to reverse while feedback quality declines. Irreversibility moves upstream. Early mistakes remain cheap only briefly, after which correction costs rise sharply. At the same time, what spreads fastest diverges from what works best. Forms that replicate quickly outperform those that behave correctly under repetition. Compression, legibility, and ease of copying dominate transmission while durability becomes harder to observe. Imitation spreads faster than learning. What circulates most widely is rarely what compounds judgment over time.&lt;&#x2F;p&gt;
&lt;p&gt;Acceleration operates as a selection mechanism at two levels. At the level of individual systems, time reveals whether repetition compounds judgment or merely increases exposure. At the level of entire sectors, time reveals which categories can sustain formation under continuous acceleration. Most cannot. Sectors that depend on local advantage, fragile differentiation, or temporary coordination tend to fragment, commoditize, or disappear rather than evolve.&lt;&#x2F;p&gt;
&lt;p&gt;Acceleration often produces less transformation than it promises. Tools change rapidly while underlying constraints remain intact. Activity increases even as structural novelty diminishes. What presents itself as innovation is often the rapid circulation of forms rather than a reconfiguration of fundamentals.&lt;&#x2F;p&gt;
&lt;p&gt;Under these conditions, endurance becomes informative. Systems that continue to behave correctly across long spans of stress and variation reveal alignment between structure, incentives, and reality. Continued correctness functions as a diagnostic signal. Duration matters because few systems remain exposed long enough for time to test them. What matters is how behavior evolves under repetition.&lt;&#x2F;p&gt;
&lt;p&gt;The internet did not dissolve coherence. It revealed texture that homogeneity had previously concealed. What once appeared uniform now resolves into distinct patterns of intention, execution, and quality. As distribution becomes universal, distinction reemerges through fidelity rather than availability. Abundance exposes superficiality. Depth becomes legible through sustained correctness rather than momentary visibility.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;two-forms-of-time&quot;&gt;Two forms of time&lt;&#x2F;h2&gt;
&lt;p&gt;Time operates in human systems in two fundamentally different ways.&lt;&#x2F;p&gt;
&lt;p&gt;Measured time is divisible and uniform. It is organized into intervals and governs schedules, deadlines, accounting periods, and discounting. It can be allocated, optimized, compressed, and exchanged. Planning systems and evaluation frameworks operate within measured time, assuming that value can be assessed independently of history.&lt;&#x2F;p&gt;
&lt;p&gt;Lived time is accumulative and qualitative. It is shaped by what occurs within it. Learning, memory, and judgment develop through lived time. Each cycle alters what follows. Later moments differ in kind from earlier ones because experience reshapes perception, attention, and capacity.&lt;&#x2F;p&gt;
&lt;p&gt;Processes that depend on formation operate in lived time. Each cycle changes the character of subsequent cycles. Experience accumulates rather than repeating identically. What is learned reshapes what becomes possible. These processes cannot be evaluated correctly through snapshots because their value emerges through accumulation rather than momentary performance.&lt;&#x2F;p&gt;
&lt;p&gt;Systems organized entirely around measured time assume that intervals are interchangeable. This assumption holds only where repetition does not change outcomes and exposure does not reshape capability.&lt;&#x2F;p&gt;
&lt;p&gt;When lived time is forced into measured time, formation fails. Standards cannot stabilize. Judgment cannot compound. The information produced by evaluation becomes distorted because it ignores history.&lt;&#x2F;p&gt;
&lt;p&gt;Time reveals what a system actually is. Structure becomes legible through sustained activity. What appears coherent early may fail under variation, load, or shifting incentives. What endures across repeated contact with reality discloses properties that cannot be inferred in advance. Continued correctness produces evidence rather than claims.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;formation-under-constraint&quot;&gt;Formation under constraint&lt;&#x2F;h2&gt;
&lt;p&gt;Excellence emerges from sustained practice under appropriate constraints. Athletic, artistic, intellectual, and technical achievement follow this pattern. Initial talent offers limited advantage relative to disciplined engagement over extended periods of formation.&lt;&#x2F;p&gt;
&lt;p&gt;Practice systems depend on complete cycles of effort, feedback, and adjustment. When these cycles are interrupted or prematurely evaluated, formation stalls. Learning fragments. Standards decay.&lt;&#x2F;p&gt;
&lt;p&gt;Errors must remain survivable for learning to occur. Adjustment must be possible without each iteration becoming terminal. Judgment improves only when experience accumulates across attempts rather than being truncated by constant resetting.&lt;&#x2F;p&gt;
&lt;p&gt;When systems optimize for immediate measurement, necessary errors are avoided rather than integrated. Practices converge toward forms that appear legible early yet fail under prolonged stress. The effort required to maintain genuine standards becomes unsustainable under continuous pressure for immediate results.&lt;&#x2F;p&gt;
&lt;p&gt;Capital structures that impose fixed evaluation windows reinforce this dynamic. When outcomes must be made legible on predetermined schedules, decisions orient toward transferability rather than structural soundness. Systems develop according to measurement regimes rather than their own requirements for formation. Failure is deferred and rendered less visible.&lt;&#x2F;p&gt;
&lt;p&gt;Practices generate two kinds of value. External value appears outside the practice through money, status, and recognition. Internal value emerges only through the practice itself, through excellence inseparable from the process that produced it.&lt;&#x2F;p&gt;
&lt;p&gt;When structures privilege rapid extraction of external value, internal value formation is displaced. Standards that require time to stabilize are abandoned in favor of standards that generate immediate signals. What the practice uniquely develops is replaced by what can be transferred quickly.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;four-domains&quot;&gt;Four domains&lt;&#x2F;h2&gt;
&lt;p&gt;The work of Ergodic Group unfolds across four interdependent domains: mathematics, code, culture, and craft. These domains describe a group level system through which abstract structure becomes operative reality and through which reality reshapes future abstraction. Individual companies typically operate primarily within one domain. Advantage emerges through connection rather than internal completeness.&lt;&#x2F;p&gt;
&lt;p&gt;Mathematics establishes structure and constraint. It defines relationships that remain valid as complexity increases. Mathematical coherence preserves alignment under transformation. A formula outlives its creator, becoming compressed truth that compounds through reuse.&lt;&#x2F;p&gt;
&lt;p&gt;Code translates structure into execution. It transforms logic into process, protocol, and system. Code brings abstraction into contact with reality through systems that must operate under stress. Over time, clarity and precision determine whether systems converge toward reliability or degrade under pressure.&lt;&#x2F;p&gt;
&lt;p&gt;Culture coordinates meaning across time and participation. It encodes standards and shared understanding that allow intent to persist as participants change. Culture resists flattening under acceleration by preserving depth, taste, and judgment.&lt;&#x2F;p&gt;
&lt;p&gt;Craft grounds abstraction through execution. It expresses standards in material reality, where precision and care impose irreversible costs. Materials resist. Execution reveals flaws. Craft encodes time, place, and skill into forms that can be shared.&lt;&#x2F;p&gt;
&lt;p&gt;These domains form a continuous loop across the group. Insight emerges from confronting execution with constraint. Standards stabilize through repetition. Precision advances through accumulated understanding. Learning compounds only when domains remain connected.&lt;&#x2F;p&gt;
&lt;p&gt;What persists across time does so through specific mechanisms: algorithmic logic that can be re-implemented, textual knowledge that can be recopied, cultural practices that can be retransmitted, material techniques that can be relearned. These domains describe how structure, meaning, and capability transfer across generations when connected rather than isolated.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;ergodicity-as-a-filter&quot;&gt;Ergodicity as a filter&lt;&#x2F;h2&gt;
&lt;p&gt;Ergodicity describes when repetition improves typical outcomes. In ergodic processes, learning transfers, experience accumulates, and later decisions benefit from earlier cycles. Competence compounds.&lt;&#x2F;p&gt;
&lt;p&gt;Where repetition strengthens judgment, time improves performance. Where outcomes fail to converge, time increases exposure without increasing capability. Ergodicity functions as a selection filter, indicating whether a system benefits from continued operation or is gradually revealed as fragile.&lt;&#x2F;p&gt;
&lt;p&gt;Under accelerating conditions, this filter concentrates value. Many sectors fragment and disappear as coordination costs rise and memory collapses. What remains are systems that preserve coherence under exposure.&lt;&#x2F;p&gt;
&lt;p&gt;Infrastructure and culture persist under this pressure because they function as environments rather than sectors. Infrastructure coordinates action through rules and constraints that must hold under stress. Each correct operation adds evidence of reliability. Culture coordinates meaning through sustained production. Standards accumulate. Direction persists.&lt;&#x2F;p&gt;
&lt;p&gt;Both absorb volatility and convert continuity into capability. Operational history becomes evidence. Coherence becomes legible. Time becomes an asset where learning transfers. They persist because they institutionalize maintenance rather than novelty, embedding accumulated judgment into structure and practice even when maintenance remains invisible to the market.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;operation&quot;&gt;Operation&lt;&#x2F;h2&gt;
&lt;p&gt;Ergodic Group is organized around this understanding. Time is treated as an information process. Companies are built or acquired primarily within one domain. Advantage is created by connecting them so that learning, standards, and constraints transfer across domains rather than remaining isolated.&lt;&#x2F;p&gt;
&lt;p&gt;This understanding shapes operation. Loop integrity is maintained across transitions. Formation is allowed to occur in lived time rather than being forced into measured time. Attention concentrates on domains where repetition produces compounding advantage and where connection strengthens performance.&lt;&#x2F;p&gt;
&lt;p&gt;Those domains win with time.&lt;&#x2F;p&gt;
</content>
        
    </entry>
    <entry xml:lang="en">
        <title>The new financial backend of the world</title>
        <published>2025-12-09T00:00:00+00:00</published>
        <updated>2025-12-09T00:00:00+00:00</updated>
        
        <author>
          <name>
            
              Unknown
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://federicocarrone.com/series/ethereum/the-new-financial-backend-of-the-world/"/>
        <id>https://federicocarrone.com/series/ethereum/the-new-financial-backend-of-the-world/</id>
        
        <content type="html" xml:base="https://federicocarrone.com/series/ethereum/the-new-financial-backend-of-the-world/">&lt;p&gt;&lt;strong&gt;By Federico Carrone and Roberto Catalan&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Ethereum is emerging as a general purpose financial backend that reduces the cost and complexity of building financial services while improving their speed and security. For decades the internet accelerated communication but did not create a neutral system for defining ownership or enforcing obligations. Economic activity moved online without the accompanying machinery of rights, records, and jurisdiction. Ethereum fills this gap by embedding these functions in software and enforcing them through a distributed validator set.&lt;&#x2F;p&gt;
&lt;p&gt;Markets depend on property rights, and property rights depend on reliable systems for recording ownership, supporting transfer, and enforcing obligations. Prices then communicate scarcity and preference, enabling coordination at scale. Technological progress has repeatedly lowered the cost of transmitting information and synchronizing action. Ethereum extends this pattern by lowering the cost of establishing and verifying ownership across borders.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;from-internet-native-to-global-infrastructure&quot;&gt;From internet native to global infrastructure&lt;&#x2F;h2&gt;
&lt;p&gt;Ethereum’s early innovation was the introduction of programmable digital assets with defined economic properties. Issuers could establish monetary rules, engineer scarcity, and integrate assets into applications. Before Ethereum, such experimentation required constructing a  network and persuading others to secure it, a process limited to technically sophisticated groups. Ethereum replaced infrastructure duplication with shared security and a general purpose environment, turning issuance from a capital intensive undertaking into a software driven activity.&lt;&#x2F;p&gt;
&lt;p&gt;The more consequential development has been the recognition that Ethereum can reconstruct traditional financial services in a form that is more transparent and less operationally burdensome. Financial institutions devote substantial resources to authorization, accounting, monitoring, dispute resolution, and reporting. Consumer interfaces sit atop complex internal systems designed to prevent error and misconduct. Ethereum substitutes a portion of this apparatus with a shared ledger, a programmable execution environment, and cryptographic enforcement. Administrative complexity is reduced because core functions are delegated to software rather than replicated within each institution.&lt;&#x2F;p&gt;
&lt;p&gt;Ethereum reduces that burden by providing a shared ledger with real time updates, a programmable space for defining rules, and cryptographic enforcement. It does not remove institutions but changes which parts of the financial stack they must build themselves. Issuance becomes simpler, custody more secure, and administration less dependent on proprietary infrastructure.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;software-trust-and-the-reduction-of-friction&quot;&gt;Software, trust and the reduction of friction&lt;&#x2F;h2&gt;
&lt;p&gt;Some economists describe transaction costs through three frictions: triangulation, transfer and trust. Triangulation concerns how economic actors identify each other and agree on terms. Transfer concerns how value moves between them. Trust concerns the enforcement of obligations. Traditional financial architecture manages these frictions through scale, proprietary systems, and coordination among intermediaries.&lt;&#x2F;p&gt;
&lt;p&gt;Ethereum remove middlemen and therefore lowers the three frictions enumerated before. Open marketplaces support discovery of assets and prices. Digital value can settle globally within minutes without the layers of correspondent banking. Obligations can be executed automatically and verified publicly. These capabilities do not eliminate institutional functions but shift part of the work from organizations to software, reducing cost and operational risk.&lt;&#x2F;p&gt;
&lt;p&gt;New entrants benefit immediately. They can rely on infrastructure maintained by thousands of engineers rather than building their own systems for settlement, custody, and enforcement. Business logic becomes code. Obligations can be automated. Settlement becomes immediate. Users retain custody. This expands the range of viable business models and allows firms to serve markets that incumbents consider too small or too complex.&lt;&#x2F;p&gt;
&lt;p&gt;Having a single global ledger also changes operational dynamics. Many institutions operate multiple databases that require frequent reconciliation and remain vulnerable to error. Ethereum maintains a continuously updated and replicated record that cannot be amended retroactively. Redundancy and recoverability become default properties rather than costly internal functions.&lt;&#x2F;p&gt;
&lt;p&gt;Security follows the same pattern. Instead of defending a central database, Ethereum distributes verification among many independent actors. Altering history requires coordination at scale and becomes prohibitively expensive. Confidence arises from system design rather than institutional promises.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;new-financial-services-and-global-reach&quot;&gt;New financial services and global reach&lt;&#x2F;h2&gt;
&lt;p&gt;These features enable services that resemble established financial activities but operate with different cost structures. International transfers can use digital dollars rather than correspondent networks. Loans can enforce collateral rules in code. Local payment systems can interoperate without proprietary standards. Individuals in unstable economies can store value in digital instruments independent of local monetary fragility.&lt;&#x2F;p&gt;
&lt;p&gt;Clearing, custody, reconciliation, monitoring, and enforcement shift from organizational processes into shared software. Companies can focus on product design and distribution rather than maintaining complex internal infrastructure. Scale is achieved by acquiring users, because infrastructure is shared. Value accrues to applications rather than to duplicated internal systems.&lt;&#x2F;p&gt;
&lt;p&gt;The impact is most visible in markets with fragile financial systems. In economies with unstable currencies or slow payment networks, Ethereum provides immediate functional gains. In developed markets the benefits appear incremental but accumulate as more instruments and processes become programmable.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;institutional-transformation-and-long-term-dynamics&quot;&gt;Institutional transformation and long term dynamics&lt;&#x2F;h2&gt;
&lt;p&gt;Many financial instruments are heterogeneous. Corporate debt is a clear example. Terms differ by maturity, coupon, covenants, collateral, and risk. Trading depends on bilateral negotiation and intermediaries who maintain records and enforce obligations. Ethereum can represent these instruments digitally, track ownership, and execute terms automatically. Contracts retain their specificity, while administration becomes standardized and interoperable.&lt;&#x2F;p&gt;
&lt;p&gt;This suggests a shift in institutional architecture. Regulation and legal systems remain central, but the boundary between what firms must build and what software can enforce changes. Institutions evolve from infrastructure providers to service designers. Cost structures diverge between firms that maintain legacy systems and those that rely on shared infrastructure.&lt;&#x2F;p&gt;
&lt;p&gt;Ethereum already functions as an alternative financial rail. Its reliability, the presence of multiple independently developed clients, substantial real world usage, active research community, and commitment to openness and verification distinguish it from other blockchain networks. These qualities align with the requirements of durable financial infrastructure.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;&#x2F;h2&gt;
&lt;p&gt;Ethereum converts core financial frictions into software functions. This changes the economics of building and operating financial services. Talent and capital shift from operations to innovation in product design. Institutions become lighter and more focused. Those who will adopt Ethereum will have lower costs of operation and will have a head start against competitors.&lt;&#x2F;p&gt;
&lt;p&gt;Technological transitions begin in niches where incumbents do not meet demand. As systems mature, costs fall and broader adoption becomes feasible. Ethereum followed this path. It began with internet native communities, expanded across emerging markets where users lacked reliable financial tools, and is now positioned to upgrade mainstream markets by making financial companies easier to create and operate.&lt;&#x2F;p&gt;
&lt;p&gt;The broader implication is that software is becoming the organizing principle of financial infrastructure. Ethereum makes this shift concrete. Whether it becomes foundational will depend on regulation and institutional adaptation, but the economic incentives are increasingly aligned with systems that are open, verifiable, and resilient.&lt;&#x2F;p&gt;
</content>
        
    </entry>
    <entry xml:lang="en">
        <title>The missing institution of the Internet</title>
        <published>2025-12-02T00:00:00+00:00</published>
        <updated>2025-12-02T00:00:00+00:00</updated>
        
        <author>
          <name>
            
              Unknown
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://federicocarrone.com/series/ethereum/the-missing-institution-of-the-internet/"/>
        <id>https://federicocarrone.com/series/ethereum/the-missing-institution-of-the-internet/</id>
        
        <content type="html" xml:base="https://federicocarrone.com/series/ethereum/the-missing-institution-of-the-internet/">&lt;p&gt;&lt;strong&gt;By Federico Carrone and Roberto Catalan&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Modern economic systems rest on two foundations: tools that expand productive capacity and institutions that define who controls their output. The internet transformed how information moves, but it did not reconstruct the institutional machinery that governs ownership and exchange. Digital economic life therefore expanded without a durable system of rights, enforcement, or jurisdiction. Blockchain networks, and Ethereum in particular, address this gap by embedding institutional functions in software and enforcing them through economic incentives and cryptographic verification.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;technology-culture-and-institutional-design&quot;&gt;Technology, Culture and Institutional Design&lt;&#x2F;h2&gt;
&lt;p&gt;In most species, behavior is shaped by biology and fixed through genetic inheritance. Humans diverged by inventing technologies that alter their environment more rapidly than biological evolution can adapt to it. Fire, agriculture, medicine and computing enabled a physically vulnerable species to extend its productive frontiers.&lt;&#x2F;p&gt;
&lt;p&gt;Equally significant was the emergence of institutions that facilitated cooperation beyond small groups. Human societies are organized not through inherited instinct but through constructed systems of norms, laws and symbolic abstractions that can be revised in response to changing conditions. Cultural evolution permits continuous redesign and operates on a faster timescale than genetic change.&lt;&#x2F;p&gt;
&lt;p&gt;This dual process, technological augmentation and institutional invention, generated compounding effects. Tools expanded individual capacity and institutions aggregated that capacity into collective action. Property rights, contracts, markets and corporate entities emerged as mechanisms to coordinate behavior at scale by defining entitlements and aligning incentives.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;property-rights-and-markets-as-social-technologies&quot;&gt;Property Rights and Markets as Social Technologies&lt;&#x2F;h2&gt;
&lt;p&gt;Economic development depends not only on productive capability but on credible commitments. Individuals and firms invest when they can expect to benefit from their efforts and be protected from arbitrary interference. Property rights provide that assurance by specifying ownership, use and exclusion. Markets, layered on top of these rights, coordinate production and exchange by allocating resources through price signals.&lt;&#x2F;p&gt;
&lt;p&gt;These arrangements are often treated as natural features of economic life. They are engineered agreements constructed through law and political settlement. Their value lies in enabling investment, specialization and trade under uncertainty. Prices, money and contracts compress information about scarcity, preferences and risk, enabling production to be coordinated across large populations without centralized direction.&lt;&#x2F;p&gt;
&lt;p&gt;The global expansion of trade in the twentieth century reflected these institutional foundations. Specialization increased productivity and interdependence reduced conflict by raising the cost of disruption. Innovations such as neutral jurisdictions and corporate structures enabled strangers to transact under shared rules. Legal entities functioned as containers that allowed participants from different regulatory environments to collaborate.&lt;&#x2F;p&gt;
&lt;p&gt;This infrastructure, whether admired or criticized, underwrote the international economic order of the late twentieth century.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;the-missing-architecture-of-digital-ownership&quot;&gt;The Missing Architecture of Digital Ownership&lt;&#x2F;h2&gt;
&lt;p&gt;The internet lowered the cost of communication and commerce across borders, but it did not establish a neutral mechanism for defining and enforcing claims on digital assets. Offline, ownership is adjudicated by courts, enforced by states and geographically bounded. Online, in the absence of a global authority, ownership defaults to either national legal systems or to the platforms that mediate activity.&lt;&#x2F;p&gt;
&lt;p&gt;Corporations filled this vacuum by providing infrastructure for identity, communication and exchange. They set terms of access, mediate transactions and retain discretionary control over assets generated within their systems. Users and firms may create content, build businesses and accumulate value, but their rights are contingent on the policies of the platform operator.&lt;&#x2F;p&gt;
&lt;p&gt;The experience of Zynga illustrates this dynamic. The company developed a profitable games business on Facebook and briefly achieved a valuation exceeding that of Electronic Arts. Its fortunes deteriorated when Facebook revised its policies and altered its revenue share. Zynga owned its intellectual property and its infrastructure but not the environment on which its business model depended, a common position for firms built on platform economies. In digital markets, platforms function as de facto landlords.&lt;&#x2F;p&gt;
&lt;p&gt;This is not an isolated case but a structural feature of platform centered economies: extensive participation paired with limited control.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;ethereum-as-an-institutional-experiment&quot;&gt;Ethereum as an Institutional Experiment&lt;&#x2F;h2&gt;
&lt;p&gt;Ethereum is a response to this institutional absence. It provides a mechanism for creating, transferring and enforcing digital assets without reliance on corporate or national intermediaries. The system operates as a verifiable computing environment in which rules are encoded in software and enforced collectively by a distributed network.&lt;&#x2F;p&gt;
&lt;p&gt;Traditional computing systems require users to trust the operator. Ethereum distributes computation across thousands of machines that execute identical code and verify each other in a continuous process. Outputs are accepted when consensus is reached and misbehavior is economically penalized. Under these conditions, property rights and contractual commitments can be represented as digital objects whose enforcement does not depend on courts or discretionary authority.&lt;&#x2F;p&gt;
&lt;p&gt;This architecture automates functions normally performed by institutions. Auditors repeat financial records to detect manipulation. Courts resolve disputes. Regulators impose compliance standards. These systems are essential but costly and slow. Ethereum replicates aspects of verification and enforcement at the system level using software, mathematics and economic incentives.&lt;&#x2F;p&gt;
&lt;p&gt;The network is open to participation without authorization and resistant to censorship because no single entity can unilaterally block or rewrite transactions. These properties arise from the structure of the system rather than ideological intent.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;the-emergence-of-a-digital-financial-system&quot;&gt;The Emergence of a Digital Financial System&lt;&#x2F;h2&gt;
&lt;p&gt;The first adopters of Ethereum were technologists experimenting with new mechanisms for ownership and coordination. Most of the culture and products were created for themselves. Over time, a broader range of actors began using the system for financial services.&lt;&#x2F;p&gt;
&lt;p&gt;The most consequential development has been the rise of stablecoins, digital representations of fiat currency backed by real world assets. Their combined market capitalization exceeds three hundred billion dollars, with a majority circulating on Ethereum. Transaction volumes on blockchain networks now approach those processed by major payment systems.&lt;&#x2F;p&gt;
&lt;p&gt;Stablecoins replicate core financial functions such as store of value and transfer of funds without geographic restrictions and with continuous settlement. Their programmability enabled the construction of lending protocols that allow users to lend and borrow assets with risk parameters enforced in software rather than through institutional mediation.&lt;&#x2F;p&gt;
&lt;p&gt;These systems differ from traditional financial infrastructure. Participation is global rather than jurisdictional. Switching costs are low because services are built on interoperable standards. Exit is immediate. Risk is transparent though often misunderstood.&lt;&#x2F;p&gt;
&lt;p&gt;Compare that to countries like Argentina, where interoperability between banks and fintech wallets, something as trivial as scanning a QR code, is still an ongoing regulatory battle. Incumbents try to use their market position to avoid being interoperable. On Ethereum, interoperability is structural. Individuals can receive payment, convert assets, provide liquidity and borrow collateralized funds within minutes from a mobile device. In legacy systems, similar transactions take days and incur high fees. Adoption reflects demand for neutral infrastructure in environments where intermediation is unreliable.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;implications&quot;&gt;Implications&lt;&#x2F;h2&gt;
&lt;p&gt;Several areas of financial activity are migrating to blockchain based systems, including remittances, trade finance and private credit. Others, such as corporate debt markets, remain fragmented and costly but exhibit characteristics that may make them suitable for digital reconstruction on top of Ethereum.&lt;&#x2F;p&gt;
&lt;p&gt;Significant obstacles remain. Regulatory uncertainty, operational risk and user experience challenges constrain adoption. Scaling transaction throughput without compromising decentralization is an engineering problem that has not been solved conclusively. Software vulnerabilities and governance failures present meaningful risk.&lt;&#x2F;p&gt;
&lt;p&gt;These challenges appear tractable. Early evidence suggests that elements of financial intermediation can be automated at lower cost and with greater transparency than existing systems. The trajectory of adoption will depend on institutional responses as much as technical progress.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;artificial-intelligence-and-coordination&quot;&gt;Artificial Intelligence and Coordination&lt;&#x2F;h2&gt;
&lt;p&gt;Artificial intelligence increases productive capacity by automating tasks but does not resolve questions of ownership, governance or compliance. Output may be generated more efficiently, but disputes over entitlement, liability and compensation persist.&lt;&#x2F;p&gt;
&lt;p&gt;Artificial intelligence and blockchains, but in particular Ethereum, are the two biggest innovations in the decades to come. The two technologies solve concrete core primitives of humans: productivity gains and coordination. Artificial intelligence will make people more productive, but it will not eliminate the bureaucratic machinery required to verify and enforce outcomes. Ethereum introduces a technology that complements AI: a system where humans and autonomous agents can coordinate, trade, and settle disputes directly through code, without relying on institutions to prove that everyone followed the rules.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;&#x2F;h2&gt;
&lt;p&gt;The internet lowered the cost of transmitting information but did not create institutions for defining and enforcing rights over digital assets. The result has been an economy coordinated by private platforms rather than neutral systems of governance. Ethereum reconstructs elements of property rights and contractual enforcement as public infrastructure encoded in software.&lt;&#x2F;p&gt;
&lt;p&gt;Whether such systems become core infrastructure or remain specialized instruments will depend on institutional adaptation, regulation and technological progress. They have already demonstrated an alternative cost structure for financial coordination and introduced mechanisms for digital property that do not rely on centralized administration.&lt;&#x2F;p&gt;
&lt;p&gt;The internet built an economy without institutions. Ethereum is an attempt to build them.&lt;&#x2F;p&gt;
</content>
        
    </entry>
    <entry xml:lang="en">
        <title>Crypto doctrine</title>
        <published>2025-09-25T00:00:00+00:00</published>
        <updated>2025-09-25T00:00:00+00:00</updated>
        
        <author>
          <name>
            
              Unknown
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://federicocarrone.com/articles/crypto-doctrine/"/>
        <id>https://federicocarrone.com/articles/crypto-doctrine/</id>
        
        <content type="html" xml:base="https://federicocarrone.com/articles/crypto-doctrine/">&lt;h1 id=&quot;crypto-and-the-21st-century&quot;&gt;Crypto and the 21st Century&lt;&#x2F;h1&gt;
&lt;p&gt;We believe crypto has been incredibly successful at providing a trustless financial layer for the 21st century. In particular it has found product market fit in two main areas:&lt;&#x2F;p&gt;
&lt;p&gt;In developing countries providing aids and tools to individuals that need to fight against inflation, censorship and for companies and individuals to be able to business.
Internet native communities that need a financial layer in the web that allows them to express and coordinate at a scale that wasn’t possible before. They have created new financial assets and markets that seem absurd from outside. Many times they are also absurd from the inside.
People that don’t live in a developing country or that didn’t grow up with the internet have enormous difficulties understanding crypto because they don’t have skin in its game. They believe crypto doesn’t have any “real” use case or that is not serious enough. They are right. The thing is that we are living in a world that’s is becoming more absurd. Memes do not only make you laugh anymore, memes are now winning elections.&lt;&#x2F;p&gt;
&lt;p&gt;We’re sure that these two use cases will grow with time and probably new ones will be found. The world is becoming more chaotic and more divided each day. The stability that existed since the fall of the Soviet Union and the beginning of the pandemic appears to have become a thing of the past. Only change will become the norm. And we love it.&lt;&#x2F;p&gt;
&lt;p&gt;This will make crypto even bigger. One of its prime advantages is that it kills many of the middlemen and allow us to coordinate even in the harshest environments. Trust assumptions are lowered thanks to economic incentives, compilers, distributed systems and cryptography. Crypto lowers the reliance on human beings. This empowers humans. It allows them to concentrate their disputes and efforts in subjectives areas. Crypto creates safe zones where some parts of the human activity becomes non-debatable (until quantum computers solve the discrete log problem).&lt;&#x2F;p&gt;
&lt;p&gt;Most of us are internet natives. We have been using irc, 4chan, reddit, hacker news, twitter, Bitcoin and Ethereum since their beginning and our organization has deep roots in unstable countries. In our roots we have a strange mix of knowing what it is to live in very chaotic societies and how to develop businesses within them and at the same time we are builders that love working in the frontier of engineering and scientific developments. We are the Fremen of crypto, raised in a harsh environment.&lt;&#x2F;p&gt;
&lt;p&gt;Open source and decentralization are not only philosophical ideas but necessary practical conditions to build crypto. Building in the open, helping onboard others and creating movements bigger than the original project are crucial for crypto projects to succeed long term. Sometimes it’s difficult for us to explain our actions to others that don’t follow the same ethos since we are not maximizing the same outcomes.&lt;&#x2F;p&gt;
&lt;p&gt;Our main objective is to help these new internet highways to be built in sustainable ways. Economic sustainability is one key aspect but there are others. We are a force that builds large technological projects but that also counterweights the natural tendency to centralize as a side effect of optimization. Centralization is easier and cheaper in the short run.  If we would want to optimize money, there are easier ways to do it. The thing is that is not our main objective. We only see money as a tool to achieve our objectives.&lt;&#x2F;p&gt;
&lt;p&gt;With or without money you will find us building. You are invited to join us in our journey.&lt;&#x2F;p&gt;
&lt;p&gt;“Top-down management leveraging command-and-control hierarchies are for the mahogany boardrooms of yesteryear. We are navigators, adventurers, and explorers of the future. We are married to the sea” - Yearn&#x27;s Blue Pill&lt;&#x2F;p&gt;
</content>
        
    </entry>
    <entry xml:lang="en">
        <title>Transforming the Future with Zero-Knowledge Proofs, Fully Homomorphic Encryption and new Distributed Systems algorithms</title>
        <published>2023-04-13T00:00:00+00:00</published>
        <updated>2023-04-13T00:00:00+00:00</updated>
        
        <author>
          <name>
            
              Unknown
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://federicocarrone.com/articles/transforming-the-future-with-zero-knowledge-proofs-fully-homomorphic-encryption-and-new-distributed-systems-algorithms/"/>
        <id>https://federicocarrone.com/articles/transforming-the-future-with-zero-knowledge-proofs-fully-homomorphic-encryption-and-new-distributed-systems-algorithms/</id>
        
        <content type="html" xml:base="https://federicocarrone.com/articles/transforming-the-future-with-zero-knowledge-proofs-fully-homomorphic-encryption-and-new-distributed-systems-algorithms/">&lt;p&gt;The evolution of every scientific discipline or engineering field experiences cycles akin to those observed in economies. Incremental advancements are made daily by corporations, individuals, and academic institutions. Occasionally, a researcher or engineer makes a groundbreaking discovery that alters the course of the field. One such example is Sir Isaac Newton, who made significant contributions to calculus, motion, optics, and gravitation during the time of the bubonic plague, which claimed millions of lives. His relentless pursuit of knowledge throughout the pandemic proved instrumental in shaping the development of mathematics, physics, and engineering. Our comfortable modern lives stand upon the foundation of these monumental discoveries.&lt;&#x2F;p&gt;
&lt;p&gt;The general public is aware of the big breakthroughs made in the aerospatial industry, energy production, internet of things, and last but not least artificial intelligence. However, most don’t know that during the COVID pandemic, enormous advances were made in cryptography. 47 years ago Diffie and Hellman wrote in their famous cryptography paper: “we stand today on the brink of a revolution in cryptography”, which enabled two people to exchange confidential information even when they can only communicate via a channel monitored by an adversary. This revolution enabled electronic commerce and the communication between citizens of the free world. We believe the discoveries made by researchers and engineers in cryptography during this COVID pandemic will be as important as the discoveries made by Diffie and Hellman in the upcoming decades.&lt;&#x2F;p&gt;
&lt;p&gt;One of the big discoveries has been how to make Zero-Knowledge Proofs fast enough for real-world applications. This technology has been around since 1984 but as Diffie also said, “Lots of people working in cryptography have no deep concern with real application issues. They are trying to discover things clever enough to write papers about”. Fortunately for humanity, researchers and engineers have made this technology practical enough in the last decade (especially the last 2 years) to be useful.&lt;&#x2F;p&gt;
&lt;p&gt;The financial system depends on the existence of intermediaries: an army of auditors, regulators, and accountants. The correct working of the financial machine depends on the integrity of its financial institutions. Integrity is maintained due to positive economic incentives and jail time, fines, and costly lawsuits if the intermediaries don’t do what the state and society expect from them. Bitcoin, a result of the 2008 crisis, created a permissionless financial system where its users can send and receive digital money without intermediaries and without anybody being able to block transactions. In countries like Argentina, Nigeria, or Lebanon, where stagnation and inflation erode its citizens&#x27; trust in the financial system and the state, Bitcoin and stablecoins on top of Ethereum are used on a daily basis by the young population to save and avoid capital controls. In developed countries, its usage is not as massive since the traditional financial system and the state is trusted by most citizens. However, the world is becoming more complex. Banks are failing in the US and Europe, a new war is taking place in Europe, debt levels are not sustainable in many countries, the fight between left and the right is retaking the main stage, tension between the West and the East increases, and technological change keeps accelerating.&lt;&#x2F;p&gt;
&lt;p&gt;New applications built on top of unstoppable and trustless technologies that don’t depend on social trust will grow and thrive in this type of environment. Everything is being questioned. Only things that can’t be questioned will fully resist the passage of time. This will happen not only in developing countries but also in developed ones. Systems like Bitcoin, where everyone can verify how it’s running, are more resilient and become more useful by the day in a world that is getting more complex.&lt;&#x2F;p&gt;
&lt;p&gt;Bitcoin&#x27;s focus has been to become a new type of monetary asset and financial network. For this reason, the development of more complex programs on top of Bitcoin has always been restricted by design. Newer blockchains like Ethereum added the ability to create new types of applications. DeFi Protocols that enabled lending and borrowing, exchange of digital currencies and the ability to buy, sell and trade digital collectives and arts rapidly grew on top of Ethereum. However the cost of creating and transferring relevant amounts of assets in blockchains is costly. The ability to create more complex applications that sit on top of blockchains is also very limited. Applications can’t run more than a few milliseconds on Ethereum.&lt;&#x2F;p&gt;
&lt;p&gt;These systems do not rely on social integrity like traditional systems. Instead, they operate as a permissionless and censorship-resistant network, allowing anyone to add a node and submit updates to its state. To ensure verification, each node must re-execute all transactions, which makes the system decentralized and secure, albeit slower than centralized systems. Consequently, this imposes a limitation on the types of applications that can be built on blockchains. Applications requiring frequent database state updates, such as those exceeding a few times per second, or machine learning algorithms, are not feasible on blockchain platforms.&lt;&#x2F;p&gt;
&lt;p&gt;This is where Zero Knowledge Proofs (ZKPs) and other cryptographic and distributed systems primitives will help society create tools that can be used by everyone. ZKPs enable a party to demonstrate a statement to other parties without revealing any information beyond the proof. In more concrete terms, this enables a person to show another person that the computation they did is correct without having to redo it and without even having to grant access to the data that was used. An important aspect of this is that the verification is done in a much faster time than the proving. In even simpler terms, it proves that the output of a certain computation is correct. The verification is way easier and faster to do than the execution or proving. Anybody can check the proof, and this saves computing time and money.&lt;&#x2F;p&gt;
&lt;p&gt;At the beginning it’s difficult to grasp, even for engineers, that such a technology is even possible. The mathematics behind it, until recently, seemed magical, and that’s why it was called moon math. Thanks to ZKPs, transferring money in blockchains similar to Bitcoin is cheaper and way faster since there is no need to re-execute each transaction by each node. Only one node is needed to process all the transactions and prove them using a ZKPs, while the rest simply need to verify it, saving valuable computing resources. Among other things, ZKPs enable creating a financial system that doesn’t depend on social trust like traditional finance and that doesn’t depend as much on re-executing algorithms as Bitcoin.&lt;&#x2F;p&gt;
&lt;p&gt;Zero Knowledge Proofs facilitate the development of an entirely new range of applications that are executed and proven on a single computer outside the blockchain, with verification occurring within Ethereum. The verification cost is way cheaper than the time it takes to prove or execute it. Ethereum will evolve from a slow yet secure distributed mainframe, where execution time is shared among all users to run small programs, into a distributed computer that stores and verifies proofs generated externally from the blockchain.&lt;&#x2F;p&gt;
&lt;p&gt;Not only will blockchains benefit from the development of new cryptographic primitives like Zero Knowledge Proofs (ZKPs), but other areas will also be significantly impacted. As AI-generated content begins to overshadow human-generated content on the internet, ZKPs will become essential for verifying that such content was produced by unbiased AI models. &quot;Proof of humanity&quot; systems are already employing ZKPs to ensure the accurate computation of a human accessing specific resources.&lt;&#x2F;p&gt;
&lt;p&gt;Hardware is another area where ZKPs will make an impact. Similar to how graphics cards in the 1990s revolutionized the video game industry, zero-knowledge hardware acceleration will be integrated into computers to enhance efficiency.&lt;&#x2F;p&gt;
&lt;p&gt;ZKPs can also be utilized to balance storage and computation securely. For instance, security cameras generate vast amounts of data. ZKPs can provide a compact proof that AI models did not detect any critical information in the video, allowing the system to delete the footage and save storage space.&lt;&#x2F;p&gt;
&lt;p&gt;ZKPs will even be used for national security purposes. As energy production shifts from centralized power plants to distributed sources like solar panels and wind turbines, verifying the proper execution of software on their controllers becomes vital. In the coming decades, ZKPs will play a crucial role in securing these devices.&lt;&#x2F;p&gt;
&lt;p&gt;Software industry regulations are inevitable, and industries such as online casinos and ad networks using Real-Time Bidding protocols will be legally required to demonstrate that they have not deceived their clients. Laws protecting users from large tech corporations are already in place in Europe, partly due to concerns about data misuse by foreign powers to influence political campaigns.&lt;&#x2F;p&gt;
&lt;p&gt;Requirements for secure storage and processing of encrypted data will become increasingly necessary. Fully Homomorphic Encryption (FHE), a technology akin to ZKPs, will be one of the tools utilized for this purpose. FHE enables computation on encrypted data, ensuring privacy. As FHE becomes more efficient and practical, most databases will integrate some FHE functionality, preventing administrators from accessing user data directly.&lt;&#x2F;p&gt;
&lt;p&gt;Zero-knowledge proofs (ZKPs), which generate evidence for a third party to confirm the accurate execution of a computation, and Fully Homomorphic Encryption (FHE), which enables calculations on encrypted data, will be combined with distributed systems algorithms that are capable of tolerating significant network failures similar to those employed by Bitcoin. Together they will be utilized to comply with regulations while creating trustless applications.&lt;&#x2F;p&gt;
&lt;p&gt;In the past decade, we have successfully launched applications serving dozens of millions of users. Leveraging our expertise, we are now dedicated to providing both technical and financial support to help others create startups focused on developing and implementing these vital technologies. As society grapples with the challenges of our rapidly evolving world these innovations will prove to be indispensable.&lt;&#x2F;p&gt;
</content>
        
    </entry>
</feed>
