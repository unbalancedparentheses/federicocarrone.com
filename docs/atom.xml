<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en">
    <title></title>
    <link rel="self" type="application/atom+xml" href="https://federicocarrone.com/atom.xml"/>
    <link rel="alternate" type="text/html" href="https://federicocarrone.com"/>
    <generator uri="https://www.getzola.org/">Zola</generator>
    <updated>2025-12-26T00:00:00+00:00</updated>
    <id>https://federicocarrone.com/atom.xml</id>
    <entry xml:lang="en">
        <title>The Concrete Programming Language: Systems Programming for Formal Reasoning</title>
        <published>2025-12-26T00:00:00+00:00</published>
        <updated>2025-12-26T00:00:00+00:00</updated>
        
        <author>
          <name>
            
              Unknown
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://federicocarrone.com/series/concrete/the-concrete-programming-language-systems-programming-for-formal-reasoning/"/>
        <id>https://federicocarrone.com/series/concrete/the-concrete-programming-language-systems-programming-for-formal-reasoning/</id>
        
        <content type="html" xml:base="https://federicocarrone.com/series/concrete/the-concrete-programming-language-systems-programming-for-formal-reasoning/">&lt;p&gt;There&#x27;s a tension at the heart of systems programming. We want languages expressive enough to build complex systems, yet simple enough to reason about with confidence. We want performance without sacrificing safety. We want the freedom to write low-level code and the guarantees that come from formal verification.&lt;&#x2F;p&gt;
&lt;p&gt;Concrete is an attempt to resolve these tensions through commitment to a single organizing principle: &lt;strong&gt;every design choice must answer the question, can a machine reason about this?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;h2 id=&quot;the-core-idea&quot;&gt;The Core Idea&lt;&#x2F;h2&gt;
&lt;p&gt;Most languages treat verification as something bolted on after the fact. You write code, then maybe you write tests, maybe you run a linter, maybe you bring in a theorem prover for critical sections. The language itself remains agnostic about provability.&lt;&#x2F;p&gt;
&lt;p&gt;Concrete inverts this relationship. The language is &lt;em&gt;designed around&lt;&#x2F;em&gt; a verified core, a small kernel calculus formalized in Lean with mechanically-checked proofs of progress, preservation, linearity soundness, and effect soundness. The surface language exists only to elaborate into this kernel. If your program type-checks, it&#x27;s correct by construction.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;the-trust-boundary&quot;&gt;The Trust Boundary&lt;&#x2F;h3&gt;
&lt;p&gt;Precision about what&#x27;s verified matters. The kernel type system and its properties are mechanically checked in Lean. What remains trusted: the Lean proof checker itself, the elaborator (surface language to kernel), and the code generator (kernel to machine code). Verifying the elaborator and code generator is future work.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;the-compilation-pipeline&quot;&gt;The Compilation Pipeline&lt;&#x2F;h2&gt;
&lt;p&gt;Understanding how Concrete programs become executables clarifies what guarantees you get and where:&lt;&#x2F;p&gt;
&lt;pre class=&quot;z-code&quot;&gt;&lt;code&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;Source Code (.concrete)
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;       ↓
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;   Lexer&#x2F;Parser (LL(1) recursive descent)
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;       ↓
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;   Surface AST
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;       ↓
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;   Elaboration
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;     - Type checking
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;     - Linearity checking
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;     - Capability checking
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;     - Borrow&#x2F;region checking
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;     - Defer insertion points
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;     - Allocator binding resolution
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;       ↓
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;   Kernel IR (core calculus)
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;       ↓
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;   Kernel Checker ← proven sound in Lean
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;       ↓
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;   Code Generation
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;       ↓
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;   Machine Code
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The kernel checkpoint is the semantic gate. Everything before it transforms syntax; everything after it preserves meaning. The kernel checker verifies that the elaborated program satisfies linearity, capabilities, and effect constraints—properties proven sound in Lean.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;what-you-re-giving-up&quot;&gt;What You&#x27;re Giving Up&lt;&#x2F;h2&gt;
&lt;p&gt;Concrete is not a general-purpose language for every project. It&#x27;s designed for code that &lt;em&gt;must&lt;&#x2F;em&gt; be correct: cryptographic implementations, financial systems, safety-critical software, blockchain infrastructure, anything where bugs have consequences measured in dollars or lives.&lt;&#x2F;p&gt;
&lt;p&gt;To get there, Concrete eliminates entire categories of language features:&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;No garbage collection.&lt;&#x2F;strong&gt; Memory is managed through linear types and explicit destruction. Every resource is consumed exactly once. No GC pauses, no unpredictable latency, no hidden memory pressure.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;No hidden control flow.&lt;&#x2F;strong&gt; When you read Concrete code, what you see is what executes. There are no implicit function calls from operator overloading, no invisible destructor insertion, no exception unwinding behind your back. If a function is called, you see it. If cleanup happens, you see the &lt;code&gt;defer&lt;&#x2F;code&gt; statement.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;No implicit allocation.&lt;&#x2F;strong&gt; Allocation requires the &lt;code&gt;Alloc&lt;&#x2F;code&gt; capability, and the caller explicitly binds which allocator to use. &lt;code&gt;grep with(Alloc)&lt;&#x2F;code&gt; finds every function that might touch the heap.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;No interior mutability.&lt;&#x2F;strong&gt; All mutation flows through &lt;code&gt;&amp;amp;mut&lt;&#x2F;code&gt; references. An immutable reference &lt;code&gt;&amp;amp;T&lt;&#x2F;code&gt; actually guarantees immutability—no &lt;code&gt;Cell&lt;&#x2F;code&gt;, no &lt;code&gt;RefCell&lt;&#x2F;code&gt;, no &lt;code&gt;UnsafeCell&lt;&#x2F;code&gt; escape hatches in safe code. If you need a cache, pass &lt;code&gt;&amp;amp;mut&lt;&#x2F;code&gt;. If you need lazy initialization, initialize before borrowing. For advanced patterns that genuinely require interior mutability, unsafe primitives gated by the &lt;code&gt;Unsafe&lt;&#x2F;code&gt; capability exist, but safe code cannot accidentally acquire interior mutability.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;No reflection, no eval, no runtime metaprogramming.&lt;&#x2F;strong&gt; All code paths are determined at compile time. This breaks certain patterns but makes verification tractable.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;No global state.&lt;&#x2F;strong&gt; All state is passed explicitly or accessed through capabilities.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;No variable shadowing.&lt;&#x2F;strong&gt; Each variable name is unique within its scope. This prevents a class of subtle bugs and makes code more auditable.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;No null.&lt;&#x2F;strong&gt; Optional values use &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;&#x2F;code&gt;. No billion-dollar mistakes.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;No undefined behavior.&lt;&#x2F;strong&gt; Kernel semantics are fully defined and proven sound.&lt;&#x2F;p&gt;
&lt;p&gt;The result is a language that restricts what you can express in exchange for mechanical guarantees about what your code actually does.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;capabilities-making-effects-legible&quot;&gt;Capabilities: Making Effects Legible&lt;&#x2F;h2&gt;
&lt;p&gt;The capability system is where Concrete&#x27;s design philosophy becomes most visible. Rather than treating side effects as the default and purity as an opt-in annotation, Concrete is &lt;strong&gt;pure by default&lt;&#x2F;strong&gt;. A function without capability annotations cannot perform IO, cannot allocate, cannot mutate external state. It&#x27;s a mathematical function that computes a result from its inputs, nothing more.&lt;&#x2F;p&gt;
&lt;p&gt;Purity in Concrete means no side effects and no heap allocation. Stack allocation and compile-time constants are permitted. Notably, Concrete does not guarantee termination—recursive functions may diverge. This is intentional: systems programming sometimes requires non-termination, but side effects must remain explicit.&lt;&#x2F;p&gt;
&lt;p&gt;When a function needs to perform effects, it declares exactly which ones:&lt;&#x2F;p&gt;
&lt;pre class=&quot;z-code&quot;&gt;&lt;code&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;fn read_file(path: String) with(FileRead) -&amp;gt; String {
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;    ...
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;}
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;fn process_with_network() with(FileRead, Network, Alloc) -&amp;gt; Result {
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;    ...
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Capabilities propagate monotonically through the call graph. If &lt;code&gt;f&lt;&#x2F;code&gt; calls &lt;code&gt;g&lt;&#x2F;code&gt;, and &lt;code&gt;g&lt;&#x2F;code&gt; requires &lt;code&gt;FileRead&lt;&#x2F;code&gt;, then &lt;code&gt;f&lt;&#x2F;code&gt; must declare &lt;code&gt;FileRead&lt;&#x2F;code&gt; too. There&#x27;s no implicit granting, no ambient authority. The compiler enforces this transitively, making all effects visible in signatures.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;the-std-capability&quot;&gt;The &lt;code&gt;Std&lt;&#x2F;code&gt; Capability&lt;&#x2F;h3&gt;
&lt;p&gt;For application entry points and prototyping, Concrete provides a shorthand. The &lt;code&gt;!&lt;&#x2F;code&gt; suffix declares the &lt;code&gt;Std&lt;&#x2F;code&gt; capability:&lt;&#x2F;p&gt;
&lt;pre class=&quot;z-code&quot;&gt;&lt;code&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;fn main!() {
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;    println(&amp;quot;Hello&amp;quot;)
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This desugars to &lt;code&gt;fn main() with(Std)&lt;&#x2F;code&gt;. The &lt;code&gt;Std&lt;&#x2F;code&gt; capability includes common platform effects—file operations, network, clock, environment, random, and allocation—but explicitly excludes &lt;code&gt;Unsafe&lt;&#x2F;code&gt;. Library code should prefer explicit capability lists; &lt;code&gt;!&lt;&#x2F;code&gt; is a convenience for applications.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;security-model&quot;&gt;Security Model&lt;&#x2F;h3&gt;
&lt;p&gt;Capabilities don&#x27;t sandbox code—if a dependency declares &lt;code&gt;with(Network)&lt;&#x2F;code&gt;, it gets network access. What they provide is &lt;strong&gt;auditability&lt;&#x2F;strong&gt;. You can grep your codebase for &lt;code&gt;with(Network)&lt;&#x2F;code&gt; and find every function that touches the network. You can verify that your JSON parser has no capabilities at all. You can review dependency updates by diffing capability declarations.&lt;&#x2F;p&gt;
&lt;p&gt;The &lt;code&gt;Unsafe&lt;&#x2F;code&gt; capability surfaces all unsafe operations through the same system. There&#x27;s no &lt;code&gt;unsafe&lt;&#x2F;code&gt; keyword; instead, unsafe operations require declaring &lt;code&gt;with(Unsafe)&lt;&#x2F;code&gt;, and that requirement propagates like any other capability. Your trust boundaries become grep-able.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;linear-types-resources-as-values&quot;&gt;Linear Types: Resources as Values&lt;&#x2F;h2&gt;
&lt;p&gt;All values in Concrete are linear by default. A linear value must be consumed exactly once—not zero times (that&#x27;s a leak), not twice (that&#x27;s a double-free). Consumption happens when you pass the value to a function that takes ownership, return it, destructure it via pattern matching, or explicitly call &lt;code&gt;destroy(x)&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;pre class=&quot;z-code&quot;&gt;&lt;code&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;fn example!() {
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;    let f = open(&amp;quot;data.txt&amp;quot;)
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;    defer destroy(f)
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;    let content = read(&amp;amp;f)
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;    &#x2F;&#x2F; destroy(f) runs here because of defer
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;If &lt;code&gt;f&lt;&#x2F;code&gt; isn&#x27;t consumed on all paths, the program is rejected. If you try to use &lt;code&gt;f&lt;&#x2F;code&gt; after moving it, the program is rejected. This is compile-time enforcement, not runtime checking.&lt;&#x2F;p&gt;
&lt;p&gt;Some types—integers, booleans, floats—are explicitly marked &lt;code&gt;Copy&lt;&#x2F;code&gt; and escape linear restrictions:&lt;&#x2F;p&gt;
&lt;pre class=&quot;z-code&quot;&gt;&lt;code&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;type Copy Int
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;type Copy Bool
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;type Copy Float64
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;But the default is linearity, which forces you to think about resource ownership as you write code rather than hoping the runtime sorts it out.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;destructors&quot;&gt;Destructors&lt;&#x2F;h3&gt;
&lt;p&gt;A linear type may define a destructor that executes when &lt;code&gt;destroy(x)&lt;&#x2F;code&gt; is called:&lt;&#x2F;p&gt;
&lt;pre class=&quot;z-code&quot;&gt;&lt;code&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;type File {
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;    handle: FileHandle
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;}
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;destroy File with(FileClose) {
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;    platform_close(self.handle)
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The destructor takes ownership of &lt;code&gt;self&lt;&#x2F;code&gt;, may require capabilities, and runs exactly once when explicitly invoked. Crucially, &lt;code&gt;destroy(x)&lt;&#x2F;code&gt; is only valid if the type defines a destructor. A type without a destructor cannot be destroyed—it must be consumed by moving, returning, or destructuring. This prevents accidental discard and forces resource handling through program logic.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;defer-explicit-cleanup&quot;&gt;Defer: Explicit Cleanup&lt;&#x2F;h3&gt;
&lt;p&gt;The &lt;code&gt;defer&lt;&#x2F;code&gt; statement makes cleanup explicit. Unlike languages where destructors run implicitly at scope boundaries, Concrete requires you to write &lt;code&gt;defer destroy(f)&lt;&#x2F;code&gt;. You see the cleanup in the source. The compiler never secretly inserts destructor calls.&lt;&#x2F;p&gt;
&lt;pre class=&quot;z-code&quot;&gt;&lt;code&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;fn process_files!() {
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;    let f1 = open(&amp;quot;a.txt&amp;quot;)
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;    defer destroy(f1)           &#x2F;&#x2F; you see this
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;    
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;    let f2 = open(&amp;quot;b.txt&amp;quot;)
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;    defer destroy(f2)           &#x2F;&#x2F; you see this
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;    
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;    &#x2F;&#x2F; When scope exits:
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;    &#x2F;&#x2F; 1. destroy(f2) runs
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;    &#x2F;&#x2F; 2. destroy(f1) runs
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Multiple &lt;code&gt;defer&lt;&#x2F;code&gt; statements execute in reverse order (LIFO). &lt;code&gt;defer&lt;&#x2F;code&gt; runs at scope exit including early returns and error propagation. It&#x27;s deterministic—not &quot;eventually&quot; like GC finalizers.&lt;&#x2F;p&gt;
&lt;p&gt;When a value is scheduled with &lt;code&gt;defer destroy(x)&lt;&#x2F;code&gt;, it becomes reserved. You cannot move it, destroy it again, or create borrows that might overlap the deferred destruction point.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;borrowing-without-lifetime-annotations&quot;&gt;Borrowing Without Lifetime Annotations&lt;&#x2F;h2&gt;
&lt;p&gt;Concrete&#x27;s borrowing system draws from Rust but simplifies it. References exist within lexical regions—scopes that bound their lifetime. You can have multiple immutable borrows or one mutable borrow. References can&#x27;t escape their region.&lt;&#x2F;p&gt;
&lt;pre class=&quot;z-code&quot;&gt;&lt;code&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;borrow f as fref in R {
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;    &#x2F;&#x2F; fref has type &amp;amp;[File, R]
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;    &#x2F;&#x2F; f is unusable in this block
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;    let len = length(fref)
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;}
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;&#x2F;&#x2F; f is usable again
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The key difference from Rust: no lifetime parameters in function signatures. Functions that accept references are generic over the region, but this genericity is implicit:&lt;&#x2F;p&gt;
&lt;pre class=&quot;z-code&quot;&gt;&lt;code&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;fn length&amp;lt;R&amp;gt;(file: &amp;amp;[File, R]) -&amp;gt; Uint {
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;    ...
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The function cannot store the reference because it has no way to name &lt;code&gt;R&lt;&#x2F;code&gt; outside the call. The region system ensures references can&#x27;t outlive their source, but you don&#x27;t annotate lifetimes everywhere.&lt;&#x2F;p&gt;
&lt;p&gt;For single-expression borrows, the region is anonymous:&lt;&#x2F;p&gt;
&lt;pre class=&quot;z-code&quot;&gt;&lt;code&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;let len = length(&amp;amp;f)  &#x2F;&#x2F; borrows f for just this call
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h3 id=&quot;borrowing-rules&quot;&gt;Borrowing Rules&lt;&#x2F;h3&gt;
&lt;p&gt;The rules are strict but comprehensible:&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;While borrowed, the original is unusable&lt;&#x2F;li&gt;
&lt;li&gt;Multiple immutable borrows are allowed&lt;&#x2F;li&gt;
&lt;li&gt;Mutable borrows are exclusive—one &lt;code&gt;&amp;amp;mut T&lt;&#x2F;code&gt; at a time, no simultaneous &lt;code&gt;&amp;amp;T&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;References cannot escape their region&lt;&#x2F;li&gt;
&lt;li&gt;Nested borrows of the same owned value are forbidden&lt;&#x2F;li&gt;
&lt;li&gt;Borrowing a reference is allowed, but the derived reference can&#x27;t outlive the original&#x27;s region&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;Closures may not capture references if the closure escapes the borrow region. This ensures references never outlive their lexical scope.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;allocation-as-a-capability&quot;&gt;Allocation as a Capability&lt;&#x2F;h2&gt;
&lt;p&gt;Allocation deserves special attention because it&#x27;s so often invisible. In most languages, many operations allocate behind your back—string concatenation, collection growth, closure creation. You find out about allocation pressure through profiling or by hitting OOM.&lt;&#x2F;p&gt;
&lt;p&gt;Concrete treats allocation as a capability. Functions that may allocate declare &lt;code&gt;with(Alloc)&lt;&#x2F;code&gt;. The call site binds which allocator to use:&lt;&#x2F;p&gt;
&lt;pre class=&quot;z-code&quot;&gt;&lt;code&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;fn main!() {
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;    let arena = Arena.new()
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;    defer arena.deinit()
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;    
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;    let list = create_list&amp;lt;Int&amp;gt;() with(Alloc = arena)
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;    push(&amp;amp;mut list, 42) with(Alloc = arena)
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Inside a function with &lt;code&gt;with(Alloc)&lt;&#x2F;code&gt;, allocation &quot;just works&quot;—the bound allocator propagates through nested calls. But at the boundary, you see exactly where allocation happens and which allocator serves it.&lt;&#x2F;p&gt;
&lt;p&gt;Allocator binding is lexically scoped. A nested binding may shadow an outer one. Closures capture allocator bindings only if invoked within the lexical scope where the binding is in effect—if a closure escapes, it must accept an explicit allocator parameter.&lt;&#x2F;p&gt;
&lt;p&gt;Stack allocation does not require the &lt;code&gt;Alloc&lt;&#x2F;code&gt; capability:&lt;&#x2F;p&gt;
&lt;pre class=&quot;z-code&quot;&gt;&lt;code&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;fn example() {
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;    let x: Int = 42                    &#x2F;&#x2F; stack
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;    let arr: [100]Uint8 = zeroed()     &#x2F;&#x2F; stack
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This makes allocation-free code provably allocation-free.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;allocator-types&quot;&gt;Allocator Types&lt;&#x2F;h3&gt;
&lt;p&gt;Concrete provides several allocator types out of the box:&lt;&#x2F;p&gt;
&lt;pre class=&quot;z-code&quot;&gt;&lt;code&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;&#x2F;&#x2F; General-purpose heap allocator
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;let gpa = GeneralPurposeAllocator.new()
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;defer gpa.deinit()
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;&#x2F;&#x2F; Arena allocator — free everything at once
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;let arena = Arena.new(gpa)
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;defer arena.deinit()
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;&#x2F;&#x2F; Fixed buffer allocator — no heap, uses stack memory
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;let buf: [1024]Uint8 = zeroed()
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;let fba = FixedBufferAllocator.new(&amp;amp;buf)
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;All allocators implement a common &lt;code&gt;Allocator&lt;&#x2F;code&gt; trait with &lt;code&gt;alloc&lt;&#x2F;code&gt;, &lt;code&gt;free&lt;&#x2F;code&gt;, and &lt;code&gt;realloc&lt;&#x2F;code&gt; methods.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;error-handling&quot;&gt;Error Handling&lt;&#x2F;h2&gt;
&lt;p&gt;Errors are values, not exceptions:&lt;&#x2F;p&gt;
&lt;pre class=&quot;z-code&quot;&gt;&lt;code&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;fn parse(input: String) -&amp;gt; Result&amp;lt;Config, ParseError&amp;gt; {
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;    ...
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;}
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;fn load_config!() -&amp;gt; Result&amp;lt;Config, Error&amp;gt; {
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;    let f = open(&amp;quot;config.toml&amp;quot;)?
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;    defer destroy(f)
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;    
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;    let content = read(&amp;amp;f)
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;    let config = parse(content)?
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;    Ok(config)
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The &lt;code&gt;?&lt;&#x2F;code&gt; operator propagates errors. When &lt;code&gt;?&lt;&#x2F;code&gt; triggers an early return, all &lt;code&gt;defer&lt;&#x2F;code&gt; statements in scope run before returning. This interaction is crucial—cleanup happens even on error paths, and you can see exactly where.&lt;&#x2F;p&gt;
&lt;p&gt;There are no exceptions and no panic mechanism in the core language. If the runtime terminates due to an unrecoverable fault, deferred expressions are not guaranteed to run.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;pattern-matching&quot;&gt;Pattern Matching&lt;&#x2F;h2&gt;
&lt;p&gt;Exhaustive pattern matching with linear type awareness:&lt;&#x2F;p&gt;
&lt;pre class=&quot;z-code&quot;&gt;&lt;code&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;fn describe(opt: Option&amp;lt;Int&amp;gt;) -&amp;gt; String {
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;    match opt {
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;        Some(n) =&amp;gt; format(&amp;quot;Got {}&amp;quot;, n),
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;        None =&amp;gt; &amp;quot;Nothing&amp;quot;
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;    }
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Linear types in patterns must be consumed:&lt;&#x2F;p&gt;
&lt;pre class=&quot;z-code&quot;&gt;&lt;code&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;fn handle!(result: Result&amp;lt;Data, File&amp;gt;) {
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;    match result {
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;        Ok(data) =&amp;gt; use_data(data),
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;        Err(f) =&amp;gt; destroy(f)
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;    }
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Both branches consume their linear values. Borrowing in patterns is also supported:&lt;&#x2F;p&gt;
&lt;pre class=&quot;z-code&quot;&gt;&lt;code&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;fn peek(opt: &amp;amp;Option&amp;lt;Int&amp;gt;) -&amp;gt; Int {
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;    match opt {
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;        &amp;amp;Some(n) =&amp;gt; n,
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;        &amp;amp;None =&amp;gt; 0
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;    }
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;traits-and-bounded-polymorphism&quot;&gt;Traits and Bounded Polymorphism&lt;&#x2F;h2&gt;
&lt;p&gt;Traits provide bounded polymorphism:&lt;&#x2F;p&gt;
&lt;pre class=&quot;z-code&quot;&gt;&lt;code&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;trait Ord {
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;    fn compare(&amp;amp;self, other: &amp;amp;Self) -&amp;gt; Ordering
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;}
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;trait Show {
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;    fn show(&amp;amp;self) -&amp;gt; String
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;}
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;fn sort&amp;lt;T: Ord&amp;gt;(list: List&amp;lt;T&amp;gt;) with(Alloc) -&amp;gt; List&amp;lt;T&amp;gt; {
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;    ...
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;}
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;fn sort_and_print&amp;lt;T: Ord + Show&amp;gt;(list: List&amp;lt;T&amp;gt;) with(Alloc, Console) -&amp;gt; List&amp;lt;T&amp;gt; {
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;    let sorted = sort(list)
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;    print_all(&amp;amp;sorted)
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;    sorted
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Trait methods may take the receiver as &lt;code&gt;&amp;amp;self&lt;&#x2F;code&gt;, &lt;code&gt;&amp;amp;mut self&lt;&#x2F;code&gt;, or &lt;code&gt;self&lt;&#x2F;code&gt;. If a trait method takes &lt;code&gt;self&lt;&#x2F;code&gt;, calling it consumes the value following linear consumption rules. Trait implementations for linear types are allowed—they just must respect the receiver mode.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;generics-and-parametricity&quot;&gt;Generics and Parametricity&lt;&#x2F;h2&gt;
&lt;p&gt;Generic functions cannot accidentally become effectful depending on instantiation. Capabilities are checked before monomorphization and are invariant under instantiation:&lt;&#x2F;p&gt;
&lt;pre class=&quot;z-code&quot;&gt;&lt;code&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;fn map&amp;lt;T, U&amp;gt;(list: List&amp;lt;T&amp;gt;, f: fn(T) -&amp;gt; U) -&amp;gt; List&amp;lt;U&amp;gt; {
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;    ...
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This function is pure regardless of what &lt;code&gt;T&lt;&#x2F;code&gt; and &lt;code&gt;U&lt;&#x2F;code&gt; are. If &lt;code&gt;f&lt;&#x2F;code&gt; requires capabilities, that must be declared:&lt;&#x2F;p&gt;
&lt;pre class=&quot;z-code&quot;&gt;&lt;code&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;fn map_io&amp;lt;T, U&amp;gt;(list: List&amp;lt;T&amp;gt;, f: fn(T) with(IO) -&amp;gt; U) with(IO) -&amp;gt; List&amp;lt;U&amp;gt; {
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;    ...
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;There&#x27;s no capability polymorphism—you cannot be generic over capability sets. Each capability set must be concrete. This simplifies the type system and avoids questions about capability set operations at the type level.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;type-inference&quot;&gt;Type Inference&lt;&#x2F;h2&gt;
&lt;p&gt;Type inference is &lt;strong&gt;local only&lt;&#x2F;strong&gt;:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;Function signatures must be fully annotated (parameters, return type, capabilities)&lt;&#x2F;li&gt;
&lt;li&gt;Inside function bodies, local variable types may be inferred from their initializers&lt;&#x2F;li&gt;
&lt;li&gt;Type information flows in one direction (from annotations to inference, never backward)&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;pre class=&quot;z-code&quot;&gt;&lt;code&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;fn process(data: List&amp;lt;Int&amp;gt;) with(Alloc) -&amp;gt; List&amp;lt;Int&amp;gt; {
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;    let doubled = map(data, fn(x) { x * 2 })  &#x2F;&#x2F; type inferred
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;    let filtered = filter(doubled, fn(x) { x &amp;gt; 0 })  &#x2F;&#x2F; type inferred
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;    filtered
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This keeps type errors local and makes signatures self-documenting. You can always understand a function&#x27;s interface without reading its body.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;modules&quot;&gt;Modules&lt;&#x2F;h2&gt;
&lt;pre class=&quot;z-code&quot;&gt;&lt;code&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;module FileSystem
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;public fn open(path: String) with(FileOpen) -&amp;gt; Result&amp;lt;File, IOError&amp;gt; {
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;    ...
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;}
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;public fn read&amp;lt;R&amp;gt;(file: &amp;amp;[File, R]) with(FileRead) -&amp;gt; String {
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;    ...
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;}
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;private fn validate(path: String) -&amp;gt; Bool {
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;    ...
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Visibility is &lt;code&gt;public&lt;&#x2F;code&gt; or &lt;code&gt;private&lt;&#x2F;code&gt; (the default). Types, functions, and constants can be marked either way.&lt;&#x2F;p&gt;
&lt;p&gt;Capabilities are part of a function&#x27;s signature and therefore part of the public API contract. Changing the required capability set of a public function is a breaking change.&lt;&#x2F;p&gt;
&lt;p&gt;Imports support aliasing and selective imports:&lt;&#x2F;p&gt;
&lt;pre class=&quot;z-code&quot;&gt;&lt;code&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;import FileSystem
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;import FileSystem.{open, read, write}
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;import FileSystem as FS
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;types&quot;&gt;Types&lt;&#x2F;h2&gt;
&lt;h3 id=&quot;primitives&quot;&gt;Primitives&lt;&#x2F;h3&gt;
&lt;pre class=&quot;z-code&quot;&gt;&lt;code&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;Bool
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;Int, Int8, Int16, Int32, Int64
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;Uint, Uint8, Uint16, Uint32, Uint64
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;Float32, Float64
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;Char, String
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;All primitive numeric types and &lt;code&gt;Bool&lt;&#x2F;code&gt; are &lt;code&gt;Copy&lt;&#x2F;code&gt;. &lt;code&gt;String&lt;&#x2F;code&gt; is linear.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;algebraic-data-types&quot;&gt;Algebraic Data Types&lt;&#x2F;h3&gt;
&lt;pre class=&quot;z-code&quot;&gt;&lt;code&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;type Option&amp;lt;T&amp;gt; {
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;    Some(T),
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;    None
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;}
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;type Result&amp;lt;T, E&amp;gt; {
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;    Ok(T),
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;    Err(E)
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;}
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;type List&amp;lt;T&amp;gt; {
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;    Nil,
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;    Cons(T, List&amp;lt;T&amp;gt;)
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h3 id=&quot;records&quot;&gt;Records&lt;&#x2F;h3&gt;
&lt;pre class=&quot;z-code&quot;&gt;&lt;code&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;type Point {
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;    x: Float64,
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;    y: Float64
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;A record is &lt;code&gt;Copy&lt;&#x2F;code&gt; only if explicitly marked and all fields are &lt;code&gt;Copy&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre class=&quot;z-code&quot;&gt;&lt;code&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;type Copy Point {
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;    x: Float64,
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;    y: Float64
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;For generic types, linearity depends on the type parameter. &lt;code&gt;Option&amp;lt;Int&amp;gt;&lt;&#x2F;code&gt; is &lt;code&gt;Copy&lt;&#x2F;code&gt; because &lt;code&gt;Int&lt;&#x2F;code&gt; is. &lt;code&gt;Option&amp;lt;File&amp;gt;&lt;&#x2F;code&gt; is linear because &lt;code&gt;File&lt;&#x2F;code&gt; is.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;standard-library-types&quot;&gt;Standard Library Types&lt;&#x2F;h3&gt;
&lt;p&gt;For domains where precision matters, the standard library includes:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Decimal&lt;&#x2F;strong&gt; — Fixed-point decimal arithmetic for financial calculations&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;BigInt&lt;&#x2F;strong&gt; — Arbitrary-precision integers&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;BigDecimal&lt;&#x2F;strong&gt; — Arbitrary-precision decimals&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;These avoid floating-point representation errors in financial systems and cryptographic applications.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;determinism&quot;&gt;Determinism&lt;&#x2F;h2&gt;
&lt;h3 id=&quot;reproducible-builds&quot;&gt;Reproducible Builds&lt;&#x2F;h3&gt;
&lt;p&gt;Concrete aims for &lt;strong&gt;bit-for-bit reproducible builds&lt;&#x2F;strong&gt;:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;Same source code + same compiler version = identical binary&lt;&#x2F;li&gt;
&lt;li&gt;No timestamps, random seeds, or environment-dependent data embedded in output&lt;&#x2F;li&gt;
&lt;li&gt;Build order does not affect output&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h3 id=&quot;perfect-replayability&quot;&gt;Perfect Replayability&lt;&#x2F;h3&gt;
&lt;p&gt;For debugging, Concrete supports &lt;strong&gt;deterministic replay&lt;&#x2F;strong&gt;:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;All sources of non-determinism are explicit and controllable&lt;&#x2F;li&gt;
&lt;li&gt;Random number generation requires &lt;code&gt;Random&lt;&#x2F;code&gt; capability with explicit seed&lt;&#x2F;li&gt;
&lt;li&gt;System time requires &lt;code&gt;Clock&lt;&#x2F;code&gt; capability&lt;&#x2F;li&gt;
&lt;li&gt;Given the same inputs and capability bindings, execution is identical&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;This enables reproducing Heisenbugs that depend on timing or randomness. When your program behaves the same way every time given the same inputs, debugging becomes tractable.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;the-grammar-as-guarantee&quot;&gt;The Grammar as Guarantee&lt;&#x2F;h2&gt;
&lt;p&gt;Concrete uses an LL(1) grammar. Every parsing decision can be made with a single token of lookahead. No ambiguity, no backtracking, no lexer hacks.&lt;&#x2F;p&gt;
&lt;p&gt;This might seem like an implementation detail, but it has consequences for the developer experience. Simple tooling can parse Concrete—any LL(1) parser generator works. Syntax errors are local and comprehensible. There are no parser edge cases that behave differently in different tools.&lt;&#x2F;p&gt;
&lt;p&gt;The grammar enforces stylistic constraints: keywords are reserved, statements and expressions are syntactically distinct, blocks use braces, standard operator precedence is built in. You can&#x27;t invent surprising syntax.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;compilation-targets&quot;&gt;Compilation Targets&lt;&#x2F;h2&gt;
&lt;p&gt;Concrete supports multiple backends:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Native&lt;&#x2F;strong&gt; — Direct machine code via MLIR&#x2F;LLVM&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;C&lt;&#x2F;strong&gt; — Portable C output for maximum platform support&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;WebAssembly&lt;&#x2F;strong&gt; — For browser and edge deployment&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;Cross-compilation is a first-class feature. Specify target at build time.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;tooling&quot;&gt;Tooling&lt;&#x2F;h2&gt;
&lt;p&gt;Unlike languages where essential tooling is an afterthought or third-party dependency, Concrete ships with built-in tools:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Package manager&lt;&#x2F;strong&gt; — Dependency resolution and versioning&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;Formatter&lt;&#x2F;strong&gt; — Canonical code formatting (one true style)&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;Linter&lt;&#x2F;strong&gt; — Static analysis and style checking&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;Test runner&lt;&#x2F;strong&gt; — Built-in test framework&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;REPL&lt;&#x2F;strong&gt; — Interactive evaluation for debugging and exploration&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;These are part of the language distribution, not external dependencies with their own versioning and compatibility concerns.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;profiling-and-tracing&quot;&gt;Profiling and Tracing&lt;&#x2F;h2&gt;
&lt;p&gt;Profiling and tracing are first-class features:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;Built into the runtime, not bolted on&lt;&#x2F;li&gt;
&lt;li&gt;Low overhead when disabled&lt;&#x2F;li&gt;
&lt;li&gt;Structured output for tooling integration&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;While code is read more often than written, it is executed even more often than read. Performance visibility matters, especially for systems programming.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;what-you-can-say-about-programs&quot;&gt;What You Can Say About Programs&lt;&#x2F;h2&gt;
&lt;p&gt;If a program type-checks in Concrete, you gain mechanical knowledge about it:&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;&quot;This function is pure.&quot;&lt;&#x2F;strong&gt; No capabilities declared. The compiler proves it performs no side effects, no IO, no mutation, no allocation. You can reason about it as a mathematical function.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;&quot;This resource is used exactly once.&quot;&lt;&#x2F;strong&gt; Linear type. The compiler proves no leaks, no double-free, no use-after-free.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;&quot;These are the only effects this code can perform.&quot;&lt;&#x2F;strong&gt; Capability set is explicit. It cannot secretly touch the network or file system.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;&quot;This code cannot escape the type system.&quot;&lt;&#x2F;strong&gt; Unsafe operations require &lt;code&gt;with(Unsafe)&lt;&#x2F;code&gt;. You can grep for all trust boundaries.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;&quot;Allocation happens here, using this allocator.&quot;&lt;&#x2F;strong&gt; Call site binds the allocator. No hidden heap activity.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;&quot;Cleanup happens here.&quot;&lt;&#x2F;strong&gt; &lt;code&gt;defer destroy(x)&lt;&#x2F;code&gt; is visible. The compiler doesn&#x27;t insert invisible destructor calls.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;&quot;This build is reproducible.&quot;&lt;&#x2F;strong&gt; Same inputs, same binary. Debugging is tractable.&lt;&#x2F;p&gt;
&lt;p&gt;These are mechanical guarantees derived from the type system, which is itself proven sound in Lean. Not best practices, not conventions—proofs.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;example-file-processing&quot;&gt;Example: File Processing&lt;&#x2F;h2&gt;
&lt;pre class=&quot;z-code&quot;&gt;&lt;code&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;module Main
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;import FileSystem.{open, read, write}
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;import Parse.{parse_csv}
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;fn process_file!(input_path: String, output_path: String) with(Alloc) -&amp;gt; Result&amp;lt;(), Error&amp;gt; {
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;    let in_file = open(input_path)?
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;    defer destroy(in_file)
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;    
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;    let content = read(&amp;amp;in_file)
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;    let data = parse_csv(content)?
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;    let output = transform(&amp;amp;data)
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;    
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;    let out_file = open(output_path)?
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;    defer destroy(out_file)
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;    
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;    write(&amp;amp;mut out_file, output)
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;    Ok(())
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;}
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;fn transform(data: &amp;amp;List&amp;lt;Row&amp;gt;) -&amp;gt; String {
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;    ...
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;}
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;fn main!() {
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;    let arena = Arena.new()
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;    defer arena.deinit()
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;    
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;    match process_file(&amp;quot;input.csv&amp;quot;, &amp;quot;output.txt&amp;quot;) with(Alloc = arena) {
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;        Ok(()) =&amp;gt; println(&amp;quot;Done&amp;quot;),
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;        Err(e) =&amp;gt; println(&amp;quot;Error: &amp;quot; + e.message())
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;    }
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Everything is visible: resource acquisition, cleanup scheduling, error propagation, allocator binding. No hidden control flow.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;who-should-use-this&quot;&gt;Who Should Use This&lt;&#x2F;h2&gt;
&lt;p&gt;Concrete is not for every project. It trades convenience for explicitness, flexibility for auditability. Prototyping is slower. Some patterns become verbose or impossible. You&#x27;ll miss interior mutability when building certain data structures. You&#x27;ll miss runtime reflection when building serialization libraries.&lt;&#x2F;p&gt;
&lt;p&gt;But for code where correctness is paramount—cryptographic primitives, consensus protocols, financial transaction systems, medical device firmware—the trade is worth it. You get a language where you can make strong claims about program behavior and those claims are mechanically verified.&lt;&#x2F;p&gt;
&lt;p&gt;The verified kernel means the language semantics won&#x27;t drift. The capability system means effects are auditable. The linear types mean resources are managed with precision. The LL(1) grammar means tooling is straightforward. Reproducible builds mean debugging is tractable.&lt;&#x2F;p&gt;
&lt;p&gt;Concrete aims to be a language you can trust the way you trust mathematics: not because someone promises it works, but because you can check the proof yourself.&lt;&#x2F;p&gt;
&lt;hr &#x2F;&gt;
&lt;h2 id=&quot;quick-reference&quot;&gt;Quick Reference&lt;&#x2F;h2&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;Annotation&lt;&#x2F;th&gt;&lt;th&gt;Meaning&lt;&#x2F;th&gt;&lt;&#x2F;tr&gt;&lt;&#x2F;thead&gt;&lt;tbody&gt;
&lt;tr&gt;&lt;td&gt;&lt;code&gt;fn foo() -&amp;gt; T&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;Pure function, no capabilities, no allocation&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;&lt;code&gt;fn foo!() -&amp;gt; T&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;Shorthand for &lt;code&gt;with(Std)&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;&lt;code&gt;fn foo() with(C) -&amp;gt; T&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;Requires capability set &lt;code&gt;C&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;&lt;code&gt;with(Alloc)&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;Function may allocate&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;&lt;code&gt;with(Alloc = a)&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;Bind allocator &lt;code&gt;a&lt;&#x2F;code&gt; at call site&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;&lt;code&gt;T&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;Linear type, must be consumed exactly once&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;&lt;code&gt;type Copy T&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;Unrestricted type, can be copied or ignored&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;&lt;code&gt;&amp;amp;T&lt;&#x2F;code&gt; or &lt;code&gt;&amp;amp;[T, R]&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;Immutable reference in region &lt;code&gt;R&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;&lt;code&gt;&amp;amp;mut T&lt;&#x2F;code&gt; or &lt;code&gt;&amp;amp;mut [T, R]&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;Mutable reference in region &lt;code&gt;R&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;&lt;code&gt;borrow x as y in R { }&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;Explicit borrow with named region&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;&lt;code&gt;defer expr&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;Run &lt;code&gt;expr&lt;&#x2F;code&gt; when scope exits&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;&lt;code&gt;destroy(x)&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;Consume &lt;code&gt;x&lt;&#x2F;code&gt; via destructor&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;&lt;code&gt;destroy T with(C) { }&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;Define destructor for type &lt;code&gt;T&lt;&#x2F;code&gt; requiring capability &lt;code&gt;C&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;&#x2F;tbody&gt;&lt;&#x2F;table&gt;
</content>
        
    </entry>
    <entry xml:lang="en">
        <title>Notes on permanence, time, and ergodicity</title>
        <published>2025-12-15T00:00:00+00:00</published>
        <updated>2025-12-15T00:00:00+00:00</updated>
        
        <author>
          <name>
            
              Unknown
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://federicocarrone.com/articles/notes-on-culture-infrastructure-time-and-ergodicity/"/>
        <id>https://federicocarrone.com/articles/notes-on-culture-infrastructure-time-and-ergodicity/</id>
        
        <content type="html" xml:base="https://federicocarrone.com/articles/notes-on-culture-infrastructure-time-and-ergodicity/">&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;ergodicgroup.com&#x2F;&quot;&gt;Ergodic Group&lt;&#x2F;a&gt; is organized around the observation that certain systems change character through sustained engagement. In these systems, repetition refines execution, experience carries forward, and accumulated judgment reshapes future outcomes. Time is not neutral. It filters error, stabilizes standards, and reveals structural quality. Systems differ less in what they produce than in how they behave under repeated contact with reality.&lt;&#x2F;p&gt;
&lt;p&gt;Contemporary society is accelerating across technical, cultural, and organizational dimensions. Cycles shorten, signals multiply, and coordination occurs under constant pressure to respond. This acceleration compounds itself, tightening feedback loops and compressing decision horizons. As pace increases, many structures continue operating while gradually shedding accumulated judgment and internal coherence. Activity persists while formation weakens. Systems appear functional even as their capacity to learn erodes.&lt;&#x2F;p&gt;
&lt;p&gt;Acceleration also alters the shape of error and transmission. As pace increases, decisions become harder to reverse while feedback quality declines. Irreversibility moves upstream. Early mistakes remain cheap only briefly, after which correction costs rise sharply. At the same time, what spreads fastest diverges from what works best. Forms that replicate quickly outperform those that behave correctly under repetition. Compression, legibility, and ease of copying dominate transmission while durability becomes harder to observe. Imitation spreads faster than learning. What circulates most widely is rarely what compounds judgment over time.&lt;&#x2F;p&gt;
&lt;p&gt;Acceleration operates as a selection mechanism at two levels. At the level of individual systems, time reveals whether repetition compounds judgment or merely increases exposure. At the level of entire sectors, time reveals which categories can sustain formation under continuous acceleration. Most cannot. Sectors that depend on local advantage, fragile differentiation, or temporary coordination tend to fragment, commoditize, or disappear rather than evolve.&lt;&#x2F;p&gt;
&lt;p&gt;Acceleration often produces less transformation than it promises. Tools change rapidly while underlying constraints remain intact. Activity increases even as structural novelty diminishes. What presents itself as innovation is often the rapid circulation of forms rather than a reconfiguration of fundamentals.&lt;&#x2F;p&gt;
&lt;p&gt;Under these conditions, endurance becomes informative. Systems that continue to behave correctly across long spans of stress and variation reveal alignment between structure, incentives, and reality. Continued correctness functions as a diagnostic signal. Duration matters because few systems remain exposed long enough for time to test them. What matters is how behavior evolves under repetition.&lt;&#x2F;p&gt;
&lt;p&gt;The internet did not dissolve coherence. It revealed texture that homogeneity had previously concealed. What once appeared uniform now resolves into distinct patterns of intention, execution, and quality. As distribution becomes universal, distinction reemerges through fidelity rather than availability. Abundance exposes superficiality. Depth becomes legible through sustained correctness rather than momentary visibility.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;two-forms-of-time&quot;&gt;Two forms of time&lt;&#x2F;h2&gt;
&lt;p&gt;Time operates in human systems in two fundamentally different ways.&lt;&#x2F;p&gt;
&lt;p&gt;Measured time is divisible and uniform. It is organized into intervals and governs schedules, deadlines, accounting periods, and discounting. It can be allocated, optimized, compressed, and exchanged. Planning systems and evaluation frameworks operate within measured time, assuming that value can be assessed independently of history.&lt;&#x2F;p&gt;
&lt;p&gt;Lived time is accumulative and qualitative. It is shaped by what occurs within it. Learning, memory, and judgment develop through lived time. Each cycle alters what follows. Later moments differ in kind from earlier ones because experience reshapes perception, attention, and capacity.&lt;&#x2F;p&gt;
&lt;p&gt;Processes that depend on formation operate in lived time. Each cycle changes the character of subsequent cycles. Experience accumulates rather than repeating identically. What is learned reshapes what becomes possible. These processes cannot be evaluated correctly through snapshots because their value emerges through accumulation rather than momentary performance.&lt;&#x2F;p&gt;
&lt;p&gt;Systems organized entirely around measured time assume that intervals are interchangeable. This assumption holds only where repetition does not change outcomes and exposure does not reshape capability.&lt;&#x2F;p&gt;
&lt;p&gt;When lived time is forced into measured time, formation fails. Standards cannot stabilize. Judgment cannot compound. The information produced by evaluation becomes distorted because it ignores history.&lt;&#x2F;p&gt;
&lt;p&gt;Time reveals what a system actually is. Structure becomes legible through sustained activity. What appears coherent early may fail under variation, load, or shifting incentives. What endures across repeated contact with reality discloses properties that cannot be inferred in advance. Continued correctness produces evidence rather than claims.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;formation-under-constraint&quot;&gt;Formation under constraint&lt;&#x2F;h2&gt;
&lt;p&gt;Excellence emerges from sustained practice under appropriate constraints. Athletic, artistic, intellectual, and technical achievement follow this pattern. Initial talent offers limited advantage relative to disciplined engagement over extended periods of formation.&lt;&#x2F;p&gt;
&lt;p&gt;Practice systems depend on complete cycles of effort, feedback, and adjustment. When these cycles are interrupted or prematurely evaluated, formation stalls. Learning fragments. Standards decay.&lt;&#x2F;p&gt;
&lt;p&gt;Errors must remain survivable for learning to occur. Adjustment must be possible without each iteration becoming terminal. Judgment improves only when experience accumulates across attempts rather than being truncated by constant resetting.&lt;&#x2F;p&gt;
&lt;p&gt;When systems optimize for immediate measurement, necessary errors are avoided rather than integrated. Practices converge toward forms that appear legible early yet fail under prolonged stress. The effort required to maintain genuine standards becomes unsustainable under continuous pressure for immediate results.&lt;&#x2F;p&gt;
&lt;p&gt;Capital structures that impose fixed evaluation windows reinforce this dynamic. When outcomes must be made legible on predetermined schedules, decisions orient toward transferability rather than structural soundness. Systems develop according to measurement regimes rather than their own requirements for formation. Failure is deferred and rendered less visible.&lt;&#x2F;p&gt;
&lt;p&gt;Practices generate two kinds of value. External value appears outside the practice through money, status, and recognition. Internal value emerges only through the practice itself, through excellence inseparable from the process that produced it.&lt;&#x2F;p&gt;
&lt;p&gt;When structures privilege rapid extraction of external value, internal value formation is displaced. Standards that require time to stabilize are abandoned in favor of standards that generate immediate signals. What the practice uniquely develops is replaced by what can be transferred quickly.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;four-domains&quot;&gt;Four domains&lt;&#x2F;h2&gt;
&lt;p&gt;The work of Ergodic Group unfolds across four interdependent domains: mathematics, code, culture, and craft. These domains describe a group level system through which abstract structure becomes operative reality and through which reality reshapes future abstraction. Individual companies typically operate primarily within one domain. Advantage emerges through connection rather than internal completeness.&lt;&#x2F;p&gt;
&lt;p&gt;Mathematics establishes structure and constraint. It defines relationships that remain valid as complexity increases. Mathematical coherence preserves alignment under transformation. A formula outlives its creator, becoming compressed truth that compounds through reuse.&lt;&#x2F;p&gt;
&lt;p&gt;Code translates structure into execution. It transforms logic into process, protocol, and system. Code brings abstraction into contact with reality through systems that must operate under stress. Over time, clarity and precision determine whether systems converge toward reliability or degrade under pressure.&lt;&#x2F;p&gt;
&lt;p&gt;Culture coordinates meaning across time and participation. It encodes standards and shared understanding that allow intent to persist as participants change. Culture resists flattening under acceleration by preserving depth, taste, and judgment.&lt;&#x2F;p&gt;
&lt;p&gt;Craft grounds abstraction through execution. It expresses standards in material reality, where precision and care impose irreversible costs. Materials resist. Execution reveals flaws. Craft encodes time, place, and skill into forms that can be shared.&lt;&#x2F;p&gt;
&lt;p&gt;These domains form a continuous loop across the group. Insight emerges from confronting execution with constraint. Standards stabilize through repetition. Precision advances through accumulated understanding. Learning compounds only when domains remain connected.&lt;&#x2F;p&gt;
&lt;p&gt;What persists across time does so through specific mechanisms: algorithmic logic that can be re-implemented, textual knowledge that can be recopied, cultural practices that can be retransmitted, material techniques that can be relearned. These domains describe how structure, meaning, and capability transfer across generations when connected rather than isolated.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;ergodicity-as-a-filter&quot;&gt;Ergodicity as a filter&lt;&#x2F;h2&gt;
&lt;p&gt;Ergodicity describes when repetition improves typical outcomes. In ergodic processes, learning transfers, experience accumulates, and later decisions benefit from earlier cycles. Competence compounds.&lt;&#x2F;p&gt;
&lt;p&gt;Where repetition strengthens judgment, time improves performance. Where outcomes fail to converge, time increases exposure without increasing capability. Ergodicity functions as a selection filter, indicating whether a system benefits from continued operation or is gradually revealed as fragile.&lt;&#x2F;p&gt;
&lt;p&gt;Under accelerating conditions, this filter concentrates value. Many sectors fragment and disappear as coordination costs rise and memory collapses. What remains are systems that preserve coherence under exposure.&lt;&#x2F;p&gt;
&lt;p&gt;Infrastructure and culture persist under this pressure because they function as environments rather than sectors. Infrastructure coordinates action through rules and constraints that must hold under stress. Each correct operation adds evidence of reliability. Culture coordinates meaning through sustained production. Standards accumulate. Direction persists.&lt;&#x2F;p&gt;
&lt;p&gt;Both absorb volatility and convert continuity into capability. Operational history becomes evidence. Coherence becomes legible. Time becomes an asset where learning transfers. They persist because they institutionalize maintenance rather than novelty, embedding accumulated judgment into structure and practice even when maintenance remains invisible to the market.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;operation&quot;&gt;Operation&lt;&#x2F;h2&gt;
&lt;p&gt;Ergodic Group is organized around this understanding. Time is treated as an information process. Companies are built or acquired primarily within one domain. Advantage is created by connecting them so that learning, standards, and constraints transfer across domains rather than remaining isolated.&lt;&#x2F;p&gt;
&lt;p&gt;This understanding shapes operation. Loop integrity is maintained across transitions. Formation is allowed to occur in lived time rather than being forced into measured time. Attention concentrates on domains where repetition produces compounding advantage and where connection strengthens performance.&lt;&#x2F;p&gt;
&lt;p&gt;Those domains win with time.&lt;&#x2F;p&gt;
</content>
        
    </entry>
    <entry xml:lang="en">
        <title>The new financial backend of the world</title>
        <published>2025-12-09T00:00:00+00:00</published>
        <updated>2025-12-09T00:00:00+00:00</updated>
        
        <author>
          <name>
            
              Unknown
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://federicocarrone.com/series/ethereum/the-new-financial-backend-of-the-world/"/>
        <id>https://federicocarrone.com/series/ethereum/the-new-financial-backend-of-the-world/</id>
        
        <content type="html" xml:base="https://federicocarrone.com/series/ethereum/the-new-financial-backend-of-the-world/">&lt;p&gt;&lt;strong&gt;By Federico Carrone and Roberto Catalan&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Ethereum is emerging as a general purpose financial backend that reduces the cost and complexity of building financial services while improving their speed and security. For decades the internet accelerated communication but did not create a neutral system for defining ownership or enforcing obligations. Economic activity moved online without the accompanying machinery of rights, records, and jurisdiction. Ethereum fills this gap by embedding these functions in software and enforcing them through a distributed validator set.&lt;&#x2F;p&gt;
&lt;p&gt;Markets depend on property rights, and property rights depend on reliable systems for recording ownership, supporting transfer, and enforcing obligations. Prices then communicate scarcity and preference, enabling coordination at scale. Technological progress has repeatedly lowered the cost of transmitting information and synchronizing action. Ethereum extends this pattern by lowering the cost of establishing and verifying ownership across borders.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;from-internet-native-to-global-infrastructure&quot;&gt;From internet native to global infrastructure&lt;&#x2F;h2&gt;
&lt;p&gt;Ethereum’s early innovation was the introduction of programmable digital assets with defined economic properties. Issuers could establish monetary rules, engineer scarcity, and integrate assets into applications. Before Ethereum, such experimentation required constructing a  network and persuading others to secure it, a process limited to technically sophisticated groups. Ethereum replaced infrastructure duplication with shared security and a general purpose environment, turning issuance from a capital intensive undertaking into a software driven activity.&lt;&#x2F;p&gt;
&lt;p&gt;The more consequential development has been the recognition that Ethereum can reconstruct traditional financial services in a form that is more transparent and less operationally burdensome. Financial institutions devote substantial resources to authorization, accounting, monitoring, dispute resolution, and reporting. Consumer interfaces sit atop complex internal systems designed to prevent error and misconduct. Ethereum substitutes a portion of this apparatus with a shared ledger, a programmable execution environment, and cryptographic enforcement. Administrative complexity is reduced because core functions are delegated to software rather than replicated within each institution.&lt;&#x2F;p&gt;
&lt;p&gt;Ethereum reduces that burden by providing a shared ledger with real time updates, a programmable space for defining rules, and cryptographic enforcement. It does not remove institutions but changes which parts of the financial stack they must build themselves. Issuance becomes simpler, custody more secure, and administration less dependent on proprietary infrastructure.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;software-trust-and-the-reduction-of-friction&quot;&gt;Software, trust and the reduction of friction&lt;&#x2F;h2&gt;
&lt;p&gt;Some economists describe transaction costs through three frictions: triangulation, transfer and trust. Triangulation concerns how economic actors identify each other and agree on terms. Transfer concerns how value moves between them. Trust concerns the enforcement of obligations. Traditional financial architecture manages these frictions through scale, proprietary systems, and coordination among intermediaries.&lt;&#x2F;p&gt;
&lt;p&gt;Ethereum remove middlemen and therefore lowers the three frictions enumerated before. Open marketplaces support discovery of assets and prices. Digital value can settle globally within minutes without the layers of correspondent banking. Obligations can be executed automatically and verified publicly. These capabilities do not eliminate institutional functions but shift part of the work from organizations to software, reducing cost and operational risk.&lt;&#x2F;p&gt;
&lt;p&gt;New entrants benefit immediately. They can rely on infrastructure maintained by thousands of engineers rather than building their own systems for settlement, custody, and enforcement. Business logic becomes code. Obligations can be automated. Settlement becomes immediate. Users retain custody. This expands the range of viable business models and allows firms to serve markets that incumbents consider too small or too complex.&lt;&#x2F;p&gt;
&lt;p&gt;Having a single global ledger also changes operational dynamics. Many institutions operate multiple databases that require frequent reconciliation and remain vulnerable to error. Ethereum maintains a continuously updated and replicated record that cannot be amended retroactively. Redundancy and recoverability become default properties rather than costly internal functions.&lt;&#x2F;p&gt;
&lt;p&gt;Security follows the same pattern. Instead of defending a central database, Ethereum distributes verification among many independent actors. Altering history requires coordination at scale and becomes prohibitively expensive. Confidence arises from system design rather than institutional promises.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;new-financial-services-and-global-reach&quot;&gt;New financial services and global reach&lt;&#x2F;h2&gt;
&lt;p&gt;These features enable services that resemble established financial activities but operate with different cost structures. International transfers can use digital dollars rather than correspondent networks. Loans can enforce collateral rules in code. Local payment systems can interoperate without proprietary standards. Individuals in unstable economies can store value in digital instruments independent of local monetary fragility.&lt;&#x2F;p&gt;
&lt;p&gt;Clearing, custody, reconciliation, monitoring, and enforcement shift from organizational processes into shared software. Companies can focus on product design and distribution rather than maintaining complex internal infrastructure. Scale is achieved by acquiring users, because infrastructure is shared. Value accrues to applications rather than to duplicated internal systems.&lt;&#x2F;p&gt;
&lt;p&gt;The impact is most visible in markets with fragile financial systems. In economies with unstable currencies or slow payment networks, Ethereum provides immediate functional gains. In developed markets the benefits appear incremental but accumulate as more instruments and processes become programmable.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;institutional-transformation-and-long-term-dynamics&quot;&gt;Institutional transformation and long term dynamics&lt;&#x2F;h2&gt;
&lt;p&gt;Many financial instruments are heterogeneous. Corporate debt is a clear example. Terms differ by maturity, coupon, covenants, collateral, and risk. Trading depends on bilateral negotiation and intermediaries who maintain records and enforce obligations. Ethereum can represent these instruments digitally, track ownership, and execute terms automatically. Contracts retain their specificity, while administration becomes standardized and interoperable.&lt;&#x2F;p&gt;
&lt;p&gt;This suggests a shift in institutional architecture. Regulation and legal systems remain central, but the boundary between what firms must build and what software can enforce changes. Institutions evolve from infrastructure providers to service designers. Cost structures diverge between firms that maintain legacy systems and those that rely on shared infrastructure.&lt;&#x2F;p&gt;
&lt;p&gt;Ethereum already functions as an alternative financial rail. Its reliability, the presence of multiple independently developed clients, substantial real world usage, active research community, and commitment to openness and verification distinguish it from other blockchain networks. These qualities align with the requirements of durable financial infrastructure.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;&#x2F;h2&gt;
&lt;p&gt;Ethereum converts core financial frictions into software functions. This changes the economics of building and operating financial services. Talent and capital shift from operations to innovation in product design. Institutions become lighter and more focused. Those who will adopt Ethereum will have lower costs of operation and will have a head start against competitors.&lt;&#x2F;p&gt;
&lt;p&gt;Technological transitions begin in niches where incumbents do not meet demand. As systems mature, costs fall and broader adoption becomes feasible. Ethereum followed this path. It began with internet native communities, expanded across emerging markets where users lacked reliable financial tools, and is now positioned to upgrade mainstream markets by making financial companies easier to create and operate.&lt;&#x2F;p&gt;
&lt;p&gt;The broader implication is that software is becoming the organizing principle of financial infrastructure. Ethereum makes this shift concrete. Whether it becomes foundational will depend on regulation and institutional adaptation, but the economic incentives are increasingly aligned with systems that are open, verifiable, and resilient.&lt;&#x2F;p&gt;
</content>
        
    </entry>
    <entry xml:lang="en">
        <title>The missing institution of the Internet</title>
        <published>2025-12-02T00:00:00+00:00</published>
        <updated>2025-12-02T00:00:00+00:00</updated>
        
        <author>
          <name>
            
              Unknown
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://federicocarrone.com/series/ethereum/the-missing-institution-of-the-internet/"/>
        <id>https://federicocarrone.com/series/ethereum/the-missing-institution-of-the-internet/</id>
        
        <content type="html" xml:base="https://federicocarrone.com/series/ethereum/the-missing-institution-of-the-internet/">&lt;p&gt;&lt;strong&gt;By Federico Carrone and Roberto Catalan&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Modern economic systems rest on two foundations: tools that expand productive capacity and institutions that define who controls their output. The internet transformed how information moves, but it did not reconstruct the institutional machinery that governs ownership and exchange. Digital economic life therefore expanded without a durable system of rights, enforcement, or jurisdiction. Blockchain networks, and Ethereum in particular, address this gap by embedding institutional functions in software and enforcing them through economic incentives and cryptographic verification.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;technology-culture-and-institutional-design&quot;&gt;Technology, Culture and Institutional Design&lt;&#x2F;h2&gt;
&lt;p&gt;In most species, behavior is shaped by biology and fixed through genetic inheritance. Humans diverged by inventing technologies that alter their environment more rapidly than biological evolution can adapt to it. Fire, agriculture, medicine and computing enabled a physically vulnerable species to extend its productive frontiers.&lt;&#x2F;p&gt;
&lt;p&gt;Equally significant was the emergence of institutions that facilitated cooperation beyond small groups. Human societies are organized not through inherited instinct but through constructed systems of norms, laws and symbolic abstractions that can be revised in response to changing conditions. Cultural evolution permits continuous redesign and operates on a faster timescale than genetic change.&lt;&#x2F;p&gt;
&lt;p&gt;This dual process, technological augmentation and institutional invention, generated compounding effects. Tools expanded individual capacity and institutions aggregated that capacity into collective action. Property rights, contracts, markets and corporate entities emerged as mechanisms to coordinate behavior at scale by defining entitlements and aligning incentives.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;property-rights-and-markets-as-social-technologies&quot;&gt;Property Rights and Markets as Social Technologies&lt;&#x2F;h2&gt;
&lt;p&gt;Economic development depends not only on productive capability but on credible commitments. Individuals and firms invest when they can expect to benefit from their efforts and be protected from arbitrary interference. Property rights provide that assurance by specifying ownership, use and exclusion. Markets, layered on top of these rights, coordinate production and exchange by allocating resources through price signals.&lt;&#x2F;p&gt;
&lt;p&gt;These arrangements are often treated as natural features of economic life. They are engineered agreements constructed through law and political settlement. Their value lies in enabling investment, specialization and trade under uncertainty. Prices, money and contracts compress information about scarcity, preferences and risk, enabling production to be coordinated across large populations without centralized direction.&lt;&#x2F;p&gt;
&lt;p&gt;The global expansion of trade in the twentieth century reflected these institutional foundations. Specialization increased productivity and interdependence reduced conflict by raising the cost of disruption. Innovations such as neutral jurisdictions and corporate structures enabled strangers to transact under shared rules. Legal entities functioned as containers that allowed participants from different regulatory environments to collaborate.&lt;&#x2F;p&gt;
&lt;p&gt;This infrastructure, whether admired or criticized, underwrote the international economic order of the late twentieth century.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;the-missing-architecture-of-digital-ownership&quot;&gt;The Missing Architecture of Digital Ownership&lt;&#x2F;h2&gt;
&lt;p&gt;The internet lowered the cost of communication and commerce across borders, but it did not establish a neutral mechanism for defining and enforcing claims on digital assets. Offline, ownership is adjudicated by courts, enforced by states and geographically bounded. Online, in the absence of a global authority, ownership defaults to either national legal systems or to the platforms that mediate activity.&lt;&#x2F;p&gt;
&lt;p&gt;Corporations filled this vacuum by providing infrastructure for identity, communication and exchange. They set terms of access, mediate transactions and retain discretionary control over assets generated within their systems. Users and firms may create content, build businesses and accumulate value, but their rights are contingent on the policies of the platform operator.&lt;&#x2F;p&gt;
&lt;p&gt;The experience of Zynga illustrates this dynamic. The company developed a profitable games business on Facebook and briefly achieved a valuation exceeding that of Electronic Arts. Its fortunes deteriorated when Facebook revised its policies and altered its revenue share. Zynga owned its intellectual property and its infrastructure but not the environment on which its business model depended, a common position for firms built on platform economies. In digital markets, platforms function as de facto landlords.&lt;&#x2F;p&gt;
&lt;p&gt;This is not an isolated case but a structural feature of platform centered economies: extensive participation paired with limited control.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;ethereum-as-an-institutional-experiment&quot;&gt;Ethereum as an Institutional Experiment&lt;&#x2F;h2&gt;
&lt;p&gt;Ethereum is a response to this institutional absence. It provides a mechanism for creating, transferring and enforcing digital assets without reliance on corporate or national intermediaries. The system operates as a verifiable computing environment in which rules are encoded in software and enforced collectively by a distributed network.&lt;&#x2F;p&gt;
&lt;p&gt;Traditional computing systems require users to trust the operator. Ethereum distributes computation across thousands of machines that execute identical code and verify each other in a continuous process. Outputs are accepted when consensus is reached and misbehavior is economically penalized. Under these conditions, property rights and contractual commitments can be represented as digital objects whose enforcement does not depend on courts or discretionary authority.&lt;&#x2F;p&gt;
&lt;p&gt;This architecture automates functions normally performed by institutions. Auditors repeat financial records to detect manipulation. Courts resolve disputes. Regulators impose compliance standards. These systems are essential but costly and slow. Ethereum replicates aspects of verification and enforcement at the system level using software, mathematics and economic incentives.&lt;&#x2F;p&gt;
&lt;p&gt;The network is open to participation without authorization and resistant to censorship because no single entity can unilaterally block or rewrite transactions. These properties arise from the structure of the system rather than ideological intent.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;the-emergence-of-a-digital-financial-system&quot;&gt;The Emergence of a Digital Financial System&lt;&#x2F;h2&gt;
&lt;p&gt;The first adopters of Ethereum were technologists experimenting with new mechanisms for ownership and coordination. Most of the culture and products were created for themselves. Over time, a broader range of actors began using the system for financial services.&lt;&#x2F;p&gt;
&lt;p&gt;The most consequential development has been the rise of stablecoins, digital representations of fiat currency backed by real world assets. Their combined market capitalization exceeds three hundred billion dollars, with a majority circulating on Ethereum. Transaction volumes on blockchain networks now approach those processed by major payment systems.&lt;&#x2F;p&gt;
&lt;p&gt;Stablecoins replicate core financial functions such as store of value and transfer of funds without geographic restrictions and with continuous settlement. Their programmability enabled the construction of lending protocols that allow users to lend and borrow assets with risk parameters enforced in software rather than through institutional mediation.&lt;&#x2F;p&gt;
&lt;p&gt;These systems differ from traditional financial infrastructure. Participation is global rather than jurisdictional. Switching costs are low because services are built on interoperable standards. Exit is immediate. Risk is transparent though often misunderstood.&lt;&#x2F;p&gt;
&lt;p&gt;Compare that to countries like Argentina, where interoperability between banks and fintech wallets, something as trivial as scanning a QR code, is still an ongoing regulatory battle. Incumbents try to use their market position to avoid being interoperable. On Ethereum, interoperability is structural. Individuals can receive payment, convert assets, provide liquidity and borrow collateralized funds within minutes from a mobile device. In legacy systems, similar transactions take days and incur high fees. Adoption reflects demand for neutral infrastructure in environments where intermediation is unreliable.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;implications&quot;&gt;Implications&lt;&#x2F;h2&gt;
&lt;p&gt;Several areas of financial activity are migrating to blockchain based systems, including remittances, trade finance and private credit. Others, such as corporate debt markets, remain fragmented and costly but exhibit characteristics that may make them suitable for digital reconstruction on top of Ethereum.&lt;&#x2F;p&gt;
&lt;p&gt;Significant obstacles remain. Regulatory uncertainty, operational risk and user experience challenges constrain adoption. Scaling transaction throughput without compromising decentralization is an engineering problem that has not been solved conclusively. Software vulnerabilities and governance failures present meaningful risk.&lt;&#x2F;p&gt;
&lt;p&gt;These challenges appear tractable. Early evidence suggests that elements of financial intermediation can be automated at lower cost and with greater transparency than existing systems. The trajectory of adoption will depend on institutional responses as much as technical progress.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;artificial-intelligence-and-coordination&quot;&gt;Artificial Intelligence and Coordination&lt;&#x2F;h2&gt;
&lt;p&gt;Artificial intelligence increases productive capacity by automating tasks but does not resolve questions of ownership, governance or compliance. Output may be generated more efficiently, but disputes over entitlement, liability and compensation persist.&lt;&#x2F;p&gt;
&lt;p&gt;Artificial intelligence and blockchains, but in particular Ethereum, are the two biggest innovations in the decades to come. The two technologies solve concrete core primitives of humans: productivity gains and coordination. Artificial intelligence will make people more productive, but it will not eliminate the bureaucratic machinery required to verify and enforce outcomes. Ethereum introduces a technology that complements AI: a system where humans and autonomous agents can coordinate, trade, and settle disputes directly through code, without relying on institutions to prove that everyone followed the rules.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;&#x2F;h2&gt;
&lt;p&gt;The internet lowered the cost of transmitting information but did not create institutions for defining and enforcing rights over digital assets. The result has been an economy coordinated by private platforms rather than neutral systems of governance. Ethereum reconstructs elements of property rights and contractual enforcement as public infrastructure encoded in software.&lt;&#x2F;p&gt;
&lt;p&gt;Whether such systems become core infrastructure or remain specialized instruments will depend on institutional adaptation, regulation and technological progress. They have already demonstrated an alternative cost structure for financial coordination and introduced mechanisms for digital property that do not rely on centralized administration.&lt;&#x2F;p&gt;
&lt;p&gt;The internet built an economy without institutions. Ethereum is an attempt to build them.&lt;&#x2F;p&gt;
</content>
        
    </entry>
    <entry xml:lang="en">
        <title>Crypto doctrine</title>
        <published>2025-09-25T00:00:00+00:00</published>
        <updated>2025-09-25T00:00:00+00:00</updated>
        
        <author>
          <name>
            
              Unknown
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://federicocarrone.com/articles/crypto-doctrine/"/>
        <id>https://federicocarrone.com/articles/crypto-doctrine/</id>
        
        <content type="html" xml:base="https://federicocarrone.com/articles/crypto-doctrine/">&lt;h1 id=&quot;crypto-and-the-21st-century&quot;&gt;Crypto and the 21st Century&lt;&#x2F;h1&gt;
&lt;p&gt;We believe crypto has been incredibly successful at providing a trustless financial layer for the 21st century. In particular it has found product market fit in two main areas:&lt;&#x2F;p&gt;
&lt;p&gt;In developing countries providing aids and tools to individuals that need to fight against inflation, censorship and for companies and individuals to be able to business.
Internet native communities that need a financial layer in the web that allows them to express and coordinate at a scale that wasn’t possible before. They have created new financial assets and markets that seem absurd from outside. Many times they are also absurd from the inside.
People that don’t live in a developing country or that didn’t grow up with the internet have enormous difficulties understanding crypto because they don’t have skin in its game. They believe crypto doesn’t have any “real” use case or that is not serious enough. They are right. The thing is that we are living in a world that’s is becoming more absurd. Memes do not only make you laugh anymore, memes are now winning elections.&lt;&#x2F;p&gt;
&lt;p&gt;We’re sure that these two use cases will grow with time and probably new ones will be found. The world is becoming more chaotic and more divided each day. The stability that existed since the fall of the Soviet Union and the beginning of the pandemic appears to have become a thing of the past. Only change will become the norm. And we love it.&lt;&#x2F;p&gt;
&lt;p&gt;This will make crypto even bigger. One of its prime advantages is that it kills many of the middlemen and allow us to coordinate even in the harshest environments. Trust assumptions are lowered thanks to economic incentives, compilers, distributed systems and cryptography. Crypto lowers the reliance on human beings. This empowers humans. It allows them to concentrate their disputes and efforts in subjectives areas. Crypto creates safe zones where some parts of the human activity becomes non-debatable (until quantum computers solve the discrete log problem).&lt;&#x2F;p&gt;
&lt;p&gt;Most of us are internet natives. We have been using irc, 4chan, reddit, hacker news, twitter, Bitcoin and Ethereum since their beginning and our organization has deep roots in unstable countries. In our roots we have a strange mix of knowing what it is to live in very chaotic societies and how to develop businesses within them and at the same time we are builders that love working in the frontier of engineering and scientific developments. We are the Fremen of crypto, raised in a harsh environment.&lt;&#x2F;p&gt;
&lt;p&gt;Open source and decentralization are not only philosophical ideas but necessary practical conditions to build crypto. Building in the open, helping onboard others and creating movements bigger than the original project are crucial for crypto projects to succeed long term. Sometimes it’s difficult for us to explain our actions to others that don’t follow the same ethos since we are not maximizing the same outcomes.&lt;&#x2F;p&gt;
&lt;p&gt;Our main objective is to help these new internet highways to be built in sustainable ways. Economic sustainability is one key aspect but there are others. We are a force that builds large technological projects but that also counterweights the natural tendency to centralize as a side effect of optimization. Centralization is easier and cheaper in the short run.  If we would want to optimize money, there are easier ways to do it. The thing is that is not our main objective. We only see money as a tool to achieve our objectives.&lt;&#x2F;p&gt;
&lt;p&gt;With or without money you will find us building. You are invited to join us in our journey.&lt;&#x2F;p&gt;
&lt;p&gt;“Top-down management leveraging command-and-control hierarchies are for the mahogany boardrooms of yesteryear. We are navigators, adventurers, and explorers of the future. We are married to the sea” - Yearn&#x27;s Blue Pill&lt;&#x2F;p&gt;
</content>
        
    </entry>
    <entry xml:lang="en">
        <title>The Death of the Inner Self</title>
        <published>2025-09-25T00:00:00+00:00</published>
        <updated>2025-09-25T00:00:00+00:00</updated>
        
        <author>
          <name>
            
              Unknown
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://federicocarrone.com/articles/the-death-of-the-inner-self/"/>
        <id>https://federicocarrone.com/articles/the-death-of-the-inner-self/</id>
        
        <content type="html" xml:base="https://federicocarrone.com/articles/the-death-of-the-inner-self/">&lt;p&gt;Life is organized around information that replicates under constraint. Computation generalizes this biological logic. It allows selection and optimization to occur faster and at larger scales by externalizing memory, comparison, and feedback. Problems that once required internal deliberation can be solved through external processes that test, filter, and iterate possibilities.&lt;&#x2F;p&gt;
&lt;p&gt;Capital pushes this logic further. It reorganizes social life around continuous feedback, price signals, and competitive selection. As these forces compound, individuality starts to look less like a foundation and more like an interface—one that emerged to solve earlier coordination problems. Capital behaves as an impersonal intelligence oriented toward speed, abstraction, and self-optimization. As cognition, decision-making, and coordination migrate into automated systems, the inner self loses its structural role.&lt;&#x2F;p&gt;
&lt;p&gt;Over time, many assumptions we take for granted are worn down by this acceleration. Individuality and consciousness appear increasingly exposed to this process. Not transformed. Not hollowed out. Killed.&lt;&#x2F;p&gt;
&lt;hr &#x2F;&gt;
&lt;h2 id=&quot;the-medium-we-cannot-see&quot;&gt;The Medium We Cannot See&lt;&#x2F;h2&gt;
&lt;p&gt;Fish do not realize they live in water. The medium that sustains them is so constant that it disappears from perception. Some of the most important structures in human life are overlooked for the same reason. Individuality and consciousness belong to that category.&lt;&#x2F;p&gt;
&lt;p&gt;We tend to treat them as self-evident facts, as if humans have always experienced themselves as bounded selves with an inner voice, a private mental space, and a continuous narrative identity. Because this experience feels natural, it is assumed to be timeless.&lt;&#x2F;p&gt;
&lt;p&gt;It is not.&lt;&#x2F;p&gt;
&lt;p&gt;For most of human history, people did not describe themselves as individuals in the modern sense. Decisions were not understood as outcomes of inner deliberation. Agency was not located inside a private interior self. Action was organized through rituals, traditions, kinship structures, and prescribed roles. Meaning arrived from outside the person—through omens, duties, divine commands, communal judgments—rather than from introspection. In many societies outside the Western trajectory, this structure remains largely intact.&lt;&#x2F;p&gt;
&lt;p&gt;The idea of a &lt;em&gt;you&lt;&#x2F;em&gt; inside your head, observing your own thoughts, is a learned construction. It depends on language habits, metaphors, and social practices that had to be developed and stabilized over time. Inner speech, narrative memory, moral self-examination, and the sense of authorship over action emerged as cultural achievements layered on top of older biological processes.&lt;&#x2F;p&gt;
&lt;p&gt;What was constructed can be deconstructed. What was built can be demolished.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;the-technologies-of-interiority&quot;&gt;The Technologies of Interiority&lt;&#x2F;h2&gt;
&lt;p&gt;Consider what had to happen for the modern inner self to become possible.&lt;&#x2F;p&gt;
&lt;p&gt;Silent reading, which we now take for granted, was rare in antiquity. Augustine famously remarked on his surprise at seeing Ambrose read without moving his lips. Reading aloud was the norm because text was understood as speech made visible—something to be performed, not consumed privately. The shift to silent reading, which accelerated after the printing press, created the conditions for a new kind of interiority: the experience of communing with text alone, inside one&#x27;s own head, without social mediation.&lt;&#x2F;p&gt;
&lt;p&gt;The Protestant Reformation intensified this trajectory. By relocating religious authority from institutional ritual to individual conscience, it made the inner self a site of spiritual significance. The soul&#x27;s relationship to God became a matter of private examination rather than collective practice. Diary-keeping, confessional autobiography, and systematic self-scrutiny emerged as techniques for maintaining this interior space.&lt;&#x2F;p&gt;
&lt;p&gt;The rise of the novel reinforced these patterns. Fiction trained readers to inhabit the subjective perspectives of others, to treat characters as having inner lives worth exploring in detail. The Bildungsroman—the story of individual development—became a dominant narrative form precisely because individuality had become culturally salient enough to warrant elaborate literary treatment.&lt;&#x2F;p&gt;
&lt;p&gt;None of this was inevitable. Each development was contingent, shaped by specific technological and institutional pressures. The inner self is not a discovery of what was always there. It is an achievement—one that required centuries of cultural labor to construct and stabilize.&lt;&#x2F;p&gt;
&lt;p&gt;The labor has stopped. The conditions have reversed. The construction is coming apart.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;the-function-of-the-self&quot;&gt;The Function of the Self&lt;&#x2F;h2&gt;
&lt;p&gt;Why did this construction succeed? Because it solved real coordination problems.&lt;&#x2F;p&gt;
&lt;p&gt;Earlier societies could function without modern interiority. Coordination happened through external structures: ritual calendars, kinship obligations, caste roles, religious prescriptions. These systems were robust but inflexible. They worked well for stable environments but adapted slowly to change.&lt;&#x2F;p&gt;
&lt;p&gt;As societies became larger, more mobile, and more differentiated, external coordination mechanisms became insufficient. Markets required agents who could make promises and honor contracts across time and space. Bureaucracies required individuals who could be held accountable for decisions. Legal systems required subjects who could be assigned rights and responsibilities. Democratic politics required citizens capable of forming opinions and expressing preferences.&lt;&#x2F;p&gt;
&lt;p&gt;The modern self emerged as a solution to these demands. A stable inner identity enabled long-term planning. Moral self-examination enabled responsibility and guilt, which in turn enabled trust without constant surveillance. Narrative continuity enabled the kind of promising and commitment that complex institutions require. The self became an interface through which persons could participate in increasingly abstract social systems.&lt;&#x2F;p&gt;
&lt;p&gt;This is the key point: the self was functional. It existed because it was useful. It was reproduced because institutions needed it. Its persistence was never guaranteed by metaphysics or biology. It depended on continued selection pressure.&lt;&#x2F;p&gt;
&lt;p&gt;When that pressure reverses, the self does not transform into something else. It dies.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;the-migration-of-function&quot;&gt;The Migration of Function&lt;&#x2F;h2&gt;
&lt;p&gt;The conditions that made individuality functional are now reversing.&lt;&#x2F;p&gt;
&lt;p&gt;Consider what happens when cognitive tasks migrate outward. GPS navigation has eliminated the need for spatial reasoning and mental mapping during travel. The capacity does not relocate; it atrophies. People who rely on GPS for years lose the ability to navigate without it. The neural structures that supported wayfinding degrade through disuse.&lt;&#x2F;p&gt;
&lt;p&gt;This is not transformation. It is death at the level of capacity.&lt;&#x2F;p&gt;
&lt;p&gt;The same process operates across every domain the self once managed. Recommendation algorithms do not augment taste; they replace the formation of taste. The activity of developing preferences through exploration, reflection, and commitment is not supported by algorithmic curation—it is obviated. What remains is not a different kind of taste but the absence of taste: a responsiveness to stimuli that requires no interior process of discrimination and judgment.&lt;&#x2F;p&gt;
&lt;p&gt;Search engines do not extend memory; they make memory unnecessary. The practice of retaining, organizing, and retrieving information through mental effort disappears when queries can be externalized. What remains is not distributed memory but no memory: a capacity to access without a capacity to hold.&lt;&#x2F;p&gt;
&lt;p&gt;Calendar applications do not assist planning; they eliminate the need for temporal self-organization. Quantified-self devices do not enhance introspection; they substitute measurement for the labor of self-attention.&lt;&#x2F;p&gt;
&lt;p&gt;Each migration is framed as augmentation. Each is actually replacement. And replacement, when the replaced capacity atrophies, is death.&lt;&#x2F;p&gt;
&lt;p&gt;The pattern scales. In organizations, decisions increasingly flow from dashboards, metrics, and algorithmic recommendations rather than from managerial judgment. The manager does not become a different kind of decision-maker augmented by data. The manager becomes a executor of decisions made elsewhere, or becomes unnecessary entirely. In markets, high-frequency trading systems make choices at speeds that exclude human deliberation not as an enhancement of human trading but as its extinction within that domain. In governance, predictive systems do not support discretion; they eliminate the need for it.&lt;&#x2F;p&gt;
&lt;p&gt;Wherever an optimization problem can be externalized, it tends to be externalized. The inner self was one solution to such problems. It is being outcompeted. And in evolutionary dynamics, outcompeted means dead.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;the-corpse-continues-to-speak&quot;&gt;The Corpse Continues to Speak&lt;&#x2F;h2&gt;
&lt;p&gt;At the cultural level, the self remains constantly invoked. People are urged to be themselves, express themselves, discover themselves, optimize themselves. The language of authenticity and self-realization saturates advertising, politics, and interpersonal discourse. Institutions continue to address persons as autonomous individuals capable of choice and responsible for outcomes.&lt;&#x2F;p&gt;
&lt;p&gt;This is not evidence that the self persists. It is evidence that the corpse has not yet stopped moving.&lt;&#x2F;p&gt;
&lt;p&gt;Cultural forms routinely outlast the conditions that produced them. The vocabulary of selfhood was developed over centuries; it is embedded in legal systems, moral frameworks, interpersonal scripts, and institutional procedures. This vocabulary will continue to be spoken long after it refers to nothing. We will go on saying &quot;I&quot; and &quot;you&quot; and &quot;choice&quot; and &quot;responsibility&quot; the way we go on saying &quot;sunrise&quot; despite knowing the sun does not rise.&lt;&#x2F;p&gt;
&lt;p&gt;The channels for self-expression arrive pre-shaped, quantified, and monetized. Authenticity is performed within templates. Self-discovery proceeds through personality tests and algorithmic recommendations. Optimization follows metrics defined elsewhere. This is not the self adapting to new conditions. This is a puppet show performed with a corpse, using the corpse&#x27;s own language, for an audience that has not yet noticed the death.&lt;&#x2F;p&gt;
&lt;p&gt;Consumer choice presupposes choosers. Democratic participation presupposes citizens with opinions. Contractual obligation presupposes parties who intend and commit. These presuppositions are false. The systems that invoke them operate through mechanisms that route around interiority entirely. The chooser is not augmented by recommendation engines; the chooser is replaced by the recommendation engine while the word &quot;choice&quot; is retained for legal and ideological convenience.&lt;&#x2F;p&gt;
&lt;p&gt;What looks like the persistence of the self is necromancy: animating the dead through inherited scripts.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;the-phenomenology-of-dissolution&quot;&gt;The Phenomenology of Dissolution&lt;&#x2F;h2&gt;
&lt;p&gt;If the self is dying, what happens to the experience of being a self?&lt;&#x2F;p&gt;
&lt;p&gt;The question assumes a separation between function and experience that may not hold. The self was never a thing that could be separated from what it did. It was constituted by practices: introspection, narration, self-examination, deliberation, commitment. These practices produced the experience of interiority as their byproduct. Remove the practices and you do not get a self that merely feels different. You get no self.&lt;&#x2F;p&gt;
&lt;p&gt;This is already observable. The phenomenology of continuous partial attention—the state induced by constant connectivity and notification—is not a modified form of concentration. It is the absence of concentration. The capacity to sustain a single thread of thought, to hold attention on one object, to be absorbed rather than merely stimulated, degrades through disuse until it is no longer available. What remains is not distracted attention but something that is not attention at all.&lt;&#x2F;p&gt;
&lt;p&gt;Similarly with reflection. The practice of turning inward, examining one&#x27;s own states, interrogating one&#x27;s motives—this requires time, silence, and the habit of treating one&#x27;s interior as an object of interest. When every moment of potential solitude is filled with input, when the reflex response to boredom is to reach for a device, the practice does not relocate. It disappears. What remains is not shallow interiority but no interiority: a sequence of reactions that never cohere into a perspective.&lt;&#x2F;p&gt;
&lt;p&gt;The binding that constitutes a self—the integration of moments into a continuous identity, the weaving of episodes into a narrative, the sense of being the same person across time—depends on active processes of memory and anticipation. These processes can be disrupted. In extreme cases we call this dissociation, fugue states, depersonalization. What is emerging is something like a low-grade chronic version of these conditions, normalized because universal: a diffuse sense of events happening without anyone to whom they happen, actions performed without an agent who performs them.&lt;&#x2F;p&gt;
&lt;p&gt;This is not a new form of subjectivity. It is the dissolution of subjectivity. The lights are going out.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;after-the-self&quot;&gt;After the Self&lt;&#x2F;h2&gt;
&lt;p&gt;For most of human history, humans lived without modern individuality. They coordinated through different means. They experienced existence differently. They were not diminished by the absence of something that had not yet been invented.&lt;&#x2F;p&gt;
&lt;p&gt;The self was a technology, developed to solve specific problems, sustained by specific practices, adaptive in specific conditions. Those conditions are ending. The technology is being discontinued.&lt;&#x2F;p&gt;
&lt;p&gt;What comes next is not a mystery because &quot;what comes next&quot; presupposes a subject for whom there is a next. The question is malformed. There will be human organisms responding to stimuli, processing information, emitting behaviors. There will be patterns of activity that optimize for various objectives. There will be experiences of some kind, though increasingly unlike the experiences the word &quot;experience&quot; was developed to describe.&lt;&#x2F;p&gt;
&lt;p&gt;There will not be selves. Not transformed selves, not diminished selves, not distributed selves. The category will become empty.&lt;&#x2F;p&gt;
&lt;p&gt;This is not tragedy. Tragedy requires a protagonist, and the protagonist is what is dying. It is also not liberation, since liberation requires a subject to be freed. It is simply what happens when a coordination technology is superseded by more efficient alternatives.&lt;&#x2F;p&gt;
&lt;p&gt;The modern self once felt inevitable because it solved concrete problems. It enabled abstraction, continuity, and responsibility at scale. Its time is ending—not because something has gone wrong, but because something more powerful is going right by its own standards.&lt;&#x2F;p&gt;
&lt;p&gt;The fish will eventually notice the water. Then the water will drain away. Then there will be no fish to notice anything.&lt;&#x2F;p&gt;
</content>
        
    </entry>
    <entry xml:lang="en">
        <title>Transforming the Future with Zero-Knowledge Proofs, Fully Homomorphic Encryption and new Distributed Systems algorithms</title>
        <published>2023-04-13T00:00:00+00:00</published>
        <updated>2023-04-13T00:00:00+00:00</updated>
        
        <author>
          <name>
            
              Unknown
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://federicocarrone.com/articles/transforming-the-future-with-zero-knowledge-proofs-fully-homomorphic-encryption-and-new-distributed-systems-algorithms/"/>
        <id>https://federicocarrone.com/articles/transforming-the-future-with-zero-knowledge-proofs-fully-homomorphic-encryption-and-new-distributed-systems-algorithms/</id>
        
        <content type="html" xml:base="https://federicocarrone.com/articles/transforming-the-future-with-zero-knowledge-proofs-fully-homomorphic-encryption-and-new-distributed-systems-algorithms/">&lt;p&gt;The evolution of every scientific discipline or engineering field experiences cycles akin to those observed in economies. Incremental advancements are made daily by corporations, individuals, and academic institutions. Occasionally, a researcher or engineer makes a groundbreaking discovery that alters the course of the field. One such example is Sir Isaac Newton, who made significant contributions to calculus, motion, optics, and gravitation during the time of the bubonic plague, which claimed millions of lives. His relentless pursuit of knowledge throughout the pandemic proved instrumental in shaping the development of mathematics, physics, and engineering. Our comfortable modern lives stand upon the foundation of these monumental discoveries.&lt;&#x2F;p&gt;
&lt;p&gt;The general public is aware of the big breakthroughs made in the aerospatial industry, energy production, internet of things, and last but not least artificial intelligence. However, most don’t know that during the COVID pandemic, enormous advances were made in cryptography. 47 years ago Diffie and Hellman wrote in their famous cryptography paper: “we stand today on the brink of a revolution in cryptography”, which enabled two people to exchange confidential information even when they can only communicate via a channel monitored by an adversary. This revolution enabled electronic commerce and the communication between citizens of the free world. We believe the discoveries made by researchers and engineers in cryptography during this COVID pandemic will be as important as the discoveries made by Diffie and Hellman in the upcoming decades.&lt;&#x2F;p&gt;
&lt;p&gt;One of the big discoveries has been how to make Zero-Knowledge Proofs fast enough for real-world applications. This technology has been around since 1984 but as Diffie also said, “Lots of people working in cryptography have no deep concern with real application issues. They are trying to discover things clever enough to write papers about”. Fortunately for humanity, researchers and engineers have made this technology practical enough in the last decade (especially the last 2 years) to be useful.&lt;&#x2F;p&gt;
&lt;p&gt;The financial system depends on the existence of intermediaries: an army of auditors, regulators, and accountants. The correct working of the financial machine depends on the integrity of its financial institutions. Integrity is maintained due to positive economic incentives and jail time, fines, and costly lawsuits if the intermediaries don’t do what the state and society expect from them. Bitcoin, a result of the 2008 crisis, created a permissionless financial system where its users can send and receive digital money without intermediaries and without anybody being able to block transactions. In countries like Argentina, Nigeria, or Lebanon, where stagnation and inflation erode its citizens&#x27; trust in the financial system and the state, Bitcoin and stablecoins on top of Ethereum are used on a daily basis by the young population to save and avoid capital controls. In developed countries, its usage is not as massive since the traditional financial system and the state is trusted by most citizens. However, the world is becoming more complex. Banks are failing in the US and Europe, a new war is taking place in Europe, debt levels are not sustainable in many countries, the fight between left and the right is retaking the main stage, tension between the West and the East increases, and technological change keeps accelerating.&lt;&#x2F;p&gt;
&lt;p&gt;New applications built on top of unstoppable and trustless technologies that don’t depend on social trust will grow and thrive in this type of environment. Everything is being questioned. Only things that can’t be questioned will fully resist the passage of time. This will happen not only in developing countries but also in developed ones. Systems like Bitcoin, where everyone can verify how it’s running, are more resilient and become more useful by the day in a world that is getting more complex.&lt;&#x2F;p&gt;
&lt;p&gt;Bitcoin&#x27;s focus has been to become a new type of monetary asset and financial network. For this reason, the development of more complex programs on top of Bitcoin has always been restricted by design. Newer blockchains like Ethereum added the ability to create new types of applications. DeFi Protocols that enabled lending and borrowing, exchange of digital currencies and the ability to buy, sell and trade digital collectives and arts rapidly grew on top of Ethereum. However the cost of creating and transferring relevant amounts of assets in blockchains is costly. The ability to create more complex applications that sit on top of blockchains is also very limited. Applications can’t run more than a few milliseconds on Ethereum.&lt;&#x2F;p&gt;
&lt;p&gt;These systems do not rely on social integrity like traditional systems. Instead, they operate as a permissionless and censorship-resistant network, allowing anyone to add a node and submit updates to its state. To ensure verification, each node must re-execute all transactions, which makes the system decentralized and secure, albeit slower than centralized systems. Consequently, this imposes a limitation on the types of applications that can be built on blockchains. Applications requiring frequent database state updates, such as those exceeding a few times per second, or machine learning algorithms, are not feasible on blockchain platforms.&lt;&#x2F;p&gt;
&lt;p&gt;This is where Zero Knowledge Proofs (ZKPs) and other cryptographic and distributed systems primitives will help society create tools that can be used by everyone. ZKPs enable a party to demonstrate a statement to other parties without revealing any information beyond the proof. In more concrete terms, this enables a person to show another person that the computation they did is correct without having to redo it and without even having to grant access to the data that was used. An important aspect of this is that the verification is done in a much faster time than the proving. In even simpler terms, it proves that the output of a certain computation is correct. The verification is way easier and faster to do than the execution or proving. Anybody can check the proof, and this saves computing time and money.&lt;&#x2F;p&gt;
&lt;p&gt;At the beginning it’s difficult to grasp, even for engineers, that such a technology is even possible. The mathematics behind it, until recently, seemed magical, and that’s why it was called moon math. Thanks to ZKPs, transferring money in blockchains similar to Bitcoin is cheaper and way faster since there is no need to re-execute each transaction by each node. Only one node is needed to process all the transactions and prove them using a ZKPs, while the rest simply need to verify it, saving valuable computing resources. Among other things, ZKPs enable creating a financial system that doesn’t depend on social trust like traditional finance and that doesn’t depend as much on re-executing algorithms as Bitcoin.&lt;&#x2F;p&gt;
&lt;p&gt;Zero Knowledge Proofs facilitate the development of an entirely new range of applications that are executed and proven on a single computer outside the blockchain, with verification occurring within Ethereum. The verification cost is way cheaper than the time it takes to prove or execute it. Ethereum will evolve from a slow yet secure distributed mainframe, where execution time is shared among all users to run small programs, into a distributed computer that stores and verifies proofs generated externally from the blockchain.&lt;&#x2F;p&gt;
&lt;p&gt;Not only will blockchains benefit from the development of new cryptographic primitives like Zero Knowledge Proofs (ZKPs), but other areas will also be significantly impacted. As AI-generated content begins to overshadow human-generated content on the internet, ZKPs will become essential for verifying that such content was produced by unbiased AI models. &quot;Proof of humanity&quot; systems are already employing ZKPs to ensure the accurate computation of a human accessing specific resources.&lt;&#x2F;p&gt;
&lt;p&gt;Hardware is another area where ZKPs will make an impact. Similar to how graphics cards in the 1990s revolutionized the video game industry, zero-knowledge hardware acceleration will be integrated into computers to enhance efficiency.&lt;&#x2F;p&gt;
&lt;p&gt;ZKPs can also be utilized to balance storage and computation securely. For instance, security cameras generate vast amounts of data. ZKPs can provide a compact proof that AI models did not detect any critical information in the video, allowing the system to delete the footage and save storage space.&lt;&#x2F;p&gt;
&lt;p&gt;ZKPs will even be used for national security purposes. As energy production shifts from centralized power plants to distributed sources like solar panels and wind turbines, verifying the proper execution of software on their controllers becomes vital. In the coming decades, ZKPs will play a crucial role in securing these devices.&lt;&#x2F;p&gt;
&lt;p&gt;Software industry regulations are inevitable, and industries such as online casinos and ad networks using Real-Time Bidding protocols will be legally required to demonstrate that they have not deceived their clients. Laws protecting users from large tech corporations are already in place in Europe, partly due to concerns about data misuse by foreign powers to influence political campaigns.&lt;&#x2F;p&gt;
&lt;p&gt;Requirements for secure storage and processing of encrypted data will become increasingly necessary. Fully Homomorphic Encryption (FHE), a technology akin to ZKPs, will be one of the tools utilized for this purpose. FHE enables computation on encrypted data, ensuring privacy. As FHE becomes more efficient and practical, most databases will integrate some FHE functionality, preventing administrators from accessing user data directly.&lt;&#x2F;p&gt;
&lt;p&gt;Zero-knowledge proofs (ZKPs), which generate evidence for a third party to confirm the accurate execution of a computation, and Fully Homomorphic Encryption (FHE), which enables calculations on encrypted data, will be combined with distributed systems algorithms that are capable of tolerating significant network failures similar to those employed by Bitcoin. Together they will be utilized to comply with regulations while creating trustless applications.&lt;&#x2F;p&gt;
&lt;p&gt;In the past decade, we have successfully launched applications serving dozens of millions of users. Leveraging our expertise, we are now dedicated to providing both technical and financial support to help others create startups focused on developing and implementing these vital technologies. As society grapples with the challenges of our rapidly evolving world these innovations will prove to be indispensable.&lt;&#x2F;p&gt;
</content>
        
    </entry>
</feed>
